/*
 * FILE : C:\Python27\Source\pywin32-219\win32\src\win32service_swig.cpp
 * 
 * This file was automatically generated by :
 * Simplified Wrapper and Interface Generator (SWIG)
 * Version 1.1 (Patch 5)
 * 
 * Portions Copyright (c) 1995-1998
 * The University of Utah and The Regents of the University of California.
 * Permission is granted to distribute this file in any manner provided
 * this notice remains intact.
 * 
 * Do not make changes to this file--changes will be lost!
 *
 */


#define SWIGCODE
/* Implementation : PYTHON */

#define SWIGPYTHON
#include <string.h>
#include <stdlib.h>
/***********************************************************************
 * $Header$
 * swig_lib/python/python.cfg
 *
 * This file contains coded needed to add variable linking to the
 * Python interpreter.   C variables are added as a new kind of Python
 * datatype.
 *
 * Also contains supporting code for building python under Windows
 * and things like that.
 *
 * $Log$
 * Revision 1.1  2000/03/14 23:34:06  mhammond
 * Needed to modify a standard Swig file to avoid the 'extern "C"' around Python.h (which gets upset when it tries to include whcar.h as part of the new Unicode patches)
 *
 ************************************************************************/

#include "Python.h"

/* Definitions for Windows/Unix exporting */
#if defined(__WIN32__)
#   if defined(_MSC_VER)
#	define SWIGEXPORT(a,b) __declspec(dllexport) a b
#   else
#	if defined(__BORLANDC__)
#	    define SWIGEXPORT(a,b) a _export b
#	else
#	    define SWIGEXPORT(a,b) a b
#	endif
#   endif
#else
#   define SWIGEXPORT(a,b) a b
#endif

#ifdef SWIG_GLOBAL
#ifdef __cplusplus
#define SWIGSTATIC extern "C"
#else
#define SWIGSTATIC
#endif
#endif

#ifndef SWIGSTATIC
#define SWIGSTATIC static
#endif

#ifdef NEED_SWIG_VARLINK

typedef struct {
  char  *name;
  PyObject *(*get_attr)(void);
  int (*set_attr)(PyObject *);
} swig_globalvar;

typedef struct swig_varlinkobject {
  PyObject_HEAD
  swig_globalvar **vars;
  int      nvars;
  int      maxvars;
} swig_varlinkobject;

/* ----------------------------------------------------------------------
   swig_varlink_repr()

   Function for python repr method
   ---------------------------------------------------------------------- */

static PyObject *
swig_varlink_repr(swig_varlinkobject *v)
{
  v = v;
  return PyString_FromString("<Global variables>");
}

/* ---------------------------------------------------------------------
   swig_varlink_print()

   Print out all of the global variable names
   --------------------------------------------------------------------- */

static int
swig_varlink_print(swig_varlinkobject *v, FILE *fp, int flags)
{

  int i = 0;
  flags = flags;
  fprintf(fp,"Global variables { ");
  while (v->vars[i]) {
    fprintf(fp,"%s", v->vars[i]->name);
    i++;
    if (v->vars[i]) fprintf(fp,", ");
  }
  fprintf(fp," }\n");
  return 0;
}

/* --------------------------------------------------------------------
   swig_varlink_getattr
 
   This function gets the value of a variable and returns it as a
   PyObject.   In our case, we'll be looking at the datatype and
   converting into a number or string
   -------------------------------------------------------------------- */

static PyObject *
swig_varlink_getattr(swig_varlinkobject *v, char *n)
{
  int i = 0;
  char temp[128];

  while (v->vars[i]) {
    if (strcmp(v->vars[i]->name,n) == 0) {
      return (*v->vars[i]->get_attr)();
    }
    i++;
  }
  sprintf(temp,"C global variable %s not found.", n);
  PyErr_SetString(PyExc_NameError,temp);
  return NULL;
}

/* -------------------------------------------------------------------
   swig_varlink_setattr()

   This function sets the value of a variable.
   ------------------------------------------------------------------- */

static int
swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p)
{
  char temp[128];
  int i = 0;
  while (v->vars[i]) {
    if (strcmp(v->vars[i]->name,n) == 0) {
      return (*v->vars[i]->set_attr)(p);
    }
    i++;
  }
  sprintf(temp,"C global variable %s not found.", n);
  PyErr_SetString(PyExc_NameError,temp);
  return 1;
}

statichere PyTypeObject varlinktype = {
/*  PyObject_HEAD_INIT(&PyType_Type)  Note : This doesn't work on some machines */
  PyObject_HEAD_INIT(0)              
  0,
  "varlink",                          /* Type name    */
  sizeof(swig_varlinkobject),         /* Basic size   */
  0,                                  /* Itemsize     */
  0,                                  /* Deallocator  */ 
  (printfunc) swig_varlink_print,     /* Print        */
  (getattrfunc) swig_varlink_getattr, /* get attr     */
  (setattrfunc) swig_varlink_setattr, /* Set attr     */
  0,                                  /* tp_compare   */
  (reprfunc) swig_varlink_repr,       /* tp_repr      */    
  0,                                  /* tp_as_number */
  0,                                  /* tp_as_mapping*/
  0,                                  /* tp_hash      */
};

/* Create a variable linking object for use later */

SWIGSTATIC PyObject *
SWIG_newvarlink(void)
{
  swig_varlinkobject *result = 0;
  result = PyMem_NEW(swig_varlinkobject,1);
  varlinktype.ob_type = &PyType_Type;    /* Patch varlinktype into a PyType */
  result->ob_type = &varlinktype;
  /*  _Py_NewReference(result);  Does not seem to be necessary */
  result->nvars = 0;
  result->maxvars = 64;
  result->vars = (swig_globalvar **) malloc(64*sizeof(swig_globalvar *));
  result->vars[0] = 0;
  Py_XINCREF((PyObject *) result);
  return ((PyObject*) result);
}

SWIGSTATIC void
SWIG_addvarlink(PyObject *p, char *name,
	   PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p))
{
  swig_varlinkobject *v;
  v= (swig_varlinkobject *) p;
	
  if (v->nvars >= v->maxvars -1) {
    v->maxvars = 2*v->maxvars;
    v->vars = (swig_globalvar **) realloc(v->vars,v->maxvars*sizeof(swig_globalvar *));
    if (v->vars == NULL) {
      fprintf(stderr,"SWIG : Fatal error in initializing Python module.\n");
      exit(1);
    }
  }
  v->vars[v->nvars] = (swig_globalvar *) malloc(sizeof(swig_globalvar));
  v->vars[v->nvars]->name = (char *) malloc(strlen(name)+1);
  strcpy(v->vars[v->nvars]->name,name);
  v->vars[v->nvars]->get_attr = get_attr;
  v->vars[v->nvars]->set_attr = set_attr;
  v->nvars++;
  v->vars[v->nvars] = 0;
}

#else
#define SWIG_newvarlink() Py_None
#endif /* SWIG_NEED_VARLINK */
#ifdef NEED_SWIG_PTR
/*****************************************************************************
 * $Header$
 *
 * swigptr.swg
 *
 * This file contains supporting code for the SWIG run-time type checking
 * mechanism.  The following functions are available :
 *
 * SWIG_RegisterMapping(char *origtype, char *newtype, void *(*cast)(void *));
 *
 *      Registers a new type-mapping with the type-checker.  origtype is the
 *      original datatype and newtype is an equivalent type.  cast is optional
 *      pointer to a function to cast pointer values between types (this
 *      is typically used to cast pointers from derived classes to base classes in C++)
 *      
 * SWIG_MakePtr(char *buffer, void *ptr, char *typestring);
 *     
 *      Makes a pointer string from a pointer and typestring.  The result is returned
 *      in buffer which is assumed to hold enough space for the result.
 *
 * char * SWIG_GetPtr(char *buffer, void **ptr, char *type)
 *
 *      Gets a pointer value from a string.  If there is a type-mismatch, returns
 *      a character string to the received type.  On success, returns NULL.
 *
 *
 * You can remap these functions by making a file called "swigptr.swg" in
 * your the same directory as the interface file you are wrapping.
 *
 * These functions are normally declared static, but this file can be
 * can be used in a multi-module environment by redefining the symbol
 * SWIGSTATIC.
 *****************************************************************************/

#include <stdlib.h>

#ifdef SWIG_GLOBAL
#ifdef __cplusplus
#define SWIGSTATIC extern "C"
#else
#define SWIGSTATIC
#endif
#endif

#ifndef SWIGSTATIC
#define SWIGSTATIC static
#endif


/* SWIG pointer structure */

typedef struct SwigPtrType {
  char               *name;               /* Datatype name                  */
  int                 len;                /* Length (used for optimization) */
  void               *(*cast)(void *);    /* Pointer casting function       */
  struct SwigPtrType *next;               /* Linked list pointer            */
} SwigPtrType;

/* Pointer cache structure */

typedef struct {
  int                 stat;               /* Status (valid) bit             */
  SwigPtrType        *tp;                 /* Pointer to type structure      */
  char                name[256];          /* Given datatype name            */
  char                mapped[256];        /* Equivalent name                */
} SwigCacheType;

/* Some variables  */

static int SwigPtrMax  = 64;           /* Max entries that can be currently held */
                                       /* This value may be adjusted dynamically */
static int SwigPtrN    = 0;            /* Current number of entries              */
static int SwigPtrSort = 0;            /* Status flag indicating sort            */
static int SwigStart[256];             /* Starting positions of types            */

/* Pointer table */
static SwigPtrType *SwigPtrTable = 0;  /* Table containing pointer equivalences  */

/* Cached values */

#define SWIG_CACHESIZE  8
#define SWIG_CACHEMASK  0x7
static SwigCacheType SwigCache[SWIG_CACHESIZE];  
static int SwigCacheIndex = 0;
static int SwigLastCache = 0;

/* Sort comparison function */
static int swigsort(const void *data1, const void *data2) {
	SwigPtrType *d1 = (SwigPtrType *) data1;
	SwigPtrType *d2 = (SwigPtrType *) data2;
	return strcmp(d1->name,d2->name);
}

/* Binary Search function */
static int swigcmp(const void *key, const void *data) {
  char *k = (char *) key;
  SwigPtrType *d = (SwigPtrType *) data;
  return strncmp(k,d->name,d->len);
}

/* Register a new datatype with the type-checker */

SWIGSTATIC 
void SWIG_RegisterMapping(char *origtype, char *newtype, void *(*cast)(void *)) {

  int i;
  SwigPtrType *t = 0,*t1;

  /* Allocate the pointer table if necessary */

  if (!SwigPtrTable) {     
    SwigPtrTable = (SwigPtrType *) malloc(SwigPtrMax*sizeof(SwigPtrType));
    SwigPtrN = 0;
  }
  /* Grow the table */
  if (SwigPtrN >= SwigPtrMax) {
    SwigPtrMax = 2*SwigPtrMax;
    SwigPtrTable = (SwigPtrType *) realloc((char *) SwigPtrTable,SwigPtrMax*sizeof(SwigPtrType));
  }
  for (i = 0; i < SwigPtrN; i++)
    if (strcmp(SwigPtrTable[i].name,origtype) == 0) {
      t = &SwigPtrTable[i];
      break;
    }
  if (!t) {
    t = &SwigPtrTable[SwigPtrN];
    t->name = origtype;
    t->len = strlen(t->name);
    t->cast = 0;
    t->next = 0;
    SwigPtrN++;
  }

  /* Check for existing entry */

  while (t->next) {
    if ((strcmp(t->name,newtype) == 0)) {
      if (cast) t->cast = cast;
      return;
    }
    t = t->next;
  }
  
  /* Now place entry (in sorted order) */

  t1 = (SwigPtrType *) malloc(sizeof(SwigPtrType));
  t1->name = newtype;
  t1->len = strlen(t1->name);
  t1->cast = cast;
  t1->next = 0;            
  t->next = t1;           
  SwigPtrSort = 0;
}

/* Make a pointer value string */

SWIGSTATIC 
void SWIG_MakePtr(char *_c, const void *_ptr, char *type) {
  static char _hex[16] =
  {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
   'a', 'b', 'c', 'd', 'e', 'f'};
  unsigned long _p, _s;
  char _result[20], *_r;    /* Note : a 64-bit hex number = 16 digits */
  _r = _result;
  _p = (unsigned long) _ptr;
  if (_p > 0) {
    while (_p > 0) {
      _s = _p & 0xf;
      *(_r++) = _hex[_s];
      _p = _p >> 4;
    }
    *_r = '_';
    while (_r >= _result)
      *(_c++) = *(_r--);
  } else {
    strcpy (_c, "NULL");
  }
  if (_ptr)
    strcpy (_c, type);
}

/* Define for backwards compatibility */

#define _swig_make_hex   SWIG_MakePtr 

/* Function for getting a pointer value */

SWIGSTATIC 
char *SWIG_GetPtr(char *_c, void **ptr, char *_t)
{
  unsigned long _p;
  char temp_type[256];
  char *name;
  int  i, len;
  SwigPtrType *sp,*tp;
  SwigCacheType *cache;
  int  start, end;
  _p = 0;

  /* Pointer values must start with leading underscore */
  if (*_c == '_') {
      _c++;
      /* Extract hex value from pointer */
      while (*_c) {
	  if ((*_c >= '0') && (*_c <= '9'))
	    _p = (_p << 4) + (*_c - '0');
	  else if ((*_c >= 'a') && (*_c <= 'f'))
	    _p = (_p << 4) + ((*_c - 'a') + 10);
	  else
	    break;
	  _c++;
      }

      if (_t) {
	if (strcmp(_t,_c)) { 
	  if (!SwigPtrSort) {
	    qsort((void *) SwigPtrTable, SwigPtrN, sizeof(SwigPtrType), swigsort); 
	    for (i = 0; i < 256; i++) {
	      SwigStart[i] = SwigPtrN;
	    }
	    for (i = SwigPtrN-1; i >= 0; i--) {
	      SwigStart[(int) (SwigPtrTable[i].name[1])] = i;
	    }
	    for (i = 255; i >= 1; i--) {
	      if (SwigStart[i-1] > SwigStart[i])
		SwigStart[i-1] = SwigStart[i];
	    }
	    SwigPtrSort = 1;
	    for (i = 0; i < SWIG_CACHESIZE; i++)  
	      SwigCache[i].stat = 0;
	  }
	  
	  /* First check cache for matches.  Uses last cache value as starting point */
	  cache = &SwigCache[SwigLastCache];
	  for (i = 0; i < SWIG_CACHESIZE; i++) {
	    if (cache->stat) {
	      if (strcmp(_t,cache->name) == 0) {
		if (strcmp(_c,cache->mapped) == 0) {
		  cache->stat++;
		  *ptr = (void *) _p;
		  if (cache->tp->cast) *ptr = (*(cache->tp->cast))(*ptr);
		  return (char *) 0;
		}
	      }
	    }
	    SwigLastCache = (SwigLastCache+1) & SWIG_CACHEMASK;
	    if (!SwigLastCache) cache = SwigCache;
	    else cache++;
	  }
	  /* We have a type mismatch.  Will have to look through our type
	     mapping table to figure out whether or not we can accept this datatype */

	  start = SwigStart[(int) _t[1]];
	  end = SwigStart[(int) _t[1]+1];
	  sp = &SwigPtrTable[start];
	  while (start < end) {
	    if (swigcmp(_t,sp) == 0) break;
	    sp++;
	    start++;
	  }
	  if (start >= end) sp = 0;
	  /* Try to find a match for this */
	  if (sp) {
	    while (swigcmp(_t,sp) == 0) {
	      name = sp->name;
	      len = sp->len;
	      tp = sp->next;
	      /* Try to find entry for our given datatype */
	      while(tp) {
		if (tp->len >= 255) {
		  return _c;
		}
		strncpy(temp_type,tp->name,255);
		strncat(temp_type,_t+len,255-tp->len);
		if (strcmp(_c,temp_type) == 0) {
		  
		  strcpy(SwigCache[SwigCacheIndex].mapped,_c);
		  strcpy(SwigCache[SwigCacheIndex].name,_t);
		  SwigCache[SwigCacheIndex].stat = 1;
		  SwigCache[SwigCacheIndex].tp = tp;
		  SwigCacheIndex = SwigCacheIndex & SWIG_CACHEMASK;
		  
		  /* Get pointer value */
		  *ptr = (void *) _p;
		  if (tp->cast) *ptr = (*(tp->cast))(*ptr);
		  return (char *) 0;
		}
		tp = tp->next;
	      }
	      sp++;
	      /* Hmmm. Didn't find it this time */
	    }
	  }
	  /* Didn't find any sort of match for this data.  
	     Get the pointer value and return the received type */
	  *ptr = (void *) _p;
	  return _c;
	} else {
	  /* Found a match on the first try.  Return pointer value */
	  *ptr = (void *) _p;
	  return (char *) 0;
	}
      } else {
	/* No type specified.  Good luck */
	*ptr = (void *) _p;
	return (char *) 0;
      }
  } else {
    if (strcmp (_c, "NULL") == 0) {
	*ptr = (void *) 0;
	return (char *) 0;
    }
    *ptr = (void *) 0;	
    return _c;
  }
}

/* Compatibility mode */

#define _swig_get_hex  SWIG_GetPtr

#else
#define SWIG_RegisterMapping(a,b,c)
#endif // NEED_SWIG_PTR
#define SWIG_init    initwin32service

#define SWIG_name    "win32service"

static PyObject* t_output_helper(PyObject* target, PyObject* o) {
    PyObject*   o2;
    PyObject*   o3;

    if (!target) {                   
        target = o;
    } else if (target == Py_None) {  
        Py_DECREF(Py_None);
        target = o;
    } else {                            
        if (!PyTuple_Check(target)) {   
            o2 = target;
            target = PyTuple_New(1);
            PyTuple_SetItem(target, 0, o2);
        }
        o3 = PyTuple_New(1);            
        PyTuple_SetItem(o3, 0, o);      

        o2 = target;
        target = PySequence_Concat(o2, o3); 
        Py_DECREF(o2);                      
        Py_DECREF(o3);
    }
    return target;
}

#include "PyWinTypes.h"
#ifdef NEED_PYWINOBJECTS_H
#include "PyWinObjects.h"
#endif
#include "tchar.h"
typedef BOOL  BOOLAPI;
typedef DWORD  DWORDAPI;

#define PyHANDLE HANDLE // Use a #define so we can undef it later if we need the true defn.
//typedef HANDLE PyHKEY;

#undef PyHANDLE
#include "PyWinObjects.h"
#include "Dbt.h" // for device events

typedef BOOL (WINAPI *QueryServiceStatusExfunc)(SC_HANDLE,SC_STATUS_TYPE,LPBYTE,DWORD,LPDWORD);
QueryServiceStatusExfunc fpQueryServiceStatusEx=NULL;
typedef BOOL (WINAPI *ChangeServiceConfig2func)(SC_HANDLE,DWORD,LPVOID);
ChangeServiceConfig2func fpChangeServiceConfig2=NULL;
typedef BOOL (WINAPI *QueryServiceConfig2func)(SC_HANDLE,DWORD,LPBYTE,DWORD,LPDWORD);
QueryServiceConfig2func fpQueryServiceConfig2=NULL;
typedef BOOL (WINAPI *EnumServicesStatusExfunc)(SC_HANDLE,SC_ENUM_TYPE,DWORD,DWORD,
	LPBYTE,DWORD,LPDWORD,LPDWORD,LPDWORD,LPCTSTR);
EnumServicesStatusExfunc fpEnumServicesStatusEx=NULL;

// according to msdn, 256 is limit for service names and service display names
#define MAX_SERVICE_NAME_LEN 256   


#include "structmember.h"

// @object PySC_HANDLE|Handle to a service or service control manager.
//	This is a variant of <o PyHANDLE> that releases its handle using CloseServiceHandle.
class PySC_HANDLE: public PyHANDLE
{
public:
	PySC_HANDLE(HANDLE hInit) : PyHANDLE(hInit) {}
	virtual BOOL Close(void){
		BOOL ret=TRUE;
		if (m_handle!=NULL){
			ret=CloseServiceHandle((SC_HANDLE)m_handle);
			m_handle = NULL;
			}
		if (!ret)
			PyWin_SetAPIError("CloseServiceHandle");
		return ret;
		}
	virtual const char *GetTypeName(){
		return "PySC_HANDLE";
		}
};

PyObject *PyWinObject_FromSC_HANDLE(SC_HANDLE sch)
{
	PyObject *ret=new PySC_HANDLE(sch);
	if (ret==NULL)
		PyErr_NoMemory();
	return ret;
}

// @object PyHWINSTA|Wrapper for a handle to a window station - returned by CreateWindowStation, OpenWindowStation, or GetProcessWindowStation
class PyHWINSTA : public PyHANDLE
{
public:
	PyHWINSTA(HWINSTA hwinsta);
	~PyHWINSTA(void);
	static void deallocFunc(PyObject *ob);
	static PyObject *EnumDesktops(PyObject *self, PyObject *args);
	static PyObject *SetProcessWindowStation(PyObject *self, PyObject *args);
	static PyObject *CloseWindowStation(PyObject *self, PyObject *args);
	static struct PyMemberDef members[];
	static struct PyMethodDef methods[]; 
	static PyObject *PyHWINSTA_new(PyTypeObject *tp, PyObject *args, PyObject *kwargs);
};

struct PyMethodDef PyHWINSTA::methods[] = {
	{"EnumDesktops",			PyHWINSTA::EnumDesktops, METH_VARARGS, "List desktop names within the window station"}, 	// @pymeth EnumDesktops|List desktop names within the window station
	{"SetProcessWindowStation",	PyHWINSTA::SetProcessWindowStation, METH_VARARGS, "Associates the calling process with the window station"}, // @pymeth SetProcessWindowStation|Associates the calling process with the window station
	{"CloseWindowStation",		PyHWINSTA::CloseWindowStation, METH_VARARGS, "Closes the window station handle"}, // @pymeth CloseWindowStation|Closes the window station handle
	{"Detach",					PyHANDLE::Detach, METH_VARARGS, "Releases reference to handle without closing it"}, //@pymeth Detach|Releases reference to handle without closing it
	{NULL}
};

struct PyMemberDef PyHWINSTA::members[] = {
	// ??? offsetof not working correctly ??? 
	// {"handle", T_LONG, offsetof(PyHWINSTA,m_handle), READONLY, "For use where an integer handle is required"},
	{NULL}
};

PyObject *PyHWINSTA::PyHWINSTA_new(PyTypeObject *tp, PyObject *args, PyObject *kwargs)
{
	static char *keywords[]={"handle",0};
	HWINSTA hwinsta;
	PyObject *obh;
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O", keywords, &obh))
		return NULL;
	if (!PyWinObject_AsHANDLE(obh, (HANDLE *)&hwinsta))
		return NULL;
	return new PyHWINSTA(hwinsta);
}

PyTypeObject PyHWINSTAType =
{
	PYWIN_OBJECT_HEAD
	"PyHWINSTA",
	sizeof(PyHWINSTA),
	0,
	PyHWINSTA::deallocFunc,		/* tp_dealloc */
	0,							/* tp_print */
	0,							/* tp_getattr */
	0,							/* tp_setattr */
	0,							/* tp_compare */
	0,							/* tp_repr */
	PyHANDLEType.tp_as_number,	/* tp_as_number */
	0,							/* tp_as_sequence */
	0,							/* tp_as_mapping */
	0,
	0,							/* tp_call */
	0,							/* tp_str */
	PyObject_GenericGetAttr,
	PyObject_GenericSetAttr,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	PyHWINSTA::methods,
	PyHWINSTA::members,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	PyHWINSTA::PyHWINSTA_new
};

#define PyHWINSTA_Check(ob)	((ob)->ob_type == &PyHWINSTAType)

PyHWINSTA::PyHWINSTA(HWINSTA hwinsta) : PyHANDLE((HANDLE)hwinsta)
{
	ob_type = &PyHWINSTAType;
}
PyHWINSTA::~PyHWINSTA(void)
{
	::CloseWindowStation((HWINSTA)m_handle);
}

void PyHWINSTA::deallocFunc(PyObject *ob)
{
	delete (PyHWINSTA *)ob;
}


// @object PyHDESK|Object representing a handle to a desktop, created by 
// <om win32service.CreateDesktop>, <om win32service.GetThreadDesktop> and <om win32service.OpenDesktop>.

class PyHDESK : public PyHANDLE
{
public:
	PyHDESK(HDESK hdesk);
	~PyHDESK(void);
	static void deallocFunc(PyObject *ob);
	static PyObject *SetThreadDesktop(PyObject *self, PyObject *args);
	static PyObject *EnumDesktopWindows(PyObject *self, PyObject *args);
	static PyObject *SwitchDesktop(PyObject *self, PyObject *args);
	static PyObject *CloseDesktop(PyObject *self, PyObject *args);
	static struct PyMemberDef members[];
	static struct PyMethodDef methods[];
	static PyObject *PyHDESK_new(PyTypeObject *tp, PyObject *args, PyObject *kwargs);
};

struct PyMethodDef PyHDESK::methods[] = {
	{"SetThreadDesktop",	PyHDESK::SetThreadDesktop, METH_VARARGS, "Assigns desktop to calling thread"}, // @pymeth SetThreadDesktop|Assigns desktop to calling thread
	{"EnumDesktopWindows",	PyHDESK::EnumDesktopWindows, METH_VARARGS, "Lists all top-level windows on the desktop"}, 	// @pymeth EnumDesktopWindows|Lists all top-level windows on the desktop
	{"SwitchDesktop",		PyHDESK::SwitchDesktop, METH_VARARGS, "Activates the desktop"}, 	// @pymeth SwitchDesktop|Activates the desktop
	{"CloseDesktop",		PyHDESK::CloseDesktop, METH_VARARGS, "Closes the handle"}, //@pymeth CloseDesktop|Closes the desktop handle
	{"Detach",				PyHANDLE::Detach, METH_VARARGS, "Releases reference to handle without closing it"}, //@pymeth Detach|Releases reference to handle without closing it
	{NULL}
};

struct PyMemberDef PyHDESK::members[] = {
	// {"handle", T_LONG, offsetof(PyHDESK,m_handle), READONLY, "For use where an integer handle is required"},
	{NULL}
};

PyObject *PyHDESK::PyHDESK_new(PyTypeObject *tp, PyObject *args, PyObject *kwargs)
{
	static char *keywords[]={"handle",0};
	HDESK hdesk;
	PyObject *obh;
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O", keywords, &obh))
		return NULL;
	if (!PyWinObject_AsHANDLE(obh, (HANDLE *)&hdesk))
		return NULL;
	return new PyHDESK(hdesk);
}

PyTypeObject PyHDESKType =
{
	PYWIN_OBJECT_HEAD
	"PyHDESK",
	sizeof(PyHDESK),
	0,
	PyHDESK::deallocFunc,		/* tp_dealloc */
	0,							/* tp_print */
	0,							/* tp_getattr */
	0,							/* tp_setattr */
	0,							/* tp_compare */
	0,							/* tp_repr */
	PyHANDLEType.tp_as_number,	/* tp_as_number */
	0,							/* tp_as_sequence */
	0,							/* tp_as_mapping */
	0,							/* tp_hash */
	0,							/* tp_call */
	0,							/* tp_str */
	PyObject_GenericGetAttr,
	PyObject_GenericSetAttr,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	PyHDESK::methods,
	PyHDESK::members,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	PyHDESK::PyHDESK_new
};

#define PyHDESK_Check(ob)	((ob)->ob_type == &PyHDESKType)

PyHDESK::PyHDESK(HDESK hdesk) : PyHANDLE((HANDLE)hdesk)
{
	ob_type = &PyHDESKType;
}

PyHDESK::~PyHDESK(void)
{
	::CloseDesktop((HDESK)m_handle);
}

void PyHDESK::deallocFunc(PyObject *ob)
{
	delete (PyHDESK *)ob;
}

BOOL CALLBACK EnumWindowStationProc(LPWSTR winstaname, LPARAM ret)
{
	PyObject *obwinstaname=PyWinObject_FromWCHAR(winstaname);
	if (obwinstaname==NULL)
		return FALSE;
	PyList_Append((PyObject *)ret,obwinstaname);
	Py_DECREF(obwinstaname);
	return TRUE;
}

BOOL CALLBACK EnumDesktopsProc(LPWSTR desktopname, LPARAM ret)
{
	PyObject *obdesktopname=PyWinObject_FromWCHAR(desktopname);
	if (obdesktopname==NULL)
		return FALSE;
	PyList_Append((PyObject *)ret,obdesktopname);
	Py_DECREF(obdesktopname);
	return TRUE;
}

BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM ret)
{
	PyObject *obhandle=PyWinObject_FromHANDLE(hwnd);
	if (obhandle==NULL)
		return FALSE;
	PyList_Append((PyObject *)ret,obhandle);
	Py_DECREF(obhandle);
	return TRUE;
}

// @pymethod (PyUNICODE,...)|PyHWINSTA|EnumDesktops|Lists names of desktops in the window station
PyObject *PyHWINSTA::EnumDesktops(PyObject *self, PyObject *args)
{
	if (!PyArg_ParseTuple(args, ":EnumDesktops"))
		return NULL;
	PyObject *ret=PyList_New(0);
	if (ret==NULL)
		return NULL;
	if (!::EnumDesktopsW((HWINSTA)((PyHWINSTA *)self)->m_handle, EnumDesktopsProc, (LPARAM)ret)){
		Py_DECREF(ret);
		ret=NULL;
		if (!PyErr_Occurred())
			PyWin_SetAPIError("EnumDesktops",GetLastError());
		}
	return ret;
}

// @pymethod |PyHWINSTA|SetProcessWindowStation|Associates the calling process with the window station
PyObject *PyHWINSTA::SetProcessWindowStation(PyObject *self, PyObject *args)
{
	if (!PyArg_ParseTuple(args, ":SetProcessWindowStation"))
		return NULL;
	if (!::SetProcessWindowStation((HWINSTA)((PyHWINSTA *)self)->m_handle))
		return PyWin_SetAPIError("SetProcessWindowStation",GetLastError());
	Py_INCREF(Py_None);
	return Py_None;
}

// @pymethod |PyHWINSTA|CloseWindowStation|Closes the window station handle
// @comm This function cannot close the handle to current process's window station 
PyObject *PyHWINSTA::CloseWindowStation(PyObject *self, PyObject *args)
{
	if (!PyArg_ParseTuple(args, ":CloseWindowStation"))
		return NULL;
	if (!::CloseWindowStation((HWINSTA)((PyHWINSTA *)self)->m_handle))
		return PyWin_SetAPIError("CloseWindowStation",GetLastError());
	Py_INCREF(Py_None);
	return Py_None;
}

// @pymethod |PyHDESK|SetThreadDesktop|Assigns this desktop to the calling thread
PyObject *PyHDESK::SetThreadDesktop(PyObject *self, PyObject *args)
{
	if (!PyArg_ParseTuple(args, ":SetThreadDesktop"))
		return NULL;
	if (!::SetThreadDesktop((HDESK)((PyHDESK *)self)->m_handle))
		return PyWin_SetAPIError("SetThreadDesktop",GetLastError());
	Py_INCREF(Py_None);
	return Py_None;
}

// @pymethod |PyHDESK|SwitchDesktop|Activates the desktop
PyObject *PyHDESK::SwitchDesktop(PyObject *self, PyObject *args)
{
	if (!PyArg_ParseTuple(args, ":SwitchDesktop"))
		return NULL;
	if (!::SwitchDesktop((HDESK)((PyHDESK *)self)->m_handle))
		return PyWin_SetAPIError("SwitchDesktop",GetLastError());
	Py_INCREF(Py_None);
	return Py_None;
}

// @pymethod |PyHDESK|CloseDesktop|Closes the desktop handle
PyObject *PyHDESK::CloseDesktop(PyObject *self, PyObject *args)
{
	if (!PyArg_ParseTuple(args, ":CloseDesktop"))
		return NULL;
	if (!::CloseDesktop((HDESK)((PyHDESK *)self)->m_handle))
		return PyWin_SetAPIError("CloseDesktop",GetLastError());
	Py_INCREF(Py_None);
	return Py_None;
}

// @pymethod (<o PyHANDLE>,...)|PyHDESK|EnumDesktopWindows|Returns a list of handles to all top-level windows on desktop
PyObject *PyHDESK::EnumDesktopWindows(PyObject *self, PyObject *args)
{
	if (!PyArg_ParseTuple(args, ":EnumDesktopWindows"))
		return NULL;
	PyObject *ret=PyList_New(0);
	if (ret==NULL)
		return NULL;
	if (!::EnumDesktopWindows((HDESK)((PyHDESK *)self)->m_handle, EnumWindowsProc, (LPARAM)ret)){
		Py_DECREF(ret);
		ret=NULL;
		if (!PyErr_Occurred())
			PyWin_SetAPIError("EnumDesktopWindows",GetLastError());
		}
	return ret;
}

PyObject *PyGetThreadDesktop(PyObject *self, PyObject *args)
{
	DWORD tid;
	HDESK hdesk;
	// @pyparm int|ThreadId||Id of thread
	if (!PyArg_ParseTuple(args, "l:GetThreadDesktop", &tid))
		return NULL;
	hdesk=GetThreadDesktop(tid);
	if (hdesk==NULL)
		return PyWin_SetAPIError("GetThreadDesktop",GetLastError());
	return new PyHDESK(hdesk);
}

PyObject *PyEnumWindowStations(PyObject *self, PyObject *args)
{
	if (!PyArg_ParseTuple(args, ":EnumWindowStations"))
		return NULL;
	PyObject *ret=PyList_New(0);
	if (ret==NULL)
		return NULL;
	if (!EnumWindowStationsW(EnumWindowStationProc, (LPARAM)ret)){
		Py_DECREF(ret);
		ret=NULL;
		if (!PyErr_Occurred())
			PyWin_SetAPIError("EnumWindowStations",GetLastError());
		}
	return ret;
}

PyObject *PyGetUserObjectInformation(PyObject *self, PyObject *args)
{
	HANDLE handle;
	DWORD origbuflen=128, reqdbuflen=0, err;
#ifdef Py_DEBUG
	origbuflen=3;
#endif
	void *buf=NULL;
	PyObject *obhandle, *ret=NULL;
	BOOL bsuccess;
	int info_type;
	// @pyparm <o PyHANDLE>|Handle||Handle to window station or desktop
	// @pyparm int|type||Type of info to return, one of UOI_FLAGS,UOI_NAME, UOI_TYPE, or UOI_USER_SID
	if (!PyArg_ParseTuple(args, "Ol:GetUserObjectInformation", &obhandle, &info_type))
		return NULL;
	if (!PyWinObject_AsHANDLE(obhandle, &handle))
		return NULL;
	buf=malloc(origbuflen);
	if (buf==NULL)
		return PyErr_Format(PyExc_MemoryError, "GetUserObjectInformation unable to allocate %d bytes", origbuflen);
	bsuccess=GetUserObjectInformationW(handle, info_type, buf, origbuflen, &reqdbuflen);
	if (!bsuccess){
		err=GetLastError();
		if (err==ERROR_INSUFFICIENT_BUFFER){
			free(buf);
			buf=malloc(reqdbuflen);
			if (buf==NULL)
				return PyErr_Format(PyExc_MemoryError, "GetUserObjectInformation unable to allocate %d bytes", reqdbuflen);
			bsuccess=GetUserObjectInformationW(handle, info_type, buf, reqdbuflen, &reqdbuflen);
			if (!bsuccess)
				err=GetLastError();
			}	
		}
	if (!bsuccess)
		PyWin_SetAPIError("GetUserObjectInformation",err);
	else
		switch(info_type){
			case UOI_NAME:
			case UOI_TYPE:{
				ret=PyWinObject_FromWCHAR((WCHAR *)buf);
				break;
				}
			case UOI_USER_SID:{
				if (reqdbuflen==0){
					Py_INCREF(Py_None);
					ret=Py_None;
					}
				else
					ret=PyWinObject_FromSID((PSID)buf);
				break;
				}
			case UOI_FLAGS:{
				ret=Py_BuildValue("{s:N,s:N,s:l}",
				 "Inherit",		PyBool_FromLong(((USEROBJECTFLAGS *)buf)->fInherit),
				 "Reserved",	PyBool_FromLong(((USEROBJECTFLAGS *)buf)->fReserved),
				 "Flags",		((USEROBJECTFLAGS *)buf)->dwFlags);
				 break;
				 }
			default:
				PyErr_SetString(PyExc_NotImplementedError,"Type of information is not supported yet");
				break;
			}
	if (buf)
		free (buf);
	return ret;
}

PyObject *PySetUserObjectInformation(PyObject *self, PyObject *args)
{
	HANDLE handle;
	USEROBJECTFLAGS uof;
	DWORD buflen=sizeof(USEROBJECTFLAGS);
	int info_type=UOI_FLAGS;
	PyObject *obhandle, *obinfo;
	static char *uof_members[]={"Inherit", "Reserved", "Flags", 0};
	static char *uof_format="Object must be a dictionary containing {'Inherit':bool, 'Reserved':bool, 'Flags':int}";
	// @pyparm <o PyHANDLE>|Handle||Handle to window station or desktop
	// @pyparm object|info||Information to set for handle, currently only a dictionary representing USEROBJECTFLAGS struct
	// @pyparm int|type|UOI_FLAGS|Type of info to set, currently only accepts UOI_FLAGS
	if (!PyArg_ParseTuple(args,"OO|l:SetUserObjectInformation", &obhandle, &obinfo, &info_type))
		return NULL;
	if (!PyWinObject_AsHANDLE(obhandle, &handle))
		return NULL;
	if (info_type!=UOI_FLAGS){
		PyErr_SetString(PyExc_TypeError,"Only UOI_FLAGS currently supported");
		return NULL;
		}
	if (!PyDict_Check(obinfo)){
		PyErr_SetString(PyExc_TypeError,uof_format);
		return NULL;
		}
	PyObject *dummy_tuple=PyTuple_New(0);
	if (!PyArg_ParseTupleAndKeywords(dummy_tuple, obinfo, "lll", uof_members, &uof.fInherit, &uof.fReserved, &uof.dwFlags)){
	 	PyErr_SetString(PyExc_TypeError,uof_format);
		return NULL;
		}
	if (!SetUserObjectInformationW(handle, info_type, (void *)&uof, buflen))
		return PyWin_SetAPIError("SetUserObjectInformation",GetLastError());
	Py_INCREF(Py_None);
	return Py_None;
}

PyObject *PyOpenWindowStation(PyObject *self, PyObject *args)
{
	WCHAR *winsta_name=NULL;
	BOOL Inherit;
	ACCESS_MASK DesiredAccess;
	PyObject *obwinsta_name, *ret=NULL;
	HWINSTA hwinsta;
	// @pyparm str/PyUNICODE|szWinSta||Name of window station
	// @pyparm Bool|Inherit||Allow handle to be inherited by subprocesses
	// @pyparm int|DesiredAccess||Bitmask of access types
	if (!PyArg_ParseTuple(args,"Oll:OpenWindowStation",&obwinsta_name, &Inherit, &DesiredAccess))
		return NULL;
	if (!PyWinObject_AsWCHAR(obwinsta_name,&winsta_name,FALSE))
		return NULL;
	hwinsta=OpenWindowStationW(winsta_name,Inherit,DesiredAccess);
	if (hwinsta==NULL)
		PyWin_SetAPIError("OpenWindowStation",GetLastError());
	else
		ret= new PyHWINSTA(hwinsta);
	PyWinObject_FreeWCHAR(winsta_name);
	return ret;
}

PyObject *PyOpenDesktop(PyObject *self, PyObject *args)
{
	WCHAR *desktop_name=NULL;
	BOOL Inherit;
	ACCESS_MASK DesiredAccess;
	DWORD Flags;
	PyObject *obdesktop_name, *ret=NULL;
	HDESK hdesk;
	// @pyparm str/unicode|szDesktop||Name of desktop to open
	// @pyparm int|Flags||DF_ALLOWOTHERACCOUNTHOOK or 0
	// @pyparm bool|Inherit||Allow handle to be inherited
	// @pyparm int|DesiredAccess||ACCESS_MASK specifying level of access for handle
	if (!PyArg_ParseTuple(args,"Olll:OpenWindowStation",&obdesktop_name, &Flags, &Inherit, &DesiredAccess))
		return NULL;
	if (!PyWinObject_AsWCHAR(obdesktop_name,&desktop_name,FALSE))
		return NULL;
	hdesk=OpenDesktopW(desktop_name, Flags, Inherit,DesiredAccess);
	if (hdesk==NULL)
		PyWin_SetAPIError("OpenDesktop",GetLastError());
	else
		ret= new PyHDESK(hdesk);
	PyWinObject_FreeWCHAR(desktop_name);
	return ret;
}

PyObject *PyCreateDesktop(PyObject *self, PyObject *args)
{
	PyObject *obDesktop, *obSA=NULL, *ret=NULL;
	WCHAR *Desktop=NULL;
	DWORD Flags;
	ACCESS_MASK DesiredAccess;
	PSECURITY_ATTRIBUTES pSA;
	HDESK hdesk;
	// @pyparm str/unicode|Desktop||Name of desktop to create
	// @pyparm int|Flags||DF_ALLOWOTHERACCOUNTHOOK or 0
	// @pyparm int|DesiredAccess||An ACCESS_MASK determining level of access available thru returned handle
	// @pyparm <o PySECURITY_ATTRIBUTES>|SecurityAttributes||Specifies inheritance and controls access to desktop
	if (!PyArg_ParseTuple(args,"OllO:CreateDesktop", &obDesktop, &Flags, &DesiredAccess, &obSA))
		return NULL;
	if (!PyWinObject_AsSECURITY_ATTRIBUTES(obSA, &pSA, TRUE))
		return NULL;
	if (!PyWinObject_AsWCHAR(obDesktop, &Desktop, FALSE))
		return NULL;

	hdesk=CreateDesktopW(Desktop,NULL,NULL,Flags,DesiredAccess, pSA);
	if (hdesk==NULL)
		PyWin_SetAPIError("CreateDesktop",GetLastError());
	else
		ret= new PyHDESK(hdesk);

	PyWinObject_FreeWCHAR(Desktop);
	return ret;
}

PyObject *PyOpenInputDesktop(PyObject *self, PyObject *args)
{
	DWORD Flags;
	BOOL Inherit;
	ACCESS_MASK DesiredAccess;
	HDESK hdesk;
	// @pyparm int|Flags||DF_ALLOWOTHERACCOUNTHOOK or 0
	// @pyparm bool|Inherit||Specifies if handle will be inheritable
	// @pyparm int|DesiredAccess||ACCESS_MASK specifying access available to returned handle
	if (!PyArg_ParseTuple(args,"lll:OpenInputDesktop",&Flags,&Inherit,&DesiredAccess))
		return NULL;
	hdesk=OpenInputDesktop(Flags,Inherit,DesiredAccess);
	if (hdesk==NULL)
		return PyWin_SetAPIError("OpenInputDesktop",GetLastError());
	return new PyHDESK(hdesk);
}

PyObject *PyGetProcessWindowStation(PyObject *self, PyObject *args)
{
	HWINSTA hwinsta;
	if (!PyArg_ParseTuple(args,":GetProcessWindowStation"))
		return NULL;
	hwinsta=::GetProcessWindowStation();
	if (hwinsta==NULL)
		return PyWin_SetAPIError("GetProcessWindowStation",GetLastError());
	return new PyHWINSTA(hwinsta);
}

PyObject *PyCreateWindowStation(PyObject *self, PyObject *args)
{
	HWINSTA hwinsta;
	WCHAR *winsta_name;
	DWORD Flags;
	ACCESS_MASK DesiredAccess;
	PSECURITY_ATTRIBUTES pSA;
	PyObject *obwinsta_name, *obSA;
	// @pyparm str/unicode|WindowStation||Name of window station to create, or None
	// @pyparm int|Flags||CWF_CREATE_ONLY or 0
	// @pyparm int|DesiredAccess||Bitmask of access types available to returned handle
	// @pyparm <o PySECURITY_ATTRIBUTES>|SecurityAttributes||Specifies security for window station, and whether handle is inheritable
	if (!PyArg_ParseTuple(args,"OllO:CreateWindowStation", &obwinsta_name, &Flags, &DesiredAccess, &obSA))
		return NULL;
	if (!PyWinObject_AsSECURITY_ATTRIBUTES(obSA, &pSA, TRUE))
		return NULL;
	if (!PyWinObject_AsWCHAR(obwinsta_name, &winsta_name, TRUE))
		return NULL;
	hwinsta=CreateWindowStationW(winsta_name, Flags, DesiredAccess, pSA);
	PyWinObject_FreeWCHAR(winsta_name); 
	if (hwinsta==NULL)
		return PyWin_SetAPIError("CreateWindowStation",GetLastError());
	return new PyHWINSTA(hwinsta);
}

PyObject *MyCreateService(
    SC_HANDLE hSCManager,	// handle to service control manager database  
    TCHAR *lpServiceName,	// pointer to name of service to start 
    TCHAR *lpDisplayName,	// pointer to display name 
    DWORD dwDesiredAccess,	// type of access to service 
    DWORD dwServiceType,	// type of service 
    DWORD dwStartType,		// when to start service 
    DWORD dwErrorControl,	// severity if service fails to start 
    TCHAR * lpBinaryPathName,	// pointer to name of binary file 
    TCHAR * lpLoadOrderGroup,	// pointer to name of load ordering group 
    BOOL  bFetchTag,
    PyObject *obDeps,		// array of dependency names 
    TCHAR *lpServiceStartName,	// pointer to account name of service 
    TCHAR *lpPassword 	// pointer to password for service account 
   )
{
	PyObject *rc = NULL;
	TCHAR *lpDeps = NULL;
	DWORD tagID;
	DWORD *pTagID = bFetchTag ? &tagID : NULL;
	SC_HANDLE sh = 0;
	if (!PyWinObject_AsMultipleString(obDeps, &lpDeps, TRUE))
		goto cleanup;

	sh = CreateService(hSCManager,lpServiceName,lpDisplayName,dwDesiredAccess,
	                             dwServiceType, dwStartType, dwErrorControl, lpBinaryPathName,
	                             lpLoadOrderGroup, pTagID, lpDeps, lpServiceStartName, lpPassword);
	if (sh==0) {
		PyWin_SetAPIError("CreateService");
		rc = NULL;
	} else {
		if (bFetchTag)
			rc = Py_BuildValue("Nl", PyWinObject_FromSC_HANDLE(sh), tagID);
		else
			rc = PyWinObject_FromSC_HANDLE(sh);
	}
cleanup:
	PyWinObject_FreeMultipleString(lpDeps);
	return rc;
		
}

PyObject *MyChangeServiceConfig(
    SC_HANDLE hSCManager,	// handle to service control manager database  
    DWORD dwServiceType,	// type of service 
    DWORD dwStartType,		// when to start service 
    DWORD dwErrorControl,	// severity if service fails to start 
    TCHAR * lpBinaryPathName,	// pointer to name of binary file 
    TCHAR * lpLoadOrderGroup,	// pointer to name of load ordering group 
    BOOL  bFetchTag,
    PyObject *obDeps,		// array of dependency names 
    TCHAR *lpServiceStartName,	// pointer to account name of service 
    TCHAR *lpPassword, 	// pointer to password for service account 
    TCHAR *lpDisplayName	// pointer to display name 
   )
{
	PyObject *rc = NULL;
	TCHAR *lpDeps = NULL;
	DWORD tagID;
	DWORD *pTagID = bFetchTag ? &tagID : NULL;
	SC_HANDLE sh = 0;
	if (!PyWinObject_AsMultipleString(obDeps, &lpDeps, TRUE))
		goto cleanup;

	if (!ChangeServiceConfig(hSCManager,
                         dwServiceType, dwStartType, dwErrorControl, lpBinaryPathName,
                         lpLoadOrderGroup, pTagID, lpDeps, lpServiceStartName, lpPassword,
						 lpDisplayName))
		rc = PyWin_SetAPIError("ChangeServiceConfig");
	else if (bFetchTag)
		rc = PyInt_FromLong(tagID);
	else {
		rc = Py_None;
		Py_INCREF(rc);
	}
cleanup:
	PyWinObject_FreeMultipleString(lpDeps);
	return rc;
		
}

PyObject *MyStartService( SC_HANDLE scHandle, PyObject *serviceArgs )
{
	LPWSTR *pArgs;
	DWORD numStrings = 0;
	if (!PyWinObject_AsWCHARArray(serviceArgs, &pArgs, &numStrings, TRUE))
		return NULL;

	PyObject *rc;
	if (StartService(scHandle, numStrings, (LPCWSTR *)pArgs)) {
		rc = Py_None;
		Py_INCREF(Py_None);
	} else
		rc = PyWin_SetAPIError("StartService");
	PyWinObject_FreeWCHARArray(pArgs, numStrings);
	return rc;
}

static PyObject *MyEnumServicesStatus(PyObject *self, PyObject *args)
{
	// @pyparm <o PySC_HANDLE>|hSCManager||Handle to service control manager as returned by <om win32service.OpenSCManager>
	// @pyparm int|ServiceType|SERVICE_WIN32|Types of services to enumerate (SERVICE_DRIVER and/or SERVICE_WIN32)
	// @pyparm int|ServiceState|SERVICE_STATE_ALL|Limits to services in specified state
	SC_HANDLE hscm;
	PyObject *obhscm;
	DWORD serviceType = SERVICE_WIN32;
	DWORD serviceState = SERVICE_STATE_ALL;
	if (!PyArg_ParseTuple(args, "O|ll:EnumServicesStatus", &obhscm, &serviceType, &serviceState))
	{
		return NULL;
	}
	if (!PyWinObject_AsHANDLE(obhscm, (HANDLE *)&hscm))
		return NULL;
	long tmp;
	LPENUM_SERVICE_STATUS services = (LPENUM_SERVICE_STATUS)&tmp;
	DWORD bytesNeeded, servicesReturned, resumeHandle = 0;
	BOOL result = FALSE;
	char *buffer = NULL;

	Py_BEGIN_ALLOW_THREADS

	EnumServicesStatus(hscm, serviceType, serviceState, services, sizeof(tmp), &bytesNeeded,
		&servicesReturned, &resumeHandle);
	
	if (GetLastError() == ERROR_MORE_DATA)
	{
		buffer = new char[bytesNeeded + 1];
		services = (LPENUM_SERVICE_STATUS)buffer;
		result = EnumServicesStatus(hscm, serviceType, serviceState, services, bytesNeeded + 1,
			&bytesNeeded, &servicesReturned, &resumeHandle);
	}

	Py_END_ALLOW_THREADS

	if (!result)
	{
		delete buffer;
		return PyWin_SetAPIError("EnumServicesStatus");
	}

	PyObject *retval = PyTuple_New(servicesReturned);
	for (DWORD i = 0; i < servicesReturned; i++)
	{
		PyObject *obServiceName = PyWinObject_FromTCHAR(services[i].lpServiceName);
		PyObject *obDisplayName = PyWinObject_FromTCHAR(services[i].lpDisplayName);
		PyTuple_SetItem(retval, i, Py_BuildValue("OO(lllllll)",
			obServiceName,
			obDisplayName,
			services[i].ServiceStatus.dwServiceType,
			services[i].ServiceStatus.dwCurrentState,
			services[i].ServiceStatus.dwControlsAccepted,
			services[i].ServiceStatus.dwWin32ExitCode,
			services[i].ServiceStatus.dwServiceSpecificExitCode,
			services[i].ServiceStatus.dwCheckPoint,
			services[i].ServiceStatus.dwWaitHint));
		Py_XDECREF(obServiceName);
		Py_XDECREF(obDisplayName);
	}

	delete buffer;
	return retval;
}

static PyObject *MyEnumServicesStatusEx(PyObject *self, PyObject *args)
{
	// @pyparm <o PySC_HANDLE>|SCManager||Handle to service control manager as returned by <om win32service.OpenSCManager>
	// @pyparm int|ServiceType|SERVICE_WIN32|Types of services to enumerate (SERVICE_DRIVER and/or SERVICE_WIN32)
	// @pyparm int|ServiceState|SERVICE_STATE_ALL|Limits to services in specified state
	// @pyparm str|GroupName|None|Name of group - use None for all, or '' for services that don't belong to a group
	// @pyparm int|InfoLevel|SC_ENUM_PROCESS_INFO|Currently SC_ENUM_PROCESS_INFO is only level defined
	SC_HANDLE hscm;
	PyObject *obgrp = Py_None, *ret = NULL;
	DWORD service_type = SERVICE_WIN32, service_state = SERVICE_STATE_ALL;
	TmpWCHAR grp;
	DWORD lvl = SC_ENUM_PROCESS_INFO;
	BYTE *buf=NULL;
	DWORD buf_size=0, buf_needed, nbr_returned;
	DWORD resume_handle =0, err=0;
	BOOL bsuccess;
	
	if (fpEnumServicesStatusEx == NULL){
		PyErr_SetString(PyExc_NotImplementedError, "EnumServicesStatusEx does not exist on this platform");
		return NULL;
		}
	if (!PyArg_ParseTuple(args, "O&|kkOk:EnumServicesStatusEx",
		PyWinObject_AsHANDLE, &hscm,
		&service_type, &service_state,
		&obgrp, &lvl))
		return NULL;
	if (lvl != SC_ENUM_PROCESS_INFO){
		PyErr_SetString(PyExc_NotImplementedError, "Unsupported information level");
		return NULL;
		}
	if (!PyWinObject_AsWCHAR(obgrp, &grp, TRUE))
		return NULL;
	ret = PyList_New(0);
	if (ret==NULL)
		return NULL;
	while (true){
		Py_BEGIN_ALLOW_THREADS
		bsuccess = (*fpEnumServicesStatusEx)(hscm, (SC_ENUM_TYPE)lvl, service_type, service_state,
			buf, buf_size, &buf_needed, &nbr_returned, &resume_handle, grp);
		Py_END_ALLOW_THREADS
		if (!bsuccess){
			err=GetLastError();
			if (err != ERROR_MORE_DATA){
				PyWin_SetAPIError("EnumServicesStatusEx", err);
				Py_DECREF(ret);
				ret = NULL;
				break;
				}
			}
		// Function can return false with ERROR_MORE_DATA after retrieving some statuses
		for (DWORD i=0; i<nbr_returned; i++){
			ENUM_SERVICE_STATUS_PROCESS *essp = (ENUM_SERVICE_STATUS_PROCESS *)buf;
			TmpPyObject stat = Py_BuildValue("{s:N, s:N, s:k, s:k, s:k, s:k, s:k, s:k, s:k, s:k, s:k}",
				"ServiceName", PyWinObject_FromTCHAR(essp[i].lpServiceName),
				"DisplayName", PyWinObject_FromTCHAR(essp[i].lpDisplayName),
				"ServiceType", essp[i].ServiceStatusProcess.dwServiceType,
				"CurrentState", essp[i].ServiceStatusProcess.dwCurrentState,
				"ControlsAccepted", essp[i].ServiceStatusProcess.dwControlsAccepted,
				"Win32ExitCode", essp[i].ServiceStatusProcess.dwWin32ExitCode,
				"ServiceSpecificExitCode", essp[i].ServiceStatusProcess.dwServiceSpecificExitCode,
				"CheckPoint", essp[i].ServiceStatusProcess.dwCheckPoint,
				"WaitHint", essp[i].ServiceStatusProcess.dwWaitHint,
				"ProcessId", essp[i].ServiceStatusProcess.dwProcessId,
				"ServiceFlags", essp[i].ServiceStatusProcess.dwServiceFlags);
			if (stat == NULL || PyList_Append(ret, stat) == -1){
				Py_DECREF(ret);
				ret=NULL;
				break;
				}
			}
		if (bsuccess || ret == NULL)
			break;
		if (buf)
			free(buf);
		buf=(BYTE *)malloc(buf_needed);
		if (buf == NULL){
			PyErr_NoMemory();
			Py_DECREF(ret);
			ret = NULL;
			break;
			}
		buf_size = buf_needed;
		}

	if (buf)
		free(buf);
	return ret;
}

static PyObject *MyEnumDependentServices(PyObject *self, PyObject *args)
{
	// @pyparm <o PySC_HANDLE>|hService||Handle to service for which to list dependent services (as returned by <om win32service.OpenService>)
	// @pyparm int|ServiceState|SERVICE_STATE_ALL|Limits to services in specified state - One of SERVICE_STATE_ALL, SERVICE_ACTIVE, SERVICE_INACTIVE
	SC_HANDLE hsc;
	PyObject *obhsc;
	DWORD serviceState = SERVICE_STATE_ALL;
	if (!PyArg_ParseTuple(args, "O|l:EnumDependentServices", &obhsc, &serviceState))
	{
		return NULL;
	}
	if (!PyWinObject_AsHANDLE(obhsc, (HANDLE *)&hsc))
		return NULL;

	long tmp;
	LPENUM_SERVICE_STATUS services = (LPENUM_SERVICE_STATUS)&tmp;
	DWORD bytesNeeded, servicesReturned, resumeHandle = 0;
	BOOL result = FALSE;
	char *buffer = NULL;

	Py_BEGIN_ALLOW_THREADS

	result = EnumDependentServices(hsc, serviceState, services, sizeof(tmp), &bytesNeeded,
		&servicesReturned);
	
	if (!result && GetLastError() == ERROR_MORE_DATA)
	{
		buffer = new char[bytesNeeded + 1];
		services = (LPENUM_SERVICE_STATUS)buffer;
		result = EnumDependentServices(hsc, serviceState, services, bytesNeeded + 1,
			&bytesNeeded, &servicesReturned);
	}

	Py_END_ALLOW_THREADS

	if (!result)
	{
		delete buffer;
		return PyWin_SetAPIError("EnumDependentServices");
	}

	PyObject *retval = PyTuple_New(servicesReturned);
	for (DWORD i = 0; i < servicesReturned; i++)
	{
		PyObject *obServiceName = PyWinObject_FromTCHAR(services[i].lpServiceName);
		PyObject *obDisplayName = PyWinObject_FromTCHAR(services[i].lpDisplayName);
		PyTuple_SetItem(retval, i, Py_BuildValue("OO(lllllll)",
			obServiceName,
			obDisplayName,
			services[i].ServiceStatus.dwServiceType,
			services[i].ServiceStatus.dwCurrentState,
			services[i].ServiceStatus.dwControlsAccepted,
			services[i].ServiceStatus.dwWin32ExitCode,
			services[i].ServiceStatus.dwServiceSpecificExitCode,
			services[i].ServiceStatus.dwCheckPoint,
			services[i].ServiceStatus.dwWaitHint));
		Py_XDECREF(obServiceName);
		Py_XDECREF(obDisplayName);
	}

	delete buffer;
	return retval;
}

static PyObject *MyQueryServiceConfig(PyObject *self, PyObject *args)
{
	// @pyparm <o PySC_HANDLE>|hService||Service handle as returned by <om win32service.OpenService>
	SC_HANDLE hsc;
	PyObject *obhsc;
	if (!PyArg_ParseTuple(args, "O:QueryServiceConfig", &obhsc))
	{
		return NULL;
	}
	if (!PyWinObject_AsHANDLE(obhsc, (HANDLE *)&hsc))
		return NULL;

	long tmp;
	LPQUERY_SERVICE_CONFIG config = (LPQUERY_SERVICE_CONFIG)&tmp;
	DWORD bytesNeeded;
	BOOL result = FALSE;
	char *buffer = NULL;

	Py_BEGIN_ALLOW_THREADS

	result = QueryServiceConfig(hsc, config, sizeof(tmp), &bytesNeeded);
	
	if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
	{
		buffer = new char[bytesNeeded + 1];
		config = (LPQUERY_SERVICE_CONFIG)buffer;
		result = QueryServiceConfig(hsc, config, bytesNeeded, &bytesNeeded);
	}

	Py_END_ALLOW_THREADS

	if (!result)
	{
		delete buffer;
		return PyWin_SetAPIError("QueryServiceConfig");
	}

	// @rdesc Returns a tuple representing a QUERY_SERVICE_CONFIG struct:
	// @tupleitem 0|int|ServiceType|Combination of SERVICE_*_DRIVER or SERVICE_*_PROCESS constants
	// @tupleitem 1|int|StartType|One of SERVICE_*_START constants
	// @tupleitem 2|int|ErrorControl|One of SERVICE_ERROR_* constants
	// @tupleitem 3|<o PyUnicode>|BinaryPathName|Service's binary executable, can also contain command line args
	// @tupleitem 4|<o PyUnicode>|LoadOrderGroup|Loading group that service is a member of
	// @tupleitem 5|int|TagId|Order of service within its load order group
	// @tupleitem 6|[<o PyUnicode>,...]|Dependencies|Sequence of names of services on which this service depends
	// @tupleitem 7|<o PyUnicode>|ServiceStartName|Account name under which service will run
	// @tupleitem 8|<o PyUnicode>|DisplayName|Name of service
	PyObject *retval = Py_BuildValue("lllNNlNNN",
			config->dwServiceType,
			config->dwStartType,
			config->dwErrorControl,
			PyWinObject_FromTCHAR(config->lpBinaryPathName),
			PyWinObject_FromTCHAR(config->lpLoadOrderGroup),
			config->dwTagId,
			PyWinObject_FromMultipleString(config->lpDependencies),
			PyWinObject_FromTCHAR(config->lpServiceStartName),
			PyWinObject_FromTCHAR(config->lpDisplayName));
	delete buffer;
	return retval;
}

// @pyswig |CloseServiceHandle|Closes a service or SCM handle
static PyObject *PyCloseServiceHandle(PyObject *self, PyObject *args)
{
	PyObject *obsch;
	SC_HANDLE sch;
	if (!PyArg_ParseTuple(args, "O:CloseServiceHandle",
		&obsch))	// @pyparm <o PySC_HANDLE>|scHandle||Handle to close
		return NULL;
	if (PyHANDLE_Check(obsch)){
		// Calling Close() in this manner could close any type of PyHANDLE.
		if (strcmp(((PyHANDLE *)obsch)->GetTypeName(),"PySC_HANDLE")!=0){
			PyErr_SetString(PyExc_TypeError,"PyHANDLE passed to CloseServiceHandle must be a PySC_HANDLE");
			return NULL;
			}
		if (!((PySC_HANDLE *)obsch)->Close())
			return NULL;
		Py_INCREF(Py_None);
		return Py_None;
		}
	if (!PyWinObject_AsHANDLE(obsch, (HANDLE *)&sch))
		return NULL;
	if (!CloseServiceHandle(sch))
		return PyWin_SetAPIError("CloseServiceHandle");
	Py_INCREF(Py_None);
	return Py_None;
}

PyObject *MyQueryServiceStatusEx(PyObject *self, PyObject *args)
{
	if (fpQueryServiceStatusEx==NULL){
		PyErr_SetString(PyExc_NotImplementedError,"QueryServiceStatusEx does not exist on this platform");
		return NULL;
		}
	SC_HANDLE hService;
	PyObject *obhService;
	SC_STATUS_TYPE InfoLevel=SC_STATUS_PROCESS_INFO;  // only existing info level
	SERVICE_STATUS_PROCESS info;
	DWORD bufsize=sizeof(SERVICE_STATUS_PROCESS);
	DWORD reqdbufsize;
	// @pyparm <o PySC_HANDLE>|hService||Handle to service to be queried
	if (!PyArg_ParseTuple(args,"O:QueryServiceStatusEx",&obhService))
		return NULL;
	if (!PyWinObject_AsHANDLE(obhService, (HANDLE *)&hService))
		return NULL;

	if (!(*fpQueryServiceStatusEx)(hService,InfoLevel,(BYTE *)&info,bufsize,&reqdbufsize))
		return PyWin_SetAPIError("QueryServiceStatusEx", GetLastError());
	return Py_BuildValue("{s:l,s:l,s:l,s:l,s:l,s:l,s:l,s:l,s:l}",
		"ServiceType", info.dwServiceType,
		"CurrentState", info.dwCurrentState,
		"ControlsAccepted", info.dwControlsAccepted,
		"Win32ExitCode", info.dwWin32ExitCode,
		"ServiceSpecificExitCode",info.dwServiceSpecificExitCode,
		"CheckPoint", info.dwCheckPoint,
		"WaitHint", info.dwWaitHint,
		"ProcessId", info.dwProcessId,
		"ServiceFlags", info.dwServiceFlags);
}

PyObject *MySetServiceObjectSecurity(PyObject *self, PyObject *args)
{
	PyObject *obSD;
	PSECURITY_DESCRIPTOR pSD;
	SECURITY_INFORMATION info;
	SC_HANDLE hsvc;
	PyObject *obhsvc;
	// @pyparm <o PySC_HANDLE>|Handle||Service handle
	// @pyparm int|SecurityInformation||Type of infomation to set, combination of values from SECURITY_INFORMATION enum
	// @pyparm <o PySECURITY_DESCRIPTOR>|SecurityDescriptor||PySECURITY_DESCRIPTOR containing infomation to set
	if (!PyArg_ParseTuple(args,"OlO:SetServiceObjectSecurity",&obhsvc, &info, &obSD))
		return NULL;
	if (!PyWinObject_AsHANDLE(obhsvc, (HANDLE *)&hsvc))
		return NULL;

	if (!PyWinObject_AsSECURITY_DESCRIPTOR(obSD,&pSD,FALSE))
		return NULL;
	if (!SetServiceObjectSecurity(hsvc,info,pSD))
		return PyWin_SetAPIError("SetServiceObjectSecurity",GetLastError());
	Py_INCREF(Py_None);
	return Py_None;
}

PyObject *MyQueryServiceObjectSecurity(PyObject *self, PyObject *args)
{
	PyObject *ret=NULL;
	PSECURITY_DESCRIPTOR pSD=NULL;
	SECURITY_INFORMATION info;
	DWORD err, origbufsize=SECURITY_DESCRIPTOR_MIN_LENGTH, reqdbufsize=0;
	SC_HANDLE hsvc;
	PyObject *obhsvc;
	// @pyparm <o PySC_HANDLE>|Handle||Service handle
	// @pyparm int|SecurityInformation||Type of infomation to retrieve, combination of values from SECURITY_INFORMATION enum
	if (!PyArg_ParseTuple(args,"Ol:QueryServiceObjectSecurity",&obhsvc, &info))
		return NULL;
	if (!PyWinObject_AsHANDLE(obhsvc, (HANDLE *)&hsvc))
		return NULL;

	pSD=(PSECURITY_DESCRIPTOR)malloc(origbufsize);
	if (pSD==NULL){
		PyErr_Format(PyExc_MemoryError, "QueryServiceObjectSecurity: unable to allocate %d bytes", origbufsize);
		return NULL;
		}
	if (!QueryServiceObjectSecurity(hsvc,info,pSD,origbufsize,&reqdbufsize)){
		err=GetLastError();
		if (err==ERROR_INSUFFICIENT_BUFFER){
			free(pSD);
			pSD=(PSECURITY_DESCRIPTOR)malloc(reqdbufsize);
			if (pSD==NULL)
				PyErr_Format(PyExc_MemoryError,"QueryServiceObjectSecurity: unable to reallocatate %d bytes",reqdbufsize);
			else
				if (!QueryServiceObjectSecurity(hsvc,info,pSD,reqdbufsize,&reqdbufsize))
					PyWin_SetAPIError("QueryServiceObjectSecurity",GetLastError());
				else
					ret=PyWinObject_FromSECURITY_DESCRIPTOR(pSD);
			}
		else
			PyWin_SetAPIError("QueryServiceObjectSecurity",err);
		}
	else
		ret=PyWinObject_FromSECURITY_DESCRIPTOR(pSD);
	if (pSD!=NULL)
		free(pSD);
	return ret;
}

PyObject *MyGetServiceKeyName(PyObject *self, PyObject *args)
{
	// @pyparm <o PySC_HANDLE>|hSCManager||Handle to service control manager as returned by <om win32service.OpenSCManager>
	// @pyparm <o PyUNICODE>|DisplayName||Display name of a service
	SC_HANDLE h;
	PyObject *obh;
	WCHAR *displayname;
	WCHAR keyname[MAX_SERVICE_NAME_LEN];
	DWORD bufsize=MAX_SERVICE_NAME_LEN;
	PyObject *obdisplayname, *ret=NULL;
	if (!PyArg_ParseTuple(args,"OO:GetServiceKeyName", &obh, &obdisplayname))
		return NULL;
	if (!PyWinObject_AsHANDLE(obh, (HANDLE *)&h))
		return NULL;
	if (!PyWinObject_AsWCHAR(obdisplayname, &displayname, FALSE))
		return NULL;
	if (!GetServiceKeyNameW(h, displayname, keyname, &bufsize))
		PyWin_SetAPIError("GetServiceKeyName");
	else
		ret=PyWinObject_FromWCHAR(keyname, bufsize);
	PyWinObject_FreeWCHAR(displayname);
	return ret;
}

PyObject *MyGetServiceDisplayName(PyObject *self, PyObject *args)
{
	// @pyparm <o PySC_HANDLE>|hSCManager||Handle to service control manager as returned by <om win32service.OpenSCManager>
	// @pyparm <o PyUNICODE>|ServiceName||Name of service
	SC_HANDLE h;
	PyObject *obh;
	WCHAR *keyname;
	WCHAR displayname[MAX_SERVICE_NAME_LEN];
	DWORD bufsize=MAX_SERVICE_NAME_LEN;
	PyObject *obkeyname, *ret=NULL;
	if (!PyArg_ParseTuple(args,"OO:GetServiceDisplayName", &obh, &obkeyname))
		return NULL;
	if (!PyWinObject_AsHANDLE(obh, (HANDLE *)&h))
		return NULL;
	if (!PyWinObject_AsWCHAR(obkeyname, &keyname, FALSE))
		return NULL;
	if (!GetServiceDisplayNameW(h, keyname, displayname, &bufsize))
		PyWin_SetAPIError("GetServiceDisplayName");
	else
		ret=PyWinObject_FromWCHAR(displayname);
	PyWinObject_FreeWCHAR(keyname);
	return ret;
}

// @pyswig (int, <o PyUnicode>, int)|QueryServiceLockStatus|Retrieves the lock status of the specified service control manager database. 
static PyObject *PyQueryServiceLockStatus(PyObject *self, PyObject *args)
{
	SC_HANDLE handle;
	PyObject *obhandle;
	// @pyparm <o PySC_HANDLE>|hSCManager||Handle to the SCM.
	if (!PyArg_ParseTuple(args, "O:QueryServiceLockStatus", &obhandle))
		return NULL;
	if (!PyWinObject_AsHANDLE(obhandle, (HANDLE *)&handle))
		return NULL;
	DWORD bufSize;
	QueryServiceLockStatus(handle, NULL, 0, &bufSize);
	if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
		return PyWin_SetAPIError("QueryServiceLockStatus");
	QUERY_SERVICE_LOCK_STATUS *buf;
	buf = (QUERY_SERVICE_LOCK_STATUS *)malloc(bufSize);
	if (buf==NULL) {
		PyErr_SetString(PyExc_MemoryError, "No memory for status buffer");
		return NULL;
	}
	BOOL ok = QueryServiceLockStatus((SC_HANDLE)handle, buf, bufSize, &bufSize);
	PyObject *ret;
	if (ok) {
		// @rdesc The result is a tuple of (bIsLocked, userName, lockDuration)
		PyObject *str = PyWinObject_FromTCHAR(buf->lpLockOwner);
		ret = Py_BuildValue("lOl", buf->fIsLocked, str, buf->dwLockDuration);
		Py_XDECREF(str);
	} else
		ret = PyWin_SetAPIError("QueryServiceLockStatus");
	free(buf);
	return ret;
}

BOOL PyWinObject_AsSC_ACTION(PyObject *obAction, SC_ACTION *Action)
{
	static char* err="SC_ACTION must be a tuple of 2 ints (Type, Delay)";
	if (!PyTuple_Check(obAction)){
		PyErr_SetString(PyExc_TypeError,err);
		return FALSE;
		}
	if (!PyArg_ParseTuple(obAction,"ll", &Action->Type, &Action->Delay)){
		PyErr_Clear();
		PyErr_SetString(PyExc_TypeError,err);
		return FALSE;
		}
	return TRUE;
}

BOOL PyWinObject_AsSC_ACTIONS(PyObject *obActions, SC_ACTION **ppActions, LPDWORD cActions)
{
	static char* err="SC_ACTIONS must be a sequence of 2-tuples ((int, int),...)";
	DWORD action_ind;
	BOOL ret=TRUE;
	SC_ACTION *pAction;
	if (obActions==Py_None){
		*cActions=0;
		*ppActions=NULL;
		return TRUE;
		}
	PyObject *actions_tuple=PyWinSequence_Tuple(obActions, cActions);
	if (actions_tuple==NULL)
		return FALSE;

	*ppActions=(SC_ACTION *)malloc(*cActions*sizeof(SC_ACTION));
	if (*ppActions==NULL){
		Py_DECREF(actions_tuple);
		PyErr_Format(PyExc_MemoryError,"Unable to allocate %d SC_ACTION structures", *cActions);
		return FALSE;
		}
	pAction=*ppActions;
	for (action_ind=0;action_ind<*cActions;action_ind++){
		ret=PyWinObject_AsSC_ACTION(PyTuple_GET_ITEM(actions_tuple, action_ind), pAction);
		if (!ret){
			free(*ppActions);
			*ppActions=NULL;
			*cActions=0;
			break;
			}
		pAction++;
		}
	Py_DECREF(actions_tuple);
	return ret;
}

void PyWinObject_FreeSERVICE_FAILURE_ACTIONS(LPSERVICE_FAILURE_ACTIONSW psfa)
{
	if (psfa->lpRebootMsg!=NULL)
		PyWinObject_FreeWCHAR(psfa->lpRebootMsg);
	if (psfa->lpCommand!=NULL)
		PyWinObject_FreeWCHAR(psfa->lpCommand);
	if (psfa->lpsaActions!=NULL)
		free(psfa->lpsaActions);
}

BOOL PyWinObject_AsSERVICE_FAILURE_ACTIONS(PyObject *obinfo, LPSERVICE_FAILURE_ACTIONSW psfa)
{
	static char *sfa_keys[]={"ResetPeriod","RebootMsg","Command","Actions",0};
	static char *err="SERVICE_FAILURE_ACTIONS must be a dictionary containing {'ResetPeriod':int,'RebootMsg':unicode,'Command':unicode,'Actions':sequence of 2 tuples(int,int)";
	PyObject *dummy_tuple, *obActions, *obRebootMsg, *obCommand;
	BOOL ret;
	ZeroMemory(psfa, sizeof(SERVICE_FAILURE_ACTIONSW));
	if (!PyDict_Check(obinfo)){
		PyErr_SetString(PyExc_TypeError,err);
		return FALSE;
		}
	dummy_tuple=PyTuple_New(0);
	if (dummy_tuple==NULL)
		return FALSE;
	ret=PyArg_ParseTupleAndKeywords(dummy_tuple, obinfo, "lOOO:SERVICE_FAILURE_ACTIONS", sfa_keys,
		&psfa->dwResetPeriod, &obRebootMsg, &obCommand, &obActions);
	Py_DECREF(dummy_tuple);
	if (!ret){
		PyErr_Clear();
		PyErr_SetString(PyExc_TypeError,err);
		return FALSE;
		}
	if (PyWinObject_AsWCHAR(obRebootMsg, &psfa->lpRebootMsg, TRUE)
		&&PyWinObject_AsWCHAR(obCommand,   &psfa->lpCommand,   TRUE)
		&&PyWinObject_AsSC_ACTIONS(obActions,&psfa->lpsaActions, &psfa->cActions))
		return TRUE;
	PyWinObject_FreeSERVICE_FAILURE_ACTIONS(psfa);
	return FALSE;
}

PyObject *PyWinObject_FromSERVICE_FAILURE_ACTIONS(LPSERVICE_FAILURE_ACTIONSW psfa)
{
	PyObject *obActions, *obAction;
	SC_ACTION *pAction;
	DWORD action_ind;
	obActions=PyTuple_New(psfa->cActions);
	if (obActions==NULL)
		return NULL;
	pAction=psfa->lpsaActions;
	for (action_ind=0;action_ind<psfa->cActions;action_ind++){
		obAction=Py_BuildValue("ll",pAction->Type,pAction->Delay);
		if (obAction==NULL){
			Py_DECREF(obActions);
			return NULL;
			}
		PyTuple_SET_ITEM(obActions, action_ind, obAction);
		pAction++;
		}
	return Py_BuildValue("{s:l,s:u,s:u,s:N}",
		"ResetPeriod", psfa->dwResetPeriod,
		"RebootMsg", psfa->lpRebootMsg,
		"Command", psfa->lpCommand,
		"Actions", obActions);
}


PyObject *PyChangeServiceConfig2(PyObject *self, PyObject *args)
{
	if (fpChangeServiceConfig2==NULL){
		PyErr_SetString(PyExc_NotImplementedError,"ChangeServiceConfig2 is not available on this operating system");
		return NULL;
		}
	SC_HANDLE hService;
	PyObject *obhService;
	DWORD level;
	BOOL bsuccess;

	PyObject *obinfo;
	// @pyparm <o PySC_HANDLE>|hService||Service handle as returned by <om win32service.OpenService>
	// @pyparm int|InfoLevel||One of win32service.SERVICE_CONFIG_* values
	// @pyparm object|info||Type depends on InfoLevel
	if (!PyArg_ParseTuple(args,"OlO:ChangeServiceConfig2", &obhService, &level, &obinfo))
		return NULL;
	if (!PyWinObject_AsHANDLE(obhService, (HANDLE *)&hService))
		return NULL;

	switch (level){
		// @flagh InfoLevel|Input value
		// @flag SERVICE_CONFIG_DESCRIPTION|Unicode string
		case SERVICE_CONFIG_DESCRIPTION:{
			SERVICE_DESCRIPTIONW buf;
			if (!PyWinObject_AsWCHAR(obinfo, &buf.lpDescription, TRUE))
				return NULL;
			bsuccess=(*fpChangeServiceConfig2)(hService, level, (LPVOID)&buf);
			PyWinObject_FreeWCHAR(buf.lpDescription);
			break;
			}
		// @flag SERVICE_CONFIG_FAILURE_ACTIONS|Dict representing a SERVICE_FAILURE_ACTIONS struct
		case SERVICE_CONFIG_FAILURE_ACTIONS:{
			SERVICE_FAILURE_ACTIONSW buf;
			if (!PyWinObject_AsSERVICE_FAILURE_ACTIONS(obinfo, &buf))
				return NULL;
			bsuccess=(*fpChangeServiceConfig2)(hService, level, (LPVOID)&buf);
			PyWinObject_FreeSERVICE_FAILURE_ACTIONS(&buf);
			break;
			}
		// @flag SERVICE_CONFIG_DELAYED_AUTO_START_INFO|Boolean
		case SERVICE_CONFIG_DELAYED_AUTO_START_INFO:{
			SERVICE_DELAYED_AUTO_START_INFO buf;
			buf.fDelayedAutostart=PyObject_IsTrue(obinfo);
			bsuccess=(*fpChangeServiceConfig2)(hService,level, (LPVOID)&buf);
			break;
			}
		// @flag SERVICE_CONFIG_FAILURE_ACTIONS_FLAG|Boolean
		case SERVICE_CONFIG_FAILURE_ACTIONS_FLAG:{
			SERVICE_FAILURE_ACTIONS_FLAG buf;
			buf.fFailureActionsOnNonCrashFailures=PyObject_IsTrue(obinfo);
			bsuccess=(*fpChangeServiceConfig2)(hService,level, (LPVOID)&buf);
			break;
			}
		// @flag SERVICE_CONFIG_PRESHUTDOWN_INFO|int (shutdown timeout in milliseconds)
		case SERVICE_CONFIG_PRESHUTDOWN_INFO:{
			SERVICE_PRESHUTDOWN_INFO buf;
			buf.dwPreshutdownTimeout = PyLong_AsUnsignedLong(obinfo);
			if (buf.dwPreshutdownTimeout==(DWORD)-1 && PyErr_Occurred())
				return NULL;
			bsuccess=(*fpChangeServiceConfig2)(hService, level, (LPVOID)&buf);
			break;
			}
		// @flag SERVICE_CONFIG_SERVICE_SID_INFO|int (SERVICE_SID_TYPE_*)
		case SERVICE_CONFIG_SERVICE_SID_INFO:{
			SERVICE_SID_INFO buf;
			buf.dwServiceSidType=PyLong_AsUnsignedLong(obinfo);
			if (buf.dwServiceSidType==(DWORD)-1 && PyErr_Occurred())
				return NULL;
			bsuccess=(*fpChangeServiceConfig2)(hService, level, (LPVOID)&buf);
			break;
			}
		// @flag SERVICE_CONFIG_REQUIRED_PRIVILEGES_INFO|Sequence of unicode strings
		case SERVICE_CONFIG_REQUIRED_PRIVILEGES_INFO:{
			SERVICE_REQUIRED_PRIVILEGES_INFO buf;
			if (!PyWinObject_AsMultipleString(obinfo, &buf.pmszRequiredPrivileges))
				return NULL;
			bsuccess=(*fpChangeServiceConfig2)(hService, level, (LPVOID)&buf);
			PyWinObject_FreeMultipleString(buf.pmszRequiredPrivileges);
			break;
			}
		default:
			return PyErr_Format(PyExc_ValueError,"Info type %d is not supported",level);
		}

	if (!bsuccess)
		return PyWin_SetAPIError("ChangeServiceConfig2");
	Py_INCREF(Py_None);
	return Py_None;
}

PyObject *PyQueryServiceConfig2(PyObject *self, PyObject *args)
{
	if (fpQueryServiceConfig2==NULL){
		PyErr_SetString(PyExc_NotImplementedError,"QueryServiceConfig2 is not available on this operating system");
		return NULL;
		}
	SC_HANDLE hService;
	PyObject *obhService;
	DWORD level, bytes_needed=0, bufsize=0;
	LPBYTE buf=NULL;
	PyObject *ret=NULL;
	// @pyparm <o PySC_HANDLE>|hService||Service handle as returned by <om win32service.OpenService>
	// @pyparm int|InfoLevel||One of win32service.SERVICE_CONFIG_* values
	if (!PyArg_ParseTuple(args,"Ol:QueryServiceConfig2", &obhService, &level))
		return NULL;
	if (!PyWinObject_AsHANDLE(obhService, (HANDLE *)&hService))
		return NULL;
	(*fpQueryServiceConfig2)(hService, level, buf, bufsize, &bytes_needed);
	if (bytes_needed==0){
		PyWin_SetAPIError("QueryServiceConfig2");
		return NULL;
		}
	buf=(LPBYTE)malloc(bytes_needed);
	if (buf==NULL)
		return PyErr_Format(PyExc_MemoryError,"QueryServiceConfig2: Unable to allocate buffer of %d bytes",bytes_needed);
	bufsize=bytes_needed;

	if ((*fpQueryServiceConfig2)(hService, level, buf, bufsize, &bytes_needed))
		switch(level){
			// @flagh InfoLevel|Type of value returned
			// @flag SERVICE_CONFIG_DESCRIPTION|Unicode string
			case SERVICE_CONFIG_DESCRIPTION:
				ret=PyWinObject_FromWCHAR(((SERVICE_DESCRIPTIONW *)buf)->lpDescription);
				break;
			// @flag SERVICE_CONFIG_FAILURE_ACTIONS|Dict representing a SERVICE_FAILURE_ACTIONS struct
			case SERVICE_CONFIG_FAILURE_ACTIONS:
				ret=PyWinObject_FromSERVICE_FAILURE_ACTIONS((LPSERVICE_FAILURE_ACTIONSW)buf);
				break;
			// @flag SERVICE_CONFIG_DELAYED_AUTO_START_INFO|Boolean
			case SERVICE_CONFIG_DELAYED_AUTO_START_INFO:
				ret=PyBool_FromLong(((SERVICE_DELAYED_AUTO_START_INFO *)buf)->fDelayedAutostart);
				break;
			// @flag SERVICE_CONFIG_FAILURE_ACTIONS_FLAG|Boolean
			case SERVICE_CONFIG_FAILURE_ACTIONS_FLAG:
				ret=PyBool_FromLong(((SERVICE_FAILURE_ACTIONS_FLAG *)buf)->fFailureActionsOnNonCrashFailures);
				break;
			// @flag SERVICE_CONFIG_PRESHUTDOWN_INFO|int (shutdown timeout in milliseconds)
			case SERVICE_CONFIG_PRESHUTDOWN_INFO:
				ret=PyLong_FromUnsignedLong(((SERVICE_PRESHUTDOWN_INFO *)buf)->dwPreshutdownTimeout);
				break;
			// @flag SERVICE_CONFIG_SERVICE_SID_INFO|int (SERVICE_SID_TYPE_*)
			case SERVICE_CONFIG_SERVICE_SID_INFO:
				ret=PyLong_FromUnsignedLong(((SERVICE_SID_INFO *)buf)->dwServiceSidType);
				break;
			// @flag SERVICE_CONFIG_REQUIRED_PRIVILEGES_INFO|List of unicode strings
			case SERVICE_CONFIG_REQUIRED_PRIVILEGES_INFO:
				ret=PyWinObject_FromMultipleString(((SERVICE_REQUIRED_PRIVILEGES_INFO *)buf)->pmszRequiredPrivileges);
				break;
			default:
				PyErr_Format(PyExc_NotImplementedError,"QueryServiceConfig2: Level %d is not supported", level);
			}
	else
		PyWin_SetAPIError("QueryServiceConfig2");
	free(buf);
	return ret;
}
static PyObject *_wrap_StartService(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    PyObject * _result;
    SC_HANDLE  _arg0;
    PyObject * _arg1;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OO:StartService",&_obj0,&_obj1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
  _arg1 = _obj1;
}
    _result = (PyObject *)MyStartService(_arg0,_arg1);
{
	if (_result==NULL) return NULL; // get out now!
	_resultobj = _result;
}
    return _resultobj;
}

static PyObject *_wrap_OpenService(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    SC_HANDLE  _result;
    SC_HANDLE  _arg0;
    TCHAR * _arg1;
    unsigned long  _arg2;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
{
	_arg1 = NULL;
}
    if(!PyArg_ParseTuple(args,"OOl:OpenService",&_obj0,&_obj1,&_arg2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsTCHAR(_obj1, &_arg1, FALSE))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (SC_HANDLE )OpenService(_arg0,_arg1,_arg2);

      Py_END_ALLOW_THREADS
      if (_result==0)  {
           {
	PyWinObject_FreeTCHAR(_arg1);
}
;
           return PyWin_SetAPIError("OpenService");
      }
}{
	_resultobj = PyWinObject_FromSC_HANDLE(_result);
}
{
	PyWinObject_FreeTCHAR(_arg1);
}
    return _resultobj;
}

static PyObject *_wrap_OpenSCManager(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    SC_HANDLE  _result;
    TCHAR * _arg0;
    TCHAR * _arg1;
    unsigned long  _arg2;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
{
	_arg0 = NULL;
}
{
	_arg1 = NULL;
}
    if(!PyArg_ParseTuple(args,"OOl:OpenSCManager",&_obj0,&_obj1,&_arg2)) 
        return NULL;
{
	if (!PyWinObject_AsTCHAR(_obj0, &_arg0, TRUE))
		return NULL;
}
{
	if (!PyWinObject_AsTCHAR(_obj1, &_arg1, TRUE))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (SC_HANDLE )OpenSCManager(_arg0,_arg1,_arg2);

      Py_END_ALLOW_THREADS
      if (_result==0)  {
           {
	PyWinObject_FreeTCHAR(_arg0);
}
{
	PyWinObject_FreeTCHAR(_arg1);
}
;
           return PyWin_SetAPIError("OpenSCManager");
      }
}{
	_resultobj = PyWinObject_FromSC_HANDLE(_result);
}
{
	PyWinObject_FreeTCHAR(_arg0);
}
{
	PyWinObject_FreeTCHAR(_arg1);
}
    return _resultobj;
}

static PyObject *_wrap_QueryServiceStatus(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    SC_HANDLE  _arg0;
    SERVICE_STATUS * _arg1;
    SERVICE_STATUS  temp;
    PyObject * _obj0 = 0;

    self = self;
{
	_arg1 = &temp;
}
    if(!PyArg_ParseTuple(args,"O:QueryServiceStatus",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )QueryServiceStatus(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("QueryServiceStatus");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
{
	Py_DECREF(_resultobj);
	_resultobj = Py_BuildValue("lllllll", 
		_arg1->dwServiceType, // @tupleitem 0|int|serviceType|The type of service.
		_arg1->dwCurrentState, // @tupleitem 1|int|serviceState|The current state of the service.
		_arg1->dwControlsAccepted, // @tupleitem 2|int|controlsAccepted|The controls the service accepts.
		_arg1->dwWin32ExitCode, // @tupleitem 3|int|win32ExitCode|The win32 error code for the service.
		_arg1->dwServiceSpecificExitCode, // @tupleitem 4|int|serviceSpecificErrorCode|The service specific error code.
		_arg1->dwCheckPoint, // @tupleitem 5|int|checkPoint|The checkpoint reported by the service.
		_arg1->dwWaitHint); // @tupleitem 6|int|waitHint|The wait hint reported by the service.
}
    return _resultobj;
}

static PyObject *_wrap_SetServiceStatus(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    SERVICE_STATUS_HANDLE  _arg0;
    SERVICE_STATUS * _arg1;
    PyObject * _obj0 = 0;
    SERVICE_STATUS  junk;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OO:SetServiceStatus",&_obj0,&_obj1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	_arg1 = &junk;
	if (!PyArg_ParseTuple(_obj1, "lllllll", 
		&_arg1->dwServiceType,
		&_arg1->dwCurrentState,
		&_arg1->dwControlsAccepted,
		&_arg1->dwWin32ExitCode,
		&_arg1->dwServiceSpecificExitCode,
		&_arg1->dwCheckPoint,
		&_arg1->dwWaitHint))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )SetServiceStatus(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("SetServiceStatus");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_ControlService(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    SC_HANDLE  _arg0;
    DWORD  _arg1;
    SERVICE_STATUS * _arg2;
    SERVICE_STATUS  temp;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
{
	_arg2 = &temp;
}
    if(!PyArg_ParseTuple(args,"OO:ControlService",&_obj0,&_obj1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	// PyLong_AsUnsignedLongMask isn't ideal - no overflow checking - but
	// this is what the 'k' format specifier in PyArg_ParseTuple uses, and
	// that is what much of pywin32 uses for DWORDS, so we use it here too
	_arg1 = PyLong_AsUnsignedLongMask(_obj1);
	if (_arg1==(DWORD)-1 && PyErr_Occurred())
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )ControlService(_arg0,_arg1,_arg2);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("ControlService");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
{
	Py_DECREF(_resultobj);
	_resultobj = Py_BuildValue("lllllll", 
		_arg2->dwServiceType, // @tupleitem 0|int|serviceType|The type of service.
		_arg2->dwCurrentState, // @tupleitem 1|int|serviceState|The current state of the service.
		_arg2->dwControlsAccepted, // @tupleitem 2|int|controlsAccepted|The controls the service accepts.
		_arg2->dwWin32ExitCode, // @tupleitem 3|int|win32ExitCode|The win32 error code for the service.
		_arg2->dwServiceSpecificExitCode, // @tupleitem 4|int|serviceSpecificErrorCode|The service specific error code.
		_arg2->dwCheckPoint, // @tupleitem 5|int|checkPoint|The checkpoint reported by the service.
		_arg2->dwWaitHint); // @tupleitem 6|int|waitHint|The wait hint reported by the service.
}
    return _resultobj;
}

static PyObject *_wrap_DeleteService(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    SC_HANDLE  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:DeleteService",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )DeleteService(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("DeleteService");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_CreateService(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    PyObject * _result;
    SC_HANDLE  _arg0;
    TCHAR * _arg1;
    TCHAR * _arg2;
    DWORD  _arg3;
    DWORD  _arg4;
    DWORD  _arg5;
    DWORD  _arg6;
    TCHAR * _arg7;
    TCHAR * _arg8;
    BOOL  _arg9;
    PyObject * _arg10;
    TCHAR * _arg11;
    TCHAR * _arg12;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;
    PyObject * _obj2 = 0;
    PyObject * _obj3 = 0;
    PyObject * _obj4 = 0;
    PyObject * _obj5 = 0;
    PyObject * _obj6 = 0;
    PyObject * _obj7 = 0;
    PyObject * _obj8 = 0;
    PyObject * _obj10 = 0;
    PyObject * _obj11 = 0;
    PyObject * _obj12 = 0;

    self = self;
{
	_arg1 = NULL;
}
{
	_arg2 = NULL;
}
{
	_arg7 = NULL;
}
{
	_arg8 = NULL;
}
{
	_arg11 = NULL;
}
{
	_arg12 = NULL;
}
    if(!PyArg_ParseTuple(args,"OOOOOOOOOiOOO:CreateService",&_obj0,&_obj1,&_obj2,&_obj3,&_obj4,&_obj5,&_obj6,&_obj7,&_obj8,&_arg9,&_obj10,&_obj11,&_obj12)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsTCHAR(_obj1, &_arg1, FALSE))
		return NULL;
}
{
	if (!PyWinObject_AsTCHAR(_obj2, &_arg2, FALSE))
		return NULL;
}
{
	// PyLong_AsUnsignedLongMask isn't ideal - no overflow checking - but
	// this is what the 'k' format specifier in PyArg_ParseTuple uses, and
	// that is what much of pywin32 uses for DWORDS, so we use it here too
	_arg3 = PyLong_AsUnsignedLongMask(_obj3);
	if (_arg3==(DWORD)-1 && PyErr_Occurred())
		return NULL;
}
{
	// PyLong_AsUnsignedLongMask isn't ideal - no overflow checking - but
	// this is what the 'k' format specifier in PyArg_ParseTuple uses, and
	// that is what much of pywin32 uses for DWORDS, so we use it here too
	_arg4 = PyLong_AsUnsignedLongMask(_obj4);
	if (_arg4==(DWORD)-1 && PyErr_Occurred())
		return NULL;
}
{
	// PyLong_AsUnsignedLongMask isn't ideal - no overflow checking - but
	// this is what the 'k' format specifier in PyArg_ParseTuple uses, and
	// that is what much of pywin32 uses for DWORDS, so we use it here too
	_arg5 = PyLong_AsUnsignedLongMask(_obj5);
	if (_arg5==(DWORD)-1 && PyErr_Occurred())
		return NULL;
}
{
	// PyLong_AsUnsignedLongMask isn't ideal - no overflow checking - but
	// this is what the 'k' format specifier in PyArg_ParseTuple uses, and
	// that is what much of pywin32 uses for DWORDS, so we use it here too
	_arg6 = PyLong_AsUnsignedLongMask(_obj6);
	if (_arg6==(DWORD)-1 && PyErr_Occurred())
		return NULL;
}
{
	if (!PyWinObject_AsTCHAR(_obj7, &_arg7, FALSE))
		return NULL;
}
{
	if (!PyWinObject_AsTCHAR(_obj8, &_arg8, TRUE))
		return NULL;
}
{
  _arg10 = _obj10;
}
{
	if (!PyWinObject_AsTCHAR(_obj11, &_arg11, TRUE))
		return NULL;
}
{
	if (!PyWinObject_AsTCHAR(_obj12, &_arg12, TRUE))
		return NULL;
}
    _result = (PyObject *)MyCreateService(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8,_arg9,_arg10,_arg11,_arg12);
{
	if (_result==NULL) return NULL; // get out now!
	_resultobj = _result;
}
{
	PyWinObject_FreeTCHAR(_arg1);
}
{
	PyWinObject_FreeTCHAR(_arg2);
}
{
	PyWinObject_FreeTCHAR(_arg7);
}
{
	PyWinObject_FreeTCHAR(_arg8);
}
{
	PyWinObject_FreeTCHAR(_arg11);
}
{
	PyWinObject_FreeTCHAR(_arg12);
}
    return _resultobj;
}

static PyObject *_wrap_ChangeServiceConfig(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    PyObject * _result;
    SC_HANDLE  _arg0;
    DWORD  _arg1;
    DWORD  _arg2;
    DWORD  _arg3;
    TCHAR * _arg4;
    TCHAR * _arg5;
    BOOL  _arg6;
    PyObject * _arg7;
    TCHAR * _arg8;
    TCHAR * _arg9;
    TCHAR * _arg10;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;
    PyObject * _obj2 = 0;
    PyObject * _obj3 = 0;
    PyObject * _obj4 = 0;
    PyObject * _obj5 = 0;
    PyObject * _obj7 = 0;
    PyObject * _obj8 = 0;
    PyObject * _obj9 = 0;
    PyObject * _obj10 = 0;

    self = self;
{
	_arg4 = NULL;
}
{
	_arg5 = NULL;
}
{
	_arg8 = NULL;
}
{
	_arg9 = NULL;
}
{
	_arg10 = NULL;
}
    if(!PyArg_ParseTuple(args,"OOOOOOiOOOO:ChangeServiceConfig",&_obj0,&_obj1,&_obj2,&_obj3,&_obj4,&_obj5,&_arg6,&_obj7,&_obj8,&_obj9,&_obj10)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	// PyLong_AsUnsignedLongMask isn't ideal - no overflow checking - but
	// this is what the 'k' format specifier in PyArg_ParseTuple uses, and
	// that is what much of pywin32 uses for DWORDS, so we use it here too
	_arg1 = PyLong_AsUnsignedLongMask(_obj1);
	if (_arg1==(DWORD)-1 && PyErr_Occurred())
		return NULL;
}
{
	// PyLong_AsUnsignedLongMask isn't ideal - no overflow checking - but
	// this is what the 'k' format specifier in PyArg_ParseTuple uses, and
	// that is what much of pywin32 uses for DWORDS, so we use it here too
	_arg2 = PyLong_AsUnsignedLongMask(_obj2);
	if (_arg2==(DWORD)-1 && PyErr_Occurred())
		return NULL;
}
{
	// PyLong_AsUnsignedLongMask isn't ideal - no overflow checking - but
	// this is what the 'k' format specifier in PyArg_ParseTuple uses, and
	// that is what much of pywin32 uses for DWORDS, so we use it here too
	_arg3 = PyLong_AsUnsignedLongMask(_obj3);
	if (_arg3==(DWORD)-1 && PyErr_Occurred())
		return NULL;
}
{
	if (!PyWinObject_AsTCHAR(_obj4, &_arg4, TRUE))
		return NULL;
}
{
	if (!PyWinObject_AsTCHAR(_obj5, &_arg5, TRUE))
		return NULL;
}
{
  _arg7 = _obj7;
}
{
	if (!PyWinObject_AsTCHAR(_obj8, &_arg8, TRUE))
		return NULL;
}
{
	if (!PyWinObject_AsTCHAR(_obj9, &_arg9, TRUE))
		return NULL;
}
{
	if (!PyWinObject_AsTCHAR(_obj10, &_arg10, TRUE))
		return NULL;
}
    _result = (PyObject *)MyChangeServiceConfig(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8,_arg9,_arg10);
{
	if (_result==NULL) return NULL; // get out now!
	_resultobj = _result;
}
{
	PyWinObject_FreeTCHAR(_arg4);
}
{
	PyWinObject_FreeTCHAR(_arg5);
}
{
	PyWinObject_FreeTCHAR(_arg8);
}
{
	PyWinObject_FreeTCHAR(_arg9);
}
{
	PyWinObject_FreeTCHAR(_arg10);
}
    return _resultobj;
}

static PyObject *_wrap_LockServiceDatabase(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    SC_LOCK  _result;
    SC_HANDLE  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:LockServiceDatabase",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
    _result = (SC_LOCK )LockServiceDatabase(_arg0);
{
	_resultobj = PyWinLong_FromVoidPtr(_result);
}
    return _resultobj;
}

static PyObject *_wrap_UnlockServiceDatabase(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    SC_LOCK  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:UnlockServiceDatabase",&_obj0)) 
        return NULL;
{
	if (!PyWinLong_AsVoidPtr(_obj0, &_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )UnlockServiceDatabase(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("UnlockServiceDatabase");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyMethodDef win32serviceMethods[] = {
	 { "QueryServiceConfig2", PyQueryServiceConfig2, 1 },
	 { "ChangeServiceConfig2", PyChangeServiceConfig2, 1 },
	 { "QueryServiceLockStatus", PyQueryServiceLockStatus, 1 },
	 { "UnlockServiceDatabase", _wrap_UnlockServiceDatabase, 1 },
	 { "LockServiceDatabase", _wrap_LockServiceDatabase, 1 },
	 { "ChangeServiceConfig", _wrap_ChangeServiceConfig, 1 },
	 { "CreateService", _wrap_CreateService, 1 },
	 { "DeleteService", _wrap_DeleteService, 1 },
	 { "ControlService", _wrap_ControlService, 1 },
	 { "SetServiceStatus", _wrap_SetServiceStatus, 1 },
	 { "GetServiceDisplayName", MyGetServiceDisplayName, 1 },
	 { "GetServiceKeyName", MyGetServiceKeyName, 1 },
	 { "QueryServiceObjectSecurity", MyQueryServiceObjectSecurity, 1 },
	 { "SetServiceObjectSecurity", MySetServiceObjectSecurity, 1 },
	 { "QueryServiceStatusEx", MyQueryServiceStatusEx, 1 },
	 { "QueryServiceStatus", _wrap_QueryServiceStatus, 1 },
	 { "CloseServiceHandle", PyCloseServiceHandle, 1 },
	 { "OpenSCManager", _wrap_OpenSCManager, 1 },
	 { "OpenService", _wrap_OpenService, 1 },
	 { "StartService", _wrap_StartService, 1 },
	 { "QueryServiceConfig", MyQueryServiceConfig, 1 },
	 { "EnumDependentServices", MyEnumDependentServices, 1 },
	 { "EnumServicesStatusEx", MyEnumServicesStatusEx, 1 },
	 { "EnumServicesStatus", MyEnumServicesStatus, 1 },
	 { "CreateWindowStation", PyCreateWindowStation, 1 },
	 { "GetProcessWindowStation", PyGetProcessWindowStation, 1 },
	 { "OpenInputDesktop", PyOpenInputDesktop, 1 },
	 { "CreateDesktop", PyCreateDesktop, 1 },
	 { "OpenDesktop", PyOpenDesktop, 1 },
	 { "OpenWindowStation", PyOpenWindowStation, 1 },
	 { "SetUserObjectInformation", PySetUserObjectInformation, 1 },
	 { "GetUserObjectInformation", PyGetUserObjectInformation, 1 },
	 { "EnumWindowStations", PyEnumWindowStations, 1 },
	 { "GetThreadDesktop", PyGetThreadDesktop, 1 },
	 { NULL, NULL }
};
static PyObject *SWIG_globals;
#ifdef __cplusplus
extern "C" 
#endif
#if (PY_VERSION_HEX < 0x03000000)
#define MODINIT_ERROR_RETURN
SWIGEXPORT(void,initwin32service)() {
#else
#define MODINIT_ERROR_RETURN NULL
SWIGEXPORT(PyObject*,  PyInit_win32service)(void) {
#endif
	 PyObject *m, *d;
	 SWIG_globals = SWIG_newvarlink();
#if (PY_VERSION_HEX < 0x03000000)
	 m = Py_InitModule("win32service", win32serviceMethods);
	 d = PyModule_GetDict(m);
#else
  static PyModuleDef win32service_def = {
    PyModuleDef_HEAD_INIT,
      "win32service",
      "",
      -1,
      win32serviceMethods,
      };
  m = PyModule_Create(&win32service_def);
  if (!m)
    return NULL;
  d = PyModule_GetDict(m);
  if (!d)
    return NULL;
#endif

#ifndef SWIG_PYTHONCOM
/* This code only valid if non COM SWIG builds */
#ifndef PYCOM_EXPORT
	 PyDict_SetItemString(d,"UNICODE", PyInt_FromLong(
#ifdef UNICODE
	1
#else
	0
#endif
	));
#endif
  PyWinGlobals_Ensure();
  PyDict_SetItemString(d, "error", PyWinExc_ApiError);
#endif SWIG_PYTHONCOM


#if (PY_VERSION_HEX >= 0x03000000)
	if (PyType_Ready(&PyHWINSTAType) == -1 ||
		PyType_Ready(&PyHDESKType) == -1)
		return NULL;
#endif

	// All errors raised by this module are of this type.
	PyDict_SetItemString(d, "error", PyWinExc_ApiError);
	PyDict_SetItemString(d, "HWINSTAType", (PyObject *)&PyHWINSTAType);
	PyDict_SetItemString(d, "HDESKType", (PyObject *)&PyHDESKType);
	HMODULE hmod;
	FARPROC fp;
	hmod=GetModuleHandle(_T("Advapi32"));
	if (hmod==NULL)
		hmod=LoadLibrary(_T("Advapi32"));
	if (hmod!=NULL){
		fp=GetProcAddress(hmod,"QueryServiceStatusEx");
		if (fp!=NULL)
			fpQueryServiceStatusEx=(QueryServiceStatusExfunc)fp;
		fp=GetProcAddress(hmod,"ChangeServiceConfig2W");
		if (fp!=NULL)
			fpChangeServiceConfig2=(ChangeServiceConfig2func)fp;
		fp=GetProcAddress(hmod,"QueryServiceConfig2W");
		if (fp!=NULL)
			fpQueryServiceConfig2=(QueryServiceConfig2func)fp;
		fp=GetProcAddress(hmod,"EnumServicesStatusExW");
		if (fp!=NULL)
			fpEnumServicesStatusEx=(EnumServicesStatusExfunc)fp;
		}
	 PyDict_SetItemString(d,"SERVICE_WIN32", PyInt_FromLong((long) SERVICE_WIN32));
	 PyDict_SetItemString(d,"SERVICE_DRIVER", PyInt_FromLong((long) SERVICE_DRIVER));
	 PyDict_SetItemString(d,"SERVICE_ACTIVE", PyInt_FromLong((long) SERVICE_ACTIVE));
	 PyDict_SetItemString(d,"SERVICE_INACTIVE", PyInt_FromLong((long) SERVICE_INACTIVE));
	 PyDict_SetItemString(d,"SERVICE_STATE_ALL", PyInt_FromLong((long) SERVICE_STATE_ALL));
	 PyDict_SetItemString(d,"SERVICE_CONTROL_STOP", PyInt_FromLong((long) SERVICE_CONTROL_STOP));
	 PyDict_SetItemString(d,"SERVICE_CONTROL_PAUSE", PyInt_FromLong((long) SERVICE_CONTROL_PAUSE));
	 PyDict_SetItemString(d,"SERVICE_CONTROL_CONTINUE", PyInt_FromLong((long) SERVICE_CONTROL_CONTINUE));
	 PyDict_SetItemString(d,"SERVICE_CONTROL_INTERROGATE", PyInt_FromLong((long) SERVICE_CONTROL_INTERROGATE));
	 PyDict_SetItemString(d,"SERVICE_CONTROL_SHUTDOWN", PyInt_FromLong((long) SERVICE_CONTROL_SHUTDOWN));
	 PyDict_SetItemString(d,"SERVICE_CONTROL_PARAMCHANGE", PyInt_FromLong((long) SERVICE_CONTROL_PARAMCHANGE));
	 PyDict_SetItemString(d,"SERVICE_CONTROL_NETBINDADD", PyInt_FromLong((long) SERVICE_CONTROL_NETBINDADD));
	 PyDict_SetItemString(d,"SERVICE_CONTROL_NETBINDREMOVE", PyInt_FromLong((long) SERVICE_CONTROL_NETBINDREMOVE));
	 PyDict_SetItemString(d,"SERVICE_CONTROL_NETBINDENABLE", PyInt_FromLong((long) SERVICE_CONTROL_NETBINDENABLE));
	 PyDict_SetItemString(d,"SERVICE_CONTROL_NETBINDDISABLE", PyInt_FromLong((long) SERVICE_CONTROL_NETBINDDISABLE));
	 PyDict_SetItemString(d,"SERVICE_CONTROL_DEVICEEVENT", PyInt_FromLong((long) SERVICE_CONTROL_DEVICEEVENT));
	 PyDict_SetItemString(d,"SERVICE_CONTROL_HARDWAREPROFILECHANGE", PyInt_FromLong((long) SERVICE_CONTROL_HARDWAREPROFILECHANGE));
	 PyDict_SetItemString(d,"SERVICE_CONTROL_POWEREVENT", PyInt_FromLong((long) SERVICE_CONTROL_POWEREVENT));
	 PyDict_SetItemString(d,"SERVICE_CONTROL_SESSIONCHANGE", PyInt_FromLong((long) SERVICE_CONTROL_SESSIONCHANGE));
	 PyDict_SetItemString(d,"SERVICE_CONTROL_PRESHUTDOWN", PyInt_FromLong((long) SERVICE_CONTROL_PRESHUTDOWN));
	 PyDict_SetItemString(d,"SC_MANAGER_ALL_ACCESS", PyInt_FromLong((long) SC_MANAGER_ALL_ACCESS));
	 PyDict_SetItemString(d,"SC_MANAGER_CONNECT", PyInt_FromLong((long) SC_MANAGER_CONNECT));
	 PyDict_SetItemString(d,"SC_MANAGER_CREATE_SERVICE", PyInt_FromLong((long) SC_MANAGER_CREATE_SERVICE));
	 PyDict_SetItemString(d,"SC_MANAGER_ENUMERATE_SERVICE", PyInt_FromLong((long) SC_MANAGER_ENUMERATE_SERVICE));
	 PyDict_SetItemString(d,"SC_MANAGER_LOCK", PyInt_FromLong((long) SC_MANAGER_LOCK));
	 PyDict_SetItemString(d,"SC_MANAGER_QUERY_LOCK_STATUS", PyInt_FromLong((long) SC_MANAGER_QUERY_LOCK_STATUS));
	 PyDict_SetItemString(d,"SC_MANAGER_MODIFY_BOOT_CONFIG", PyInt_FromLong((long) SC_MANAGER_MODIFY_BOOT_CONFIG));
	 PyDict_SetItemString(d,"SC_GROUP_IDENTIFIER", PyInt_FromLong((long) SC_GROUP_IDENTIFIER));
	 PyDict_SetItemString(d,"SERVICE_WIN32_OWN_PROCESS", PyInt_FromLong((long) SERVICE_WIN32_OWN_PROCESS));
	 PyDict_SetItemString(d,"SERVICE_WIN32_SHARE_PROCESS", PyInt_FromLong((long) SERVICE_WIN32_SHARE_PROCESS));
	 PyDict_SetItemString(d,"SERVICE_KERNEL_DRIVER", PyInt_FromLong((long) SERVICE_KERNEL_DRIVER));
	 PyDict_SetItemString(d,"SERVICE_FILE_SYSTEM_DRIVER", PyInt_FromLong((long) SERVICE_FILE_SYSTEM_DRIVER));
	 PyDict_SetItemString(d,"SERVICE_INTERACTIVE_PROCESS", PyInt_FromLong((long) SERVICE_INTERACTIVE_PROCESS));
	 PyDict_SetItemString(d,"SERVICE_STOPPED", PyInt_FromLong((long) SERVICE_STOPPED));
	 PyDict_SetItemString(d,"SERVICE_START_PENDING", PyInt_FromLong((long) SERVICE_START_PENDING));
	 PyDict_SetItemString(d,"SERVICE_STOP_PENDING", PyInt_FromLong((long) SERVICE_STOP_PENDING));
	 PyDict_SetItemString(d,"SERVICE_RUNNING", PyInt_FromLong((long) SERVICE_RUNNING));
	 PyDict_SetItemString(d,"SERVICE_CONTINUE_PENDING", PyInt_FromLong((long) SERVICE_CONTINUE_PENDING));
	 PyDict_SetItemString(d,"SERVICE_PAUSE_PENDING", PyInt_FromLong((long) SERVICE_PAUSE_PENDING));
	 PyDict_SetItemString(d,"SERVICE_PAUSED", PyInt_FromLong((long) SERVICE_PAUSED));
	 PyDict_SetItemString(d,"SERVICE_ACCEPT_STOP", PyInt_FromLong((long) SERVICE_ACCEPT_STOP));
	 PyDict_SetItemString(d,"SERVICE_ACCEPT_PAUSE_CONTINUE", PyInt_FromLong((long) SERVICE_ACCEPT_PAUSE_CONTINUE));
	 PyDict_SetItemString(d,"SERVICE_ACCEPT_SHUTDOWN", PyInt_FromLong((long) SERVICE_ACCEPT_SHUTDOWN));
	 PyDict_SetItemString(d,"SERVICE_ACCEPT_PARAMCHANGE", PyInt_FromLong((long) SERVICE_ACCEPT_PARAMCHANGE));
	 PyDict_SetItemString(d,"SERVICE_ACCEPT_NETBINDCHANGE", PyInt_FromLong((long) SERVICE_ACCEPT_NETBINDCHANGE));
	 PyDict_SetItemString(d,"SERVICE_ACCEPT_HARDWAREPROFILECHANGE", PyInt_FromLong((long) SERVICE_ACCEPT_HARDWAREPROFILECHANGE));
	 PyDict_SetItemString(d,"SERVICE_ACCEPT_POWEREVENT", PyInt_FromLong((long) SERVICE_ACCEPT_POWEREVENT));
	 PyDict_SetItemString(d,"SERVICE_ACCEPT_SESSIONCHANGE", PyInt_FromLong((long) SERVICE_ACCEPT_SESSIONCHANGE));
	 PyDict_SetItemString(d,"SERVICE_ACCEPT_PRESHUTDOWN", PyInt_FromLong((long) SERVICE_ACCEPT_PRESHUTDOWN));
	 PyDict_SetItemString(d,"SERVICE_BOOT_START", PyInt_FromLong((long) SERVICE_BOOT_START));
	 PyDict_SetItemString(d,"SERVICE_SYSTEM_START", PyInt_FromLong((long) SERVICE_SYSTEM_START));
	 PyDict_SetItemString(d,"SERVICE_AUTO_START", PyInt_FromLong((long) SERVICE_AUTO_START));
	 PyDict_SetItemString(d,"SERVICE_DEMAND_START", PyInt_FromLong((long) SERVICE_DEMAND_START));
	 PyDict_SetItemString(d,"SERVICE_DISABLED", PyInt_FromLong((long) SERVICE_DISABLED));
	 PyDict_SetItemString(d,"SERVICE_ERROR_IGNORE", PyInt_FromLong((long) SERVICE_ERROR_IGNORE));
	 PyDict_SetItemString(d,"SERVICE_ERROR_NORMAL", PyInt_FromLong((long) SERVICE_ERROR_NORMAL));
	 PyDict_SetItemString(d,"SERVICE_ERROR_SEVERE", PyInt_FromLong((long) SERVICE_ERROR_SEVERE));
	 PyDict_SetItemString(d,"SERVICE_ERROR_CRITICAL", PyInt_FromLong((long) SERVICE_ERROR_CRITICAL));
	 PyDict_SetItemString(d,"SERVICE_ALL_ACCESS", PyInt_FromLong((long) SERVICE_ALL_ACCESS));
	 PyDict_SetItemString(d,"SERVICE_CHANGE_CONFIG", PyInt_FromLong((long) SERVICE_CHANGE_CONFIG));
	 PyDict_SetItemString(d,"SERVICE_ENUMERATE_DEPENDENTS", PyInt_FromLong((long) SERVICE_ENUMERATE_DEPENDENTS));
	 PyDict_SetItemString(d,"SERVICE_INTERROGATE", PyInt_FromLong((long) SERVICE_INTERROGATE));
	 PyDict_SetItemString(d,"SERVICE_PAUSE_CONTINUE", PyInt_FromLong((long) SERVICE_PAUSE_CONTINUE));
	 PyDict_SetItemString(d,"SERVICE_QUERY_CONFIG", PyInt_FromLong((long) SERVICE_QUERY_CONFIG));
	 PyDict_SetItemString(d,"SERVICE_QUERY_STATUS", PyInt_FromLong((long) SERVICE_QUERY_STATUS));
	 PyDict_SetItemString(d,"SERVICE_START", PyInt_FromLong((long) SERVICE_START));
	 PyDict_SetItemString(d,"SERVICE_STOP", PyInt_FromLong((long) SERVICE_STOP));
	 PyDict_SetItemString(d,"SERVICE_USER_DEFINED_CONTROL", PyInt_FromLong((long) SERVICE_USER_DEFINED_CONTROL));
	 PyDict_SetItemString(d,"SERVICE_NO_CHANGE", PyInt_FromLong((long) SERVICE_NO_CHANGE));
	 PyDict_SetItemString(d,"SERVICE_SPECIFIC_ERROR", PyInt_FromLong((long) ERROR_SERVICE_SPECIFIC_ERROR));
	 PyDict_SetItemString(d,"UOI_FLAGS", PyInt_FromLong((long) UOI_FLAGS));
	 PyDict_SetItemString(d,"UOI_NAME", PyInt_FromLong((long) UOI_NAME));
	 PyDict_SetItemString(d,"UOI_TYPE", PyInt_FromLong((long) UOI_TYPE));
	 PyDict_SetItemString(d,"UOI_USER_SID", PyInt_FromLong((long) UOI_USER_SID));
	 PyDict_SetItemString(d,"WSF_VISIBLE", PyInt_FromLong((long) WSF_VISIBLE));
	 PyDict_SetItemString(d,"DF_ALLOWOTHERACCOUNTHOOK", PyInt_FromLong((long) DF_ALLOWOTHERACCOUNTHOOK));
	 PyDict_SetItemString(d,"SERVICE_CONFIG_DESCRIPTION", PyInt_FromLong((long) SERVICE_CONFIG_DESCRIPTION));
	 PyDict_SetItemString(d,"SERVICE_CONFIG_FAILURE_ACTIONS", PyInt_FromLong((long) SERVICE_CONFIG_FAILURE_ACTIONS));
	 PyDict_SetItemString(d,"SERVICE_CONFIG_DELAYED_AUTO_START_INFO", PyInt_FromLong((long) SERVICE_CONFIG_DELAYED_AUTO_START_INFO));
	 PyDict_SetItemString(d,"SERVICE_CONFIG_FAILURE_ACTIONS_FLAG", PyInt_FromLong((long) SERVICE_CONFIG_FAILURE_ACTIONS_FLAG));
	 PyDict_SetItemString(d,"SERVICE_CONFIG_PRESHUTDOWN_INFO", PyInt_FromLong((long) SERVICE_CONFIG_PRESHUTDOWN_INFO));
	 PyDict_SetItemString(d,"SERVICE_CONFIG_REQUIRED_PRIVILEGES_INFO", PyInt_FromLong((long) SERVICE_CONFIG_REQUIRED_PRIVILEGES_INFO));
	 PyDict_SetItemString(d,"SERVICE_CONFIG_SERVICE_SID_INFO", PyInt_FromLong((long) SERVICE_CONFIG_SERVICE_SID_INFO));
	 PyDict_SetItemString(d,"SC_ENUM_PROCESS_INFO", PyInt_FromLong((long) SC_ENUM_PROCESS_INFO));
	 PyDict_SetItemString(d,"SERVICE_SID_TYPE_NONE", PyInt_FromLong((long) SERVICE_SID_TYPE_NONE));
	 PyDict_SetItemString(d,"SERVICE_SID_TYPE_RESTRICTED", PyInt_FromLong((long) SERVICE_SID_TYPE_RESTRICTED));
	 PyDict_SetItemString(d,"SERVICE_SID_TYPE_UNRESTRICTED", PyInt_FromLong((long) SERVICE_SID_TYPE_UNRESTRICTED));
	 PyDict_SetItemString(d,"SC_ACTION_NONE", PyInt_FromLong((long) SC_ACTION_NONE));
	 PyDict_SetItemString(d,"SC_ACTION_REBOOT", PyInt_FromLong((long) SC_ACTION_REBOOT));
	 PyDict_SetItemString(d,"SC_ACTION_RESTART", PyInt_FromLong((long) SC_ACTION_RESTART));
	 PyDict_SetItemString(d,"SC_ACTION_RUN_COMMAND", PyInt_FromLong((long) SC_ACTION_RUN_COMMAND));
	 PyDict_SetItemString(d,"DBT_DEVICEARRIVAL", PyInt_FromLong((long) DBT_DEVICEARRIVAL));
	 PyDict_SetItemString(d,"DBT_DEVICEQUERYREMOVE", PyInt_FromLong((long) DBT_DEVICEQUERYREMOVE));
	 PyDict_SetItemString(d,"DBT_DEVICEQUERYREMOVEFAILED", PyInt_FromLong((long) DBT_DEVICEQUERYREMOVEFAILED));
	 PyDict_SetItemString(d,"DBT_DEVICEREMOVEPENDING", PyInt_FromLong((long) DBT_DEVICEREMOVEPENDING));
	 PyDict_SetItemString(d,"DBT_DEVICEREMOVECOMPLETE", PyInt_FromLong((long) DBT_DEVICEREMOVECOMPLETE));
	 PyDict_SetItemString(d,"DBT_DEVICETYPESPECIFIC", PyInt_FromLong((long) DBT_DEVICETYPESPECIFIC));
	 PyDict_SetItemString(d,"DBT_CUSTOMEVENT", PyInt_FromLong((long) DBT_CUSTOMEVENT));
	 PyDict_SetItemString(d,"DBT_QUERYCHANGECONFIG", PyInt_FromLong((long) DBT_QUERYCHANGECONFIG));
	 PyDict_SetItemString(d,"DBT_CONFIGCHANGED", PyInt_FromLong((long) DBT_CONFIGCHANGED));
	 PyDict_SetItemString(d,"DBT_CONFIGCHANGECANCELED", PyInt_FromLong((long) DBT_CONFIGCHANGECANCELED));
#if (PY_VERSION_HEX > 0x03000000)
	return m;
#endif
}
