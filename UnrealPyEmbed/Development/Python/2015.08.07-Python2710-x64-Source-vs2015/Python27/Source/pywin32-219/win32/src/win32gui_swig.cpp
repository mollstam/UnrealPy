/*
 * FILE : C:\Python27\Source\pywin32-219\win32\src\win32gui_swig.cpp
 * 
 * This file was automatically generated by :
 * Simplified Wrapper and Interface Generator (SWIG)
 * Version 1.1 (Patch 5)
 * 
 * Portions Copyright (c) 1995-1998
 * The University of Utah and The Regents of the University of California.
 * Permission is granted to distribute this file in any manner provided
 * this notice remains intact.
 * 
 * Do not make changes to this file--changes will be lost!
 *
 */


#define SWIGCODE
/* Implementation : PYTHON */

#define SWIGPYTHON
#include <string.h>
#include <stdlib.h>
/***********************************************************************
 * $Header$
 * swig_lib/python/python.cfg
 *
 * This file contains coded needed to add variable linking to the
 * Python interpreter.   C variables are added as a new kind of Python
 * datatype.
 *
 * Also contains supporting code for building python under Windows
 * and things like that.
 *
 * $Log$
 * Revision 1.1  2000/03/14 23:34:06  mhammond
 * Needed to modify a standard Swig file to avoid the 'extern "C"' around Python.h (which gets upset when it tries to include whcar.h as part of the new Unicode patches)
 *
 ************************************************************************/

#include "Python.h"

/* Definitions for Windows/Unix exporting */
#if defined(__WIN32__)
#   if defined(_MSC_VER)
#	define SWIGEXPORT(a,b) __declspec(dllexport) a b
#   else
#	if defined(__BORLANDC__)
#	    define SWIGEXPORT(a,b) a _export b
#	else
#	    define SWIGEXPORT(a,b) a b
#	endif
#   endif
#else
#   define SWIGEXPORT(a,b) a b
#endif

#ifdef SWIG_GLOBAL
#ifdef __cplusplus
#define SWIGSTATIC extern "C"
#else
#define SWIGSTATIC
#endif
#endif

#ifndef SWIGSTATIC
#define SWIGSTATIC static
#endif

#ifdef NEED_SWIG_VARLINK

typedef struct {
  char  *name;
  PyObject *(*get_attr)(void);
  int (*set_attr)(PyObject *);
} swig_globalvar;

typedef struct swig_varlinkobject {
  PyObject_HEAD
  swig_globalvar **vars;
  int      nvars;
  int      maxvars;
} swig_varlinkobject;

/* ----------------------------------------------------------------------
   swig_varlink_repr()

   Function for python repr method
   ---------------------------------------------------------------------- */

static PyObject *
swig_varlink_repr(swig_varlinkobject *v)
{
  v = v;
  return PyString_FromString("<Global variables>");
}

/* ---------------------------------------------------------------------
   swig_varlink_print()

   Print out all of the global variable names
   --------------------------------------------------------------------- */

static int
swig_varlink_print(swig_varlinkobject *v, FILE *fp, int flags)
{

  int i = 0;
  flags = flags;
  fprintf(fp,"Global variables { ");
  while (v->vars[i]) {
    fprintf(fp,"%s", v->vars[i]->name);
    i++;
    if (v->vars[i]) fprintf(fp,", ");
  }
  fprintf(fp," }\n");
  return 0;
}

/* --------------------------------------------------------------------
   swig_varlink_getattr
 
   This function gets the value of a variable and returns it as a
   PyObject.   In our case, we'll be looking at the datatype and
   converting into a number or string
   -------------------------------------------------------------------- */

static PyObject *
swig_varlink_getattr(swig_varlinkobject *v, char *n)
{
  int i = 0;
  char temp[128];

  while (v->vars[i]) {
    if (strcmp(v->vars[i]->name,n) == 0) {
      return (*v->vars[i]->get_attr)();
    }
    i++;
  }
  sprintf(temp,"C global variable %s not found.", n);
  PyErr_SetString(PyExc_NameError,temp);
  return NULL;
}

/* -------------------------------------------------------------------
   swig_varlink_setattr()

   This function sets the value of a variable.
   ------------------------------------------------------------------- */

static int
swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p)
{
  char temp[128];
  int i = 0;
  while (v->vars[i]) {
    if (strcmp(v->vars[i]->name,n) == 0) {
      return (*v->vars[i]->set_attr)(p);
    }
    i++;
  }
  sprintf(temp,"C global variable %s not found.", n);
  PyErr_SetString(PyExc_NameError,temp);
  return 1;
}

statichere PyTypeObject varlinktype = {
/*  PyObject_HEAD_INIT(&PyType_Type)  Note : This doesn't work on some machines */
  PyObject_HEAD_INIT(0)              
  0,
  "varlink",                          /* Type name    */
  sizeof(swig_varlinkobject),         /* Basic size   */
  0,                                  /* Itemsize     */
  0,                                  /* Deallocator  */ 
  (printfunc) swig_varlink_print,     /* Print        */
  (getattrfunc) swig_varlink_getattr, /* get attr     */
  (setattrfunc) swig_varlink_setattr, /* Set attr     */
  0,                                  /* tp_compare   */
  (reprfunc) swig_varlink_repr,       /* tp_repr      */    
  0,                                  /* tp_as_number */
  0,                                  /* tp_as_mapping*/
  0,                                  /* tp_hash      */
};

/* Create a variable linking object for use later */

SWIGSTATIC PyObject *
SWIG_newvarlink(void)
{
  swig_varlinkobject *result = 0;
  result = PyMem_NEW(swig_varlinkobject,1);
  varlinktype.ob_type = &PyType_Type;    /* Patch varlinktype into a PyType */
  result->ob_type = &varlinktype;
  /*  _Py_NewReference(result);  Does not seem to be necessary */
  result->nvars = 0;
  result->maxvars = 64;
  result->vars = (swig_globalvar **) malloc(64*sizeof(swig_globalvar *));
  result->vars[0] = 0;
  Py_XINCREF((PyObject *) result);
  return ((PyObject*) result);
}

SWIGSTATIC void
SWIG_addvarlink(PyObject *p, char *name,
	   PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p))
{
  swig_varlinkobject *v;
  v= (swig_varlinkobject *) p;
	
  if (v->nvars >= v->maxvars -1) {
    v->maxvars = 2*v->maxvars;
    v->vars = (swig_globalvar **) realloc(v->vars,v->maxvars*sizeof(swig_globalvar *));
    if (v->vars == NULL) {
      fprintf(stderr,"SWIG : Fatal error in initializing Python module.\n");
      exit(1);
    }
  }
  v->vars[v->nvars] = (swig_globalvar *) malloc(sizeof(swig_globalvar));
  v->vars[v->nvars]->name = (char *) malloc(strlen(name)+1);
  strcpy(v->vars[v->nvars]->name,name);
  v->vars[v->nvars]->get_attr = get_attr;
  v->vars[v->nvars]->set_attr = set_attr;
  v->nvars++;
  v->vars[v->nvars] = 0;
}

#else
#define SWIG_newvarlink() Py_None
#endif /* SWIG_NEED_VARLINK */
#ifdef NEED_SWIG_PTR
/*****************************************************************************
 * $Header$
 *
 * swigptr.swg
 *
 * This file contains supporting code for the SWIG run-time type checking
 * mechanism.  The following functions are available :
 *
 * SWIG_RegisterMapping(char *origtype, char *newtype, void *(*cast)(void *));
 *
 *      Registers a new type-mapping with the type-checker.  origtype is the
 *      original datatype and newtype is an equivalent type.  cast is optional
 *      pointer to a function to cast pointer values between types (this
 *      is typically used to cast pointers from derived classes to base classes in C++)
 *      
 * SWIG_MakePtr(char *buffer, void *ptr, char *typestring);
 *     
 *      Makes a pointer string from a pointer and typestring.  The result is returned
 *      in buffer which is assumed to hold enough space for the result.
 *
 * char * SWIG_GetPtr(char *buffer, void **ptr, char *type)
 *
 *      Gets a pointer value from a string.  If there is a type-mismatch, returns
 *      a character string to the received type.  On success, returns NULL.
 *
 *
 * You can remap these functions by making a file called "swigptr.swg" in
 * your the same directory as the interface file you are wrapping.
 *
 * These functions are normally declared static, but this file can be
 * can be used in a multi-module environment by redefining the symbol
 * SWIGSTATIC.
 *****************************************************************************/

#include <stdlib.h>

#ifdef SWIG_GLOBAL
#ifdef __cplusplus
#define SWIGSTATIC extern "C"
#else
#define SWIGSTATIC
#endif
#endif

#ifndef SWIGSTATIC
#define SWIGSTATIC static
#endif


/* SWIG pointer structure */

typedef struct SwigPtrType {
  char               *name;               /* Datatype name                  */
  int                 len;                /* Length (used for optimization) */
  void               *(*cast)(void *);    /* Pointer casting function       */
  struct SwigPtrType *next;               /* Linked list pointer            */
} SwigPtrType;

/* Pointer cache structure */

typedef struct {
  int                 stat;               /* Status (valid) bit             */
  SwigPtrType        *tp;                 /* Pointer to type structure      */
  char                name[256];          /* Given datatype name            */
  char                mapped[256];        /* Equivalent name                */
} SwigCacheType;

/* Some variables  */

static int SwigPtrMax  = 64;           /* Max entries that can be currently held */
                                       /* This value may be adjusted dynamically */
static int SwigPtrN    = 0;            /* Current number of entries              */
static int SwigPtrSort = 0;            /* Status flag indicating sort            */
static int SwigStart[256];             /* Starting positions of types            */

/* Pointer table */
static SwigPtrType *SwigPtrTable = 0;  /* Table containing pointer equivalences  */

/* Cached values */

#define SWIG_CACHESIZE  8
#define SWIG_CACHEMASK  0x7
static SwigCacheType SwigCache[SWIG_CACHESIZE];  
static int SwigCacheIndex = 0;
static int SwigLastCache = 0;

/* Sort comparison function */
static int swigsort(const void *data1, const void *data2) {
	SwigPtrType *d1 = (SwigPtrType *) data1;
	SwigPtrType *d2 = (SwigPtrType *) data2;
	return strcmp(d1->name,d2->name);
}

/* Binary Search function */
static int swigcmp(const void *key, const void *data) {
  char *k = (char *) key;
  SwigPtrType *d = (SwigPtrType *) data;
  return strncmp(k,d->name,d->len);
}

/* Register a new datatype with the type-checker */

SWIGSTATIC 
void SWIG_RegisterMapping(char *origtype, char *newtype, void *(*cast)(void *)) {

  int i;
  SwigPtrType *t = 0,*t1;

  /* Allocate the pointer table if necessary */

  if (!SwigPtrTable) {     
    SwigPtrTable = (SwigPtrType *) malloc(SwigPtrMax*sizeof(SwigPtrType));
    SwigPtrN = 0;
  }
  /* Grow the table */
  if (SwigPtrN >= SwigPtrMax) {
    SwigPtrMax = 2*SwigPtrMax;
    SwigPtrTable = (SwigPtrType *) realloc((char *) SwigPtrTable,SwigPtrMax*sizeof(SwigPtrType));
  }
  for (i = 0; i < SwigPtrN; i++)
    if (strcmp(SwigPtrTable[i].name,origtype) == 0) {
      t = &SwigPtrTable[i];
      break;
    }
  if (!t) {
    t = &SwigPtrTable[SwigPtrN];
    t->name = origtype;
    t->len = strlen(t->name);
    t->cast = 0;
    t->next = 0;
    SwigPtrN++;
  }

  /* Check for existing entry */

  while (t->next) {
    if ((strcmp(t->name,newtype) == 0)) {
      if (cast) t->cast = cast;
      return;
    }
    t = t->next;
  }
  
  /* Now place entry (in sorted order) */

  t1 = (SwigPtrType *) malloc(sizeof(SwigPtrType));
  t1->name = newtype;
  t1->len = strlen(t1->name);
  t1->cast = cast;
  t1->next = 0;            
  t->next = t1;           
  SwigPtrSort = 0;
}

/* Make a pointer value string */

SWIGSTATIC 
void SWIG_MakePtr(char *_c, const void *_ptr, char *type) {
  static char _hex[16] =
  {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
   'a', 'b', 'c', 'd', 'e', 'f'};
  unsigned long _p, _s;
  char _result[20], *_r;    /* Note : a 64-bit hex number = 16 digits */
  _r = _result;
  _p = (unsigned long) _ptr;
  if (_p > 0) {
    while (_p > 0) {
      _s = _p & 0xf;
      *(_r++) = _hex[_s];
      _p = _p >> 4;
    }
    *_r = '_';
    while (_r >= _result)
      *(_c++) = *(_r--);
  } else {
    strcpy (_c, "NULL");
  }
  if (_ptr)
    strcpy (_c, type);
}

/* Define for backwards compatibility */

#define _swig_make_hex   SWIG_MakePtr 

/* Function for getting a pointer value */

SWIGSTATIC 
char *SWIG_GetPtr(char *_c, void **ptr, char *_t)
{
  unsigned long _p;
  char temp_type[256];
  char *name;
  int  i, len;
  SwigPtrType *sp,*tp;
  SwigCacheType *cache;
  int  start, end;
  _p = 0;

  /* Pointer values must start with leading underscore */
  if (*_c == '_') {
      _c++;
      /* Extract hex value from pointer */
      while (*_c) {
	  if ((*_c >= '0') && (*_c <= '9'))
	    _p = (_p << 4) + (*_c - '0');
	  else if ((*_c >= 'a') && (*_c <= 'f'))
	    _p = (_p << 4) + ((*_c - 'a') + 10);
	  else
	    break;
	  _c++;
      }

      if (_t) {
	if (strcmp(_t,_c)) { 
	  if (!SwigPtrSort) {
	    qsort((void *) SwigPtrTable, SwigPtrN, sizeof(SwigPtrType), swigsort); 
	    for (i = 0; i < 256; i++) {
	      SwigStart[i] = SwigPtrN;
	    }
	    for (i = SwigPtrN-1; i >= 0; i--) {
	      SwigStart[(int) (SwigPtrTable[i].name[1])] = i;
	    }
	    for (i = 255; i >= 1; i--) {
	      if (SwigStart[i-1] > SwigStart[i])
		SwigStart[i-1] = SwigStart[i];
	    }
	    SwigPtrSort = 1;
	    for (i = 0; i < SWIG_CACHESIZE; i++)  
	      SwigCache[i].stat = 0;
	  }
	  
	  /* First check cache for matches.  Uses last cache value as starting point */
	  cache = &SwigCache[SwigLastCache];
	  for (i = 0; i < SWIG_CACHESIZE; i++) {
	    if (cache->stat) {
	      if (strcmp(_t,cache->name) == 0) {
		if (strcmp(_c,cache->mapped) == 0) {
		  cache->stat++;
		  *ptr = (void *) _p;
		  if (cache->tp->cast) *ptr = (*(cache->tp->cast))(*ptr);
		  return (char *) 0;
		}
	      }
	    }
	    SwigLastCache = (SwigLastCache+1) & SWIG_CACHEMASK;
	    if (!SwigLastCache) cache = SwigCache;
	    else cache++;
	  }
	  /* We have a type mismatch.  Will have to look through our type
	     mapping table to figure out whether or not we can accept this datatype */

	  start = SwigStart[(int) _t[1]];
	  end = SwigStart[(int) _t[1]+1];
	  sp = &SwigPtrTable[start];
	  while (start < end) {
	    if (swigcmp(_t,sp) == 0) break;
	    sp++;
	    start++;
	  }
	  if (start >= end) sp = 0;
	  /* Try to find a match for this */
	  if (sp) {
	    while (swigcmp(_t,sp) == 0) {
	      name = sp->name;
	      len = sp->len;
	      tp = sp->next;
	      /* Try to find entry for our given datatype */
	      while(tp) {
		if (tp->len >= 255) {
		  return _c;
		}
		strncpy(temp_type,tp->name,255);
		strncat(temp_type,_t+len,255-tp->len);
		if (strcmp(_c,temp_type) == 0) {
		  
		  strcpy(SwigCache[SwigCacheIndex].mapped,_c);
		  strcpy(SwigCache[SwigCacheIndex].name,_t);
		  SwigCache[SwigCacheIndex].stat = 1;
		  SwigCache[SwigCacheIndex].tp = tp;
		  SwigCacheIndex = SwigCacheIndex & SWIG_CACHEMASK;
		  
		  /* Get pointer value */
		  *ptr = (void *) _p;
		  if (tp->cast) *ptr = (*(tp->cast))(*ptr);
		  return (char *) 0;
		}
		tp = tp->next;
	      }
	      sp++;
	      /* Hmmm. Didn't find it this time */
	    }
	  }
	  /* Didn't find any sort of match for this data.  
	     Get the pointer value and return the received type */
	  *ptr = (void *) _p;
	  return _c;
	} else {
	  /* Found a match on the first try.  Return pointer value */
	  *ptr = (void *) _p;
	  return (char *) 0;
	}
      } else {
	/* No type specified.  Good luck */
	*ptr = (void *) _p;
	return (char *) 0;
      }
  } else {
    if (strcmp (_c, "NULL") == 0) {
	*ptr = (void *) 0;
	return (char *) 0;
    }
    *ptr = (void *) 0;	
    return _c;
  }
}

/* Compatibility mode */

#define _swig_get_hex  SWIG_GetPtr

#else
#define SWIG_RegisterMapping(a,b,c)
#endif // NEED_SWIG_PTR
#define SWIG_init    initwin32gui

#define SWIG_name    "win32gui"

// #define UNICODE
// #define _UNICODE // for CRT string functions
#define _WIN32_IE 0x0501 // to enable balloon notifications in Shell_NotifyIcon
#define _WIN32_WINNT 0x0501
#ifdef WINXPGUI
// This changes the entire world for XP!
#define ISOLATION_AWARE_ENABLED 1
#endif


static PyObject* t_output_helper(PyObject* target, PyObject* o) {
    PyObject*   o2;
    PyObject*   o3;

    if (!target) {                   
        target = o;
    } else if (target == Py_None) {  
        Py_DECREF(Py_None);
        target = o;
    } else {                            
        if (!PyTuple_Check(target)) {   
            o2 = target;
            target = PyTuple_New(1);
            PyTuple_SetItem(target, 0, o2);
        }
        o3 = PyTuple_New(1);            
        PyTuple_SetItem(o3, 0, o);      

        o2 = target;
        target = PySequence_Concat(o2, o3); 
        Py_DECREF(o2);                      
        Py_DECREF(o3);
    }
    return target;
}

#include "PyWinTypes.h"
#ifdef NEED_PYWINOBJECTS_H
#include "PyWinObjects.h"
#endif
#include "tchar.h"
typedef BOOL  BOOLAPI;
typedef DWORD  DWORDAPI;

#define PyHANDLE HANDLE // Use a #define so we can undef it later if we need the true defn.
//typedef HANDLE PyHKEY;

#undef PyHANDLE
#include "pywinobjects.h"
#include "winuser.h"
#include "commctrl.h"
#include "windowsx.h" // For edit control hacks.
#include "Dbt.h" // device notification
#include "malloc.h"

#ifdef MS_WINCE
#include "winbase.h"
#define IS_INTRESOURCE(res) (((DWORD)(res) & 0xffff0000) == 0)
#endif

#define CHECK_PFN(fname)if (pfn##fname==NULL) return PyErr_Format(PyExc_NotImplementedError,"%s is not available on this platform", #fname);
typedef BOOL (WINAPI *SetLayeredWindowAttributesfunc)(HWND, COLORREF, BYTE,DWORD);
static SetLayeredWindowAttributesfunc pfnSetLayeredWindowAttributes=NULL;
typedef BOOL (WINAPI *GetLayeredWindowAttributesfunc)(HWND, COLORREF *, BYTE *, DWORD *);
static GetLayeredWindowAttributesfunc pfnGetLayeredWindowAttributes=NULL;
typedef BOOL (WINAPI *UpdateLayeredWindowfunc)(HWND,HDC,POINT *,SIZE *,HDC,POINT *,COLORREF,BLENDFUNCTION *,DWORD);
static UpdateLayeredWindowfunc pfnUpdateLayeredWindow=NULL;
typedef BOOL (WINAPI *AngleArcfunc)(HDC, int, int, DWORD, FLOAT, FLOAT);
static AngleArcfunc pfnAngleArc=NULL;
typedef BOOL (WINAPI *PlgBltfunc)(HDC,CONST POINT *,HDC,int,int,int,int,HBITMAP,int,int);
static PlgBltfunc pfnPlgBlt=NULL;
typedef BOOL (WINAPI *GetWorldTransformfunc)(HDC,XFORM *);
static GetWorldTransformfunc pfnGetWorldTransform=NULL;
typedef BOOL (WINAPI *SetWorldTransformfunc)(HDC,XFORM *);
static SetWorldTransformfunc pfnSetWorldTransform=NULL;
typedef BOOL (WINAPI *ModifyWorldTransformfunc)(HDC,XFORM *,DWORD);
static ModifyWorldTransformfunc pfnModifyWorldTransform=NULL;
typedef BOOL (WINAPI *CombineTransformfunc)(LPXFORM,CONST XFORM *,CONST XFORM *);
static CombineTransformfunc pfnCombineTransform=NULL;
typedef BOOL (WINAPI *GradientFillfunc)(HDC,PTRIVERTEX,ULONG,PVOID,ULONG,ULONG);
static GradientFillfunc pfnGradientFill=NULL;
typedef BOOL (WINAPI *TransparentBltfunc)(HDC,int,int,int,int,HDC,int,int,int,int,UINT);
static TransparentBltfunc pfnTransparentBlt=NULL;
typedef BOOL (WINAPI *MaskBltfunc)(HDC,int,int,int,int,HDC,int,int,HBITMAP,int,int,DWORD);
static MaskBltfunc pfnMaskBlt=NULL;
typedef BOOL (WINAPI *AlphaBlendfunc)(HDC,int,int,int,int,HDC,int,int,int,int,BLENDFUNCTION);
static AlphaBlendfunc pfnAlphaBlend=NULL;
typedef BOOL (WINAPI *AnimateWindowfunc)(HWND,DWORD,DWORD);
static AnimateWindowfunc pfnAnimateWindow=NULL;
typedef BOOL (WINAPI *GetMenuInfofunc)(HMENU, LPCMENUINFO);
static GetMenuInfofunc pfnGetMenuInfo=NULL;
typedef BOOL (WINAPI *SetMenuInfofunc)(HMENU, LPCMENUINFO);
static GetMenuInfofunc pfnSetMenuInfo=NULL;
typedef DWORD (WINAPI *GetLayoutfunc)(HDC);
static GetLayoutfunc pfnGetLayout=NULL;
typedef DWORD (WINAPI *SetLayoutfunc)(HDC, DWORD);
static SetLayoutfunc pfnSetLayout=NULL;
typedef int (WINAPI *DrawTextWfunc)(HDC,LPWSTR,int,LPRECT,UINT);
static DrawTextWfunc pfnDrawTextW = NULL;

static PyObject *g_AtomMap = NULL; // Mapping class atoms to Python WNDPROC
static PyObject *g_HWNDMap = NULL; // Mapping HWND to Python WNDPROC
static PyObject *g_DLGMap = NULL;  // Mapping Dialog HWND to Python WNDPROC

static	HWND	hDialogCurrent = NULL;	// see MS TID Q71450 and PumpMessages for this

extern HGLOBAL MakeResourceFromDlgList(PyObject *tmpl);
extern PyObject *MakeDlgListFromResource(HGLOBAL res);
HINSTANCE g_dllhandle;

static PyObject *logger = NULL;

void HandleError(char *prefix)
{
	BOOL do_stderr = TRUE;
	if (logger) {
		PyObject *exc_typ = NULL, *exc_val = NULL, *exc_tb = NULL;
		PyErr_Fetch( &exc_typ, &exc_val, &exc_tb);

		PyObject *kw = PyDict_New();
		PyObject *exc_info = Py_BuildValue("OOO", exc_typ, exc_val, exc_tb);
		if (kw)
			PyDict_SetItemString(kw, "exc_info", exc_info);
		Py_XDECREF(exc_info);
		PyObject *args = Py_BuildValue("(s)", prefix);
		PyObject *method = PyObject_GetAttrString(logger, "error");
		PyObject *result = NULL;
		if (method && kw && args)
			result = PyObject_Call(method, args, kw);
		Py_XDECREF(method);
		Py_XDECREF(kw);
		Py_XDECREF(args);
		if (result) {
			do_stderr = FALSE;
			Py_DECREF(result);
		}
	}
	if (do_stderr) {
		PySys_WriteStderr(prefix);
		PySys_WriteStderr("\n");
		PyErr_Print();
	}
}

// @object PyBLENDFUNCTION|Tuple of four small ints used to fill a BLENDFUNCTION struct
// Each int must fit in a byte (0-255).
// @pyseeapi BLENDFUNCTION
BOOL PyWinObject_AsBLENDFUNCTION(PyObject *obbl, BLENDFUNCTION *pbl)
{
	if (!PyTuple_Check(obbl)){
		PyErr_SetString(PyExc_TypeError, "BLENDFUNCTION must be a tuple of four small ints (0-255)");
		return FALSE;
		}
	return PyArg_ParseTuple(obbl, "BBBB:BLENDFUNCTION",
		&pbl->BlendOp,				// @tupleitem 0|int|BlendOp|Only defined value is AC_SRC_OVER (0)
		&pbl->BlendFlags,			// @tupleitem 1|int|BlendFlags|None currently defined, must be 0
		&pbl->SourceConstantAlpha,	// @tupleitem 2|int|SourceConstantAlpha|Transparency to be applied to entire source. (255 is opaque)
		&pbl->AlphaFormat);			// @tupleitem 3|int|AlphaFormat|Only defined flag is AC_SRC_ALPHA, used when src bitmap contains per-pixel alpha
}

// @object PySIZE|Tuple of two ints (cx,cy) representing a SIZE struct
BOOL PyWinObject_AsSIZE(PyObject *obsize, SIZE *psize)
{
	if (!PyTuple_Check(obsize)){
		PyErr_SetString(PyExc_TypeError, "SIZE must be a tuple of 2 ints (x,y)");
		return FALSE;
		}
	return PyArg_ParseTuple(obsize, "ll;SIZE must be a tuple of 2 ints (x,y)", 
		&psize->cx, &psize->cy);
}

// @object PyGdiHANDLE|Gdi objects such as brush (HBRUSH), pen (HPEN), font (HFONT), region (HRGN), bitmap (HBITMAP)
//	On destruction, the handle is closed using DeleteObject.  The object's Close() method also calls DeleteObject.
//	The gdi object should be deselected from any DC that it is selected into before it's closed.
//	Inherits the methods and properties of <o PyHANDLE>.
class PyGdiHANDLE: public PyHANDLE
{
public:
	PyGdiHANDLE(HANDLE hInit) : PyHANDLE(hInit) {}
	virtual BOOL Close(void){
		BOOL ret=DeleteObject(m_handle);
		if (!ret)
			PyWin_SetAPIError("DeleteObject");
		m_handle = 0;
		return ret;
		}
	virtual const char *GetTypeName(){
		return "PyGdiHANDLE";
		}
};

PyObject *PyWinObject_FromGdiHANDLE(HGDIOBJ h)
{
	PyObject *ret=new PyGdiHANDLE(h);
	if (ret==NULL) {
            DeleteObject(h);
	    PyErr_NoMemory();
        }
	return ret;
}
typedef int  int_regiontype;

// @object PyHDEVNOTIFY|A handle returned by RegisterDeviceNotifications which
//      automatically calls UnregisterDeviceNotification on destruction.
//	Inherits the methods and properties of <o PyHANDLE>.
class PyHDEVNOTIFY: public PyHANDLE
{
public:
	PyHDEVNOTIFY(HANDLE hInit) : PyHANDLE(hInit) {}
	virtual BOOL Close(void){
		BOOL ret=UnregisterDeviceNotification(m_handle);
		if (!ret)
			PyWin_SetAPIError("UnregisterDeviceNotification");
		m_handle = 0;
		return ret;
		}
	virtual const char *GetTypeName(){
		return "PyHDEVNOTIFY";
		}
};

PyObject *PyWinObject_FromHDEVNOTIFY(HGDIOBJ h)
{
	PyObject *ret=new PyHDEVNOTIFY(h);
	if (ret==NULL) {
            UnregisterDeviceNotification(h);
	    PyErr_NoMemory();
        }
	return ret;
}

#ifdef MS_WINCE
typedef HANDLE HINST_ARG;
// WinCE gives a compile error this with dllexport
#define DECLSPEC_DLLMAIN
#else
typedef HINSTANCE HINST_ARG;
#define DECLSPEC_DLLMAIN __declspec(dllexport)
#endif

extern "C" DECLSPEC_DLLMAIN BOOL WINAPI DllMain(HINST_ARG hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if ( dwReason == DLL_PROCESS_ATTACH )
		g_dllhandle = (HINSTANCE)hInstance;
	return TRUE;
}
typedef void * NULL_ONLY;


#ifdef STRICT
#define MYWNDPROC WNDPROC
#else
#define MYWNDPROC FARPROC
#endif

// Returns TRUE if a call was made (and the rc is in the param)
// Returns FALSE if nothing could be done (so the caller should probably
// call its default)
// NOTE: assumes thread state already acquired.
BOOL PyWndProc_Call(PyObject *obFuncOrMap, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *prc)
{
	// oldWndProc may be:
	//  NULL : Call DefWindowProc
	//  -1   : Assumed a dialog proc, and returns FALSE
	// else  : A valid WndProc to call.

	PyObject *obFunc = NULL;
	if (obFuncOrMap!=NULL) {
		if (PyDict_Check(obFuncOrMap)) {
			PyObject *key = PyInt_FromLong(uMsg);
			if (key==NULL){
				HandleError("Internal error converting Msg param of window procedure");
				return FALSE;
				}
			obFunc = PyDict_GetItem(obFuncOrMap, key);
			Py_DECREF(key);
		} else {
			obFunc = obFuncOrMap;
		}
	}
	if (obFunc==NULL)
		return FALSE;

	// We are dispatching to Python...
	PyObject *args = Py_BuildValue("NlNN", PyWinLong_FromHANDLE(hWnd), uMsg, 
		PyWinObject_FromPARAM(wParam), PyWinObject_FromPARAM(lParam));
	if (args==NULL){
		HandleError("Error building argument tuple for python callback");
		return FALSE;
		}
	PyObject *ret = PyObject_CallObject(obFunc, args);
	Py_DECREF(args);
	LRESULT rc = 0;
	if (ret){
		if (!PyWinObject_AsPARAM(ret, (LPARAM *)&rc))
			HandleError("WNDPROC return value cannot be converted to LRESULT");
		Py_DECREF(ret);
		}
	else
		HandleError("Python WNDPROC handler failed");
	*prc = rc;
	return TRUE;
}

LRESULT CALLBACK PyWndProcClass(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	PyObject *obFunc = (PyObject *)GetClassLongPtr( hWnd, 0);
	LRESULT rc = 0;
	CEnterLeavePython _celp;
	if (!PyWndProc_Call(obFunc, hWnd, uMsg, wParam, lParam, &rc)) {
		_celp.release();
		rc = DefWindowProc(hWnd, uMsg, wParam, lParam);
	}
	return rc;
}

LRESULT CALLBACK PyDlgProcClass(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	PyObject *obFunc = (PyObject *)GetClassLongPtr( hWnd, 0);
	LRESULT rc = 0;
	CEnterLeavePython _celp;
	if (!PyWndProc_Call(obFunc, hWnd, uMsg, wParam, lParam, &rc)) {
		_celp.release();
		rc = DefDlgProc(hWnd, uMsg, wParam, lParam);
	}
	return rc;
}

LRESULT CALLBACK PyWndProcHWND(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CEnterLeavePython _celp;
	PyObject *key = PyWinLong_FromHANDLE(hWnd);
	PyObject *obInfo = PyDict_GetItem(g_HWNDMap, key);
	Py_DECREF(key);
	MYWNDPROC oldWndProc = NULL;
	PyObject *obFunc = NULL;
	if (obInfo!=NULL) { // Is one of ours!
		obFunc = PyTuple_GET_ITEM(obInfo, 0);
		PyObject *obOldWndProc = PyTuple_GET_ITEM(obInfo, 1);
		PyWinLong_AsVoidPtr(obOldWndProc, (void **)&oldWndProc);
	}
	LRESULT rc = 0;
	if (!PyWndProc_Call(obFunc, hWnd, uMsg, wParam, lParam, &rc))
		if (oldWndProc) {
			_celp.release();
			rc = CallWindowProc(oldWndProc, hWnd, uMsg, wParam, lParam);
		}

#ifdef WM_NCDESTROY
	if (uMsg==WM_NCDESTROY) {
#else // CE doesnt have this message!
	if (uMsg==WM_DESTROY) {
#endif
		_celp.acquire(); // in case we released above - safe if already acquired.
		PyObject *key = PyWinLong_FromHANDLE(hWnd);
		if (PyDict_DelItem(g_HWNDMap, key) != 0)
			PyErr_Clear();
		Py_DECREF(key);
	}
	return rc;
}

INT_PTR CALLBACK PyDlgProcHDLG(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	BOOL rc = FALSE;
	CEnterLeavePython _celp;
	if (uMsg==WM_INITDIALOG) {
		// The lparam is our PyObject.
		// Put our HWND in the map.
		PyObject *obTuple = (PyObject *)lParam;
		PyObject *obWndProc = PyTuple_GET_ITEM(obTuple, 0);
		// Replace the lParam with the one the user specified.
		lParam = 0;
		if (PyTuple_GET_ITEM(obTuple, 1) != Py_None)
			PyWinObject_AsPARAM( PyTuple_GET_ITEM(obTuple, 1), &lParam );

		PyObject *key = PyWinLong_FromHANDLE(hWnd);
		PyDict_SetItem(g_DLGMap, key, obWndProc);
		Py_DECREF(key);
		// obWndProc has no reference.
		rc = TRUE;
	} else if(uMsg == WM_ACTIVATE) {	// see MS TID Q71450 and PumpMessages
		if(0 == wParam)
			hDialogCurrent = NULL;
		else
			hDialogCurrent = hWnd;
	}
	// If our HWND is in the map, then call it.
	PyObject *obFunc = NULL;
	PyObject *key = PyWinLong_FromHANDLE(hWnd);
	obFunc = PyDict_GetItem(g_DLGMap, key);
	Py_XDECREF(key);
	if (!obFunc)
		PyErr_Clear();

	if (obFunc) {
		LRESULT lrc;
		if (PyWndProc_Call(obFunc, hWnd, uMsg, wParam, lParam, &lrc))
			rc = (BOOL)lrc;
	}

#ifdef WM_NCDESTROY
	if (uMsg==WM_NCDESTROY) {
#else // CE doesnt have this message!
	if (uMsg==WM_DESTROY) {
#endif
		PyObject *key = PyWinLong_FromHANDLE(hWnd);

		if (g_DLGMap != NULL)
			if (PyDict_DelItem(g_DLGMap, key) != 0)
				PyErr_Clear();
		Py_DECREF(key);
	}
	return rc;
}

#include "structmember.h"

// Support for a WNDCLASS object.
class PyWNDCLASS : public PyObject
{
public:
	WNDCLASS *GetWC() {return &m_WNDCLASS;}

	PyWNDCLASS(void);
	~PyWNDCLASS();

	/* Python support */
	static PyObject *meth_SetDialogProc(PyObject *self, PyObject *args);

	static void deallocFunc(PyObject *ob);

	static PyObject *getattro(PyObject *self, PyObject *obname);
	static int setattro(PyObject *self, PyObject *obname, PyObject *v);
	static struct PyMemberDef members[];
	static struct PyMethodDef methods[];
	static PyObject *PySetDialogProc(PyObject *self, PyObject *args);
	WNDCLASS m_WNDCLASS;
	PyObject *m_obMenuName, *m_obClassName, *m_obWndProc;
};
#define PyWNDCLASS_Check(ob)	((ob)->ob_type == &PyWNDCLASSType)

// @object PyWNDCLASS|A Python object, representing an WNDCLASS structure
// @comm Typically you create a PyWNDCLASS object, and set its properties.
// The object can then be passed to any function which takes an WNDCLASS object
PyTypeObject PyWNDCLASSType =
{
	PYWIN_OBJECT_HEAD
	"PyWNDCLASS",
	sizeof(PyWNDCLASS),
	0,
	PyWNDCLASS::deallocFunc,		/* tp_dealloc */
	0,						/* tp_print */
	0,						/* tp_getattr */
	0,						/* tp_setattr */
	0,						/* tp_compare */
	0,						/* tp_repr */
	0,						/* tp_as_number */
	0,						/* tp_as_sequence */
	0,						/* tp_as_mapping */
	0,						/* tp_hash */
	0,						/* tp_call */
	0,						/* tp_str */
	PyWNDCLASS::getattro,	/* tp_getattro */
	PyWNDCLASS::setattro,	/* tp_setattro */
	0,						/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,		/* tp_flags */
	0,						/* tp_doc */
	0,						/* tp_traverse */
	0,						/* tp_clear */
	0,						/* tp_richcompare */
	0,						/* tp_weaklistoffset */
	0,						/* tp_iter */
	0,						/* tp_iternext */
	PyWNDCLASS::methods,	/* tp_methods */
	PyWNDCLASS::members,	/* tp_members */
	0,						/* tp_getset */
	0,						/* tp_base */
	0,						/* tp_dict */
	0,						/* tp_descr_get */
	0,						/* tp_descr_set */
	0,						/* tp_dictoffset */
	0,						/* tp_init */
	0,						/* tp_alloc */
	0,						/* tp_new */
};

#define OFF(e) offsetof(PyWNDCLASS, e)

/*static*/ struct PyMemberDef PyWNDCLASS::members[] = {
	{"style",            T_INT,  OFF(m_WNDCLASS.style)}, // @prop integer|style|
//	{"cbClsExtra",       T_INT,  OFF(m_WNDCLASS.cbClsExtra)}, // @prop integer|cbClsExtra|
	{"cbWndExtra",       T_INT,  OFF(m_WNDCLASS.cbWndExtra)}, // @prop integer|cbWndExtra|
	{NULL}

    // ack - these are also handled now explicitly, as T_LONGLONG is too 
    // stupid to handle ints :(
	// @prop integer|hInstance|
	// @prop integer|hIcon|
	// @prop integer|hCursor|
	// @prop integer|hbrBackground|
	// These 3 handled manually in PyWNDCLASS::getattro/setattro.  The pymeth below is used as an
	// end tag, so these props will be lost if below it
	// @prop string/<o PyUnicode>|lpszMenuName|
	// @prop string/<o PyUnicode>|lpszClassName|
	// @prop function|lpfnWndProc|

};

PyObject *PyWNDCLASS::PySetDialogProc(PyObject *self, PyObject *args)
{
	if (!PyArg_ParseTuple(args, ":SetDialogProc"))
		return NULL;
	PyWNDCLASS *pW = (PyWNDCLASS *)self;
	pW->m_WNDCLASS.lpfnWndProc = (WNDPROC)PyDlgProcClass;
	Py_INCREF(Py_None);
	return Py_None;
}

struct PyMethodDef PyWNDCLASS::methods[] = {
	{"SetDialogProc",    PyWNDCLASS::PySetDialogProc, 1}, 	// @pymeth SetDialogProc|Sets the WNDCLASS to be for a dialog box.
	// @pymethod |PyWNDCLASS|SetDialogProc|Sets the WNDCLASS to be for a dialog box
	{NULL}
};


PyWNDCLASS::PyWNDCLASS()
{
	ob_type = &PyWNDCLASSType;
	_Py_NewReference(this);
	memset(&m_WNDCLASS, 0, sizeof(m_WNDCLASS));
	m_WNDCLASS.cbClsExtra = sizeof(PyObject *);
	m_WNDCLASS.lpfnWndProc = PyWndProcClass;
	m_obMenuName = m_obClassName = m_obWndProc = NULL;
}

PyWNDCLASS::~PyWNDCLASS(void)
{
	Py_XDECREF(m_obMenuName);
	Py_XDECREF(m_obClassName);
	Py_XDECREF(m_obWndProc);
}

PyObject *PyWNDCLASS::getattro(PyObject *self, PyObject *obname)
{
	char *name=PYWIN_ATTR_CONVERT(obname);
	if (name==NULL)
		return NULL;
	PyWNDCLASS *pW = (PyWNDCLASS *)self;
	if (strcmp("lpszMenuName", name)==0) {
		PyObject *ret = pW->m_obMenuName ? pW->m_obMenuName : Py_None;
		Py_INCREF(ret);
		return ret;
	}
	if (strcmp("lpszClassName", name)==0) {
		PyObject *ret = pW->m_obClassName ? pW->m_obClassName : Py_None;
		Py_INCREF(ret);
		return ret;
	}
	if (strcmp("lpfnWndProc", name)==0) {
		PyObject *ret = pW->m_obWndProc ? pW->m_obWndProc : Py_None;
		Py_INCREF(ret);
		return ret;
	}
	if (strcmp("hInstance", name)==0)
		return PyWinLong_FromVoidPtr(pW->m_WNDCLASS.hInstance);

	if (strcmp("hIcon", name)==0)
		return PyWinLong_FromVoidPtr(pW->m_WNDCLASS.hIcon);

	if (strcmp("hCursor", name)==0)
		return PyWinLong_FromVoidPtr(pW->m_WNDCLASS.hCursor);

	if (strcmp("hbrBackground", name)==0)
		return PyWinLong_FromVoidPtr(pW->m_WNDCLASS.hbrBackground);

	return PyObject_GenericGetAttr(self, obname);
}

int SetTCHAR(PyObject *v, PyObject **m, LPCTSTR *ret)
{
#ifdef UNICODE
	if (!PyUnicode_Check(v)) {
		PyErr_SetString(PyExc_TypeError, "Object must be a Unicode");
		return -1;
	}
	Py_XDECREF(*m);
	*m = v;
	Py_INCREF(v);
	*ret = PyUnicode_AsUnicode(v);
	return 0;
#else
	if (!PyString_Check(v)) {
		PyErr_SetString(PyExc_TypeError, "Object must be a string");
		return -1;
	}
	Py_XDECREF(*m);
	*m = v;
	Py_INCREF(v);
	*ret = PyString_AsString(v);
	return 0;
#endif
}

int PyWNDCLASS::setattro(PyObject *self, PyObject *obname, PyObject *v)
{
	if (v == NULL) {
		PyErr_SetString(PyExc_AttributeError, "can't delete WNDCLASS attributes");
		return -1;
	}
	char *name=PYWIN_ATTR_CONVERT(obname);
	if (name==NULL)
		return -1;
	PyWNDCLASS *pW = (PyWNDCLASS *)self;
	if (strcmp("lpszMenuName", name)==0) {
		return SetTCHAR(v, &pW->m_obMenuName, &pW->m_WNDCLASS.lpszMenuName);
	}
	if (strcmp("lpszClassName", name)==0) {
		return SetTCHAR(v, &pW->m_obClassName, &pW->m_WNDCLASS.lpszClassName);
	}
	if (strcmp("lpfnWndProc", name)==0) {
		if (!PyCallable_Check(v) && !PyDict_Check(v)) {
			PyErr_SetString(PyExc_TypeError, "lpfnWndProc must be callable, or a dictionary");
			return -1;
		}
		Py_XDECREF(pW->m_obWndProc);
		pW->m_obWndProc = v;
		Py_INCREF(v);
		return 0;
	}
	if (strcmp("hInstance", name)==0)
		return PyWinLong_AsVoidPtr(v, (void **)&pW->m_WNDCLASS.hInstance) ? 0 : -1;

	if (strcmp("hIcon", name)==0)
		return PyWinLong_AsVoidPtr(v, (void **)&pW->m_WNDCLASS.hIcon) ? 0 : -1;

	if (strcmp("hCursor", name)==0)
		return PyWinLong_AsVoidPtr(v, (void **)&pW->m_WNDCLASS.hCursor) ? 0 : -1;

	if (strcmp("hbrBackground", name)==0)
		return PyWinLong_AsVoidPtr(v, (void **)&pW->m_WNDCLASS.hbrBackground) ? 0 : -1;

	return PyObject_GenericSetAttr(self, obname, v);
}

/*static*/ void PyWNDCLASS::deallocFunc(PyObject *ob)
{
	delete (PyWNDCLASS *)ob;
}

static PyObject *MakeWNDCLASS(PyObject *self, PyObject *args)
{
	if (!PyArg_ParseTuple(args, ""))
		return NULL;
	return new PyWNDCLASS();
}


// Support for a BITMAP object.
class PyBITMAP : public PyObject
{
public:
	BITMAP *GetBM() {return &m_BITMAP;}
	PyBITMAP(void);
	PyBITMAP(const BITMAP *pBM);
	~PyBITMAP();

	/* Python support */
	static void deallocFunc(PyObject *ob);
	static PyObject *getattro(PyObject *self, PyObject *obname);
	static int setattro(PyObject *self, PyObject *obname, PyObject *v);
	static struct PyMemberDef members[];
	BITMAP m_BITMAP;
};
#define PyBITMAP_Check(ob)	((ob)->ob_type == &PyBITMAPType)

// @object PyBITMAP|A Python object, representing an PyBITMAP structure
// @comm Typically you get one of these from GetObject.  Note that currently 
// the bitmap bits are not exposed via this type - but the value of the 
// pointer is.  You can use the struct and win32gui functions to unpack 
// these bits manually if you really need them.
// Note that you are still responsible for the life of the win32 bitmap object.
// The object can then be passed to any function which takes an BITMAP object
PyTypeObject PyBITMAPType =
{
	PYWIN_OBJECT_HEAD
	"PyBITMAP",
	sizeof(PyBITMAP),
	0,
	PyBITMAP::deallocFunc,	/* tp_dealloc */
	0,						/* tp_print */
	0,						/* tp_getattr */
	0,						/* tp_setattr */
	0,						/* tp_compare */
	0,						/* tp_repr */
	0,						/* tp_as_number */
	0,						/* tp_as_sequence */
	0,						/* tp_as_mapping */
	0,						/* tp_hash */
	0,						/* tp_call */
	0,						/* tp_str */
	PyBITMAP::getattro,		/* tp_getattro */
	PyBITMAP::setattro,		/* tp_setattro */
	0,						/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,		/* tp_flags */
	0,						/* tp_doc */
	0,						/* tp_traverse */
	0,						/* tp_clear */
	0,						/* tp_richcompare */
	0,						/* tp_weaklistoffset */
	0,						/* tp_iter */
	0,						/* tp_iternext */
	0,						/* tp_methods */
	PyBITMAP::members,		/* tp_members */
	0,						/* tp_getset */
	0,						/* tp_base */
	0,						/* tp_dict */
	0,						/* tp_descr_get */
	0,						/* tp_descr_set */
	0,						/* tp_dictoffset */
	0,						/* tp_init */
	0,						/* tp_alloc */
	0,						/* tp_new */
};

#undef OFF
#define OFF(e) offsetof(PyBITMAP, e)

/*static*/ struct PyMemberDef PyBITMAP::members[] = {
	{"bmType",           T_LONG,  OFF(m_BITMAP.bmType)}, // @prop integer|bmType|
	{"bmWidth",           T_LONG,  OFF(m_BITMAP.bmWidth)}, // @prop integer|bmWidth|
	{"bmHeight",           T_LONG,  OFF(m_BITMAP.bmHeight)}, // @prop integer|bmHeight|
	{"bmWidthBytes",     T_LONG,  OFF(m_BITMAP.bmWidthBytes)}, // @prop integer|bmWidthBytes|
	{"bmPlanes",           T_SHORT,  OFF(m_BITMAP.bmPlanes)}, // @prop integer|bmPlanes|
	{"bmBitsPixel",           T_SHORT,  OFF(m_BITMAP.bmBitsPixel)}, // @prop integer||
	{NULL}
};


PyBITMAP::PyBITMAP()
{
	ob_type = &PyBITMAPType;
	_Py_NewReference(this);
	memset(&m_BITMAP, 0, sizeof(m_BITMAP));
}

PyBITMAP::PyBITMAP(const BITMAP *pBM)
{
	ob_type = &PyBITMAPType;
	_Py_NewReference(this);
	memcpy(&m_BITMAP, pBM, sizeof(m_BITMAP));
}

PyBITMAP::~PyBITMAP(void)
{
}

PyObject *PyBITMAP::getattro(PyObject *self, PyObject *obname)
{
	char *name=PYWIN_ATTR_CONVERT(obname);
	if (name==NULL)
		return NULL;
	PyBITMAP *pB = (PyBITMAP *)self;
	if (strcmp("bmBits", name)==0) {
		return PyWinLong_FromVoidPtr(pB->m_BITMAP.bmBits);
	}
	return PyObject_GenericGetAttr(self, obname);
}

int PyBITMAP::setattro(PyObject *self, PyObject *obname, PyObject *v)
{
	if (v == NULL) {
		PyErr_SetString(PyExc_AttributeError, "can't delete BITMAP attributes");
		return -1;
	}
	char *name=PYWIN_ATTR_CONVERT(obname);
	if (name==NULL)
		return -1;
	if (strcmp("bmBits", name)==0) {
		PyBITMAP *pB = (PyBITMAP *)self;
		if (!PyWinLong_AsVoidPtr(v, &pB->m_BITMAP.bmBits))
			return -1;
		return 0;
	}
	return PyObject_GenericSetAttr(self, obname, v);
}

/*static*/ void PyBITMAP::deallocFunc(PyObject *ob)
{
	delete (PyBITMAP *)ob;
}

// Support for a LOGFONT object.
class PyLOGFONT : public PyObject
{
public:
	LOGFONT *GetLF() {return &m_LOGFONT;}

	PyLOGFONT(void);
	PyLOGFONT(const LOGFONT *pLF);
	~PyLOGFONT();

	/* Python support */

	static void deallocFunc(PyObject *ob);

	static PyObject *getattro(PyObject *self, PyObject *obname);
	static int setattro(PyObject *self, PyObject *obname, PyObject *v);
	static struct PyMemberDef members[];
	LOGFONT m_LOGFONT;
};
#define PyLOGFONT_Check(ob)	((ob)->ob_type == &PyLOGFONTType)

// @object PyLOGFONT|A Python object, representing an PyLOGFONT structure
// @comm Typically you create a PyLOGFONT object, and set its properties.
// The object can then be passed to any function which takes an LOGFONT object
PyTypeObject PyLOGFONTType =
{
	PYWIN_OBJECT_HEAD
	"PyLOGFONT",
	sizeof(PyLOGFONT),
	0,
	PyLOGFONT::deallocFunc,	/* tp_dealloc */
	0,						/* tp_print */
	0,						/* tp_getattr */
	0,						/* tp_setattr */
	0,						/* tp_compare */
	0,						/* tp_repr */
	0,						/* tp_as_number */
	0,						/* tp_as_sequence */
	0,						/* tp_as_mapping */
	0,						/* tp_hash */
	0,						/* tp_call */
	0,						/* tp_str */
	PyLOGFONT::getattro,	/* tp_getattro */
	PyLOGFONT::setattro,	/* tp_setattro */
	0,						/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,		/* tp_flags */
	0,						/* tp_doc */
	0,						/* tp_traverse */
	0,						/* tp_clear */
	0,						/* tp_richcompare */
	0,						/* tp_weaklistoffset */
	0,						/* tp_iter */
	0,						/* tp_iternext */
	0,						/* tp_methods */
	PyLOGFONT::members,		/* tp_members */
	0,						/* tp_getset */
	0,						/* tp_base */
	0,						/* tp_dict */
	0,						/* tp_descr_get */
	0,						/* tp_descr_set */
	0,						/* tp_dictoffset */
	0,						/* tp_init */
	0,						/* tp_alloc */
	0,						/* tp_new */
};
#undef OFF
#define OFF(e) offsetof(PyLOGFONT, e)

/*static*/ struct PyMemberDef PyLOGFONT::members[] = {
	{"lfHeight",           T_LONG,  OFF(m_LOGFONT.lfHeight)}, // @prop integer|lfHeight|
	{"lfWidth",            T_LONG,  OFF(m_LOGFONT.lfWidth)}, // @prop integer|lfWidth|
	{"lfEscapement",       T_LONG,  OFF(m_LOGFONT.lfEscapement)}, // @prop integer|lfEscapement|
	{"lfOrientation",      T_LONG,  OFF(m_LOGFONT.lfOrientation)}, // @prop integer|lfOrientation|
	{"lfWeight",           T_LONG,  OFF(m_LOGFONT.lfWeight)}, // @prop integer|lfWeight|
	{"lfItalic",           T_BYTE,  OFF(m_LOGFONT.lfItalic)}, // @prop integer|lfItalic|
	{"lfUnderline",        T_BYTE,  OFF(m_LOGFONT.lfUnderline)}, // @prop integer|lfUnderline|
	{"lfStrikeOut",        T_BYTE,  OFF(m_LOGFONT.lfStrikeOut)}, // @prop integer|lfStrikeOut|
	{"lfCharSet",          T_BYTE,  OFF(m_LOGFONT.lfCharSet)}, // @prop integer|lfCharSet|
	{"lfOutPrecision",     T_BYTE,  OFF(m_LOGFONT.lfOutPrecision)}, // @prop integer|lfOutPrecision|
	{"lfClipPrecision",    T_BYTE,  OFF(m_LOGFONT.lfClipPrecision)}, // @prop integer|lfClipPrecision|
	{"lfQuality",          T_BYTE,  OFF(m_LOGFONT.lfQuality)}, // @prop integer|lfQuality|
	{"lfPitchAndFamily",   T_BYTE,  OFF(m_LOGFONT.lfPitchAndFamily)}, // @prop integer|lfPitchAndFamily|
	{"lfFaceName",         T_LONG, 0}, // @prop string|lfFaceName|Name of the typeface, at most 31 characters
	{NULL}	/* Sentinel */
};


PyLOGFONT::PyLOGFONT()
{
	ob_type = &PyLOGFONTType;
	_Py_NewReference(this);
	memset(&m_LOGFONT, 0, sizeof(m_LOGFONT));
}

PyLOGFONT::PyLOGFONT(const LOGFONT *pLF)
{
	ob_type = &PyLOGFONTType;
	_Py_NewReference(this);
	memcpy(&m_LOGFONT, pLF, sizeof(m_LOGFONT));
}

PyLOGFONT::~PyLOGFONT(void)
{
}

PyObject *PyLOGFONT::getattro(PyObject *self, PyObject *obname)
{
	char *name=PYWIN_ATTR_CONVERT(obname);
	if (name==NULL)
		return NULL;
	PyLOGFONT *pL = (PyLOGFONT *)self;
	if (strcmp("lfFaceName", name)==0) {
		return PyWinObject_FromTCHAR(pL->m_LOGFONT.lfFaceName);
	}
	return PyObject_GenericGetAttr(self, obname);
}

int PyLOGFONT::setattro(PyObject *self, PyObject *obname, PyObject *v)
{
	if (v == NULL) {
		PyErr_SetString(PyExc_AttributeError, "can't delete LOGFONT attributes");
		return -1;
	}
	char *name=PYWIN_ATTR_CONVERT(obname);
	if (name==NULL)
		return -1;
	if (strcmp("lfFaceName", name)==0) {
		PyLOGFONT *pL = (PyLOGFONT *)self;
		TCHAR *face;
		DWORD facesize;
		if (!PyWinObject_AsTCHAR(v, &face, FALSE, &facesize))
			return -1;
		if (facesize >= LF_FACESIZE){	// LF_FACESIZE includes the trailing NULL
			PyErr_Format(PyExc_ValueError, "lfFaceName must be less than %d characters", LF_FACESIZE);
			PyWinObject_FreeTCHAR(face);
			return -1;
			}
		_tcsncpy( pL->m_LOGFONT.lfFaceName, face, LF_FACESIZE );
		PyWinObject_FreeTCHAR(face);
		return 0;
	}
	return PyObject_GenericSetAttr(self, obname, v);
}

/*static*/ void PyLOGFONT::deallocFunc(PyObject *ob)
{
	delete (PyLOGFONT *)ob;
}

static PyObject *MakeLOGFONT(PyObject *self, PyObject *args)
{
	if (!PyArg_ParseTuple(args, ""))
		return NULL;
	return new PyLOGFONT();
}

BOOL PyWinObject_AsLOGFONT(PyObject *ob, LOGFONT *plf)
{
	if (!PyLOGFONT_Check(ob)){
		PyErr_SetString(PyExc_TypeError, "Object must be a PyLOGFONT");
		return FALSE;
		}
	*plf=*((PyLOGFONT *)ob)->GetLF();
	return TRUE;
}

BOOL CALLBACK EnumFontFamProc(const LOGFONT FAR *lpelf, const TEXTMETRIC *lpntm, DWORD FontType, LPARAM lParam)
{
	PyObject *obFunc;
	PyObject *obExtra;
	if (!PyArg_ParseTuple((PyObject *)lParam, "OO", &obFunc, &obExtra))
		return 0;
	PyObject *FontArg = new PyLOGFONT(lpelf);
	PyObject *params = Py_BuildValue("OOiO", FontArg, Py_None, FontType, obExtra);
	Py_XDECREF(FontArg);

	long iret = 0;
	PyObject *ret = PyObject_CallObject(obFunc, params);
	Py_XDECREF(params);
	if (ret) {
		iret = PyInt_AsLong(ret);
		Py_DECREF(ret);
	}
	return iret;
}

// @pyswig int|EnumFontFamilies|Enumerates the available font families.
static PyObject *PyEnumFontFamilies(PyObject *self, PyObject *args)
{
	PyObject *obFamily;
	PyObject *obProc, *obdc;
	PyObject *obExtra = Py_None;
	HDC hdc;
	// @pyparm <o PyHANDLE>|hdc||Handle to a device context for which to enumerate available fonts
	// @pyparm string/<o PyUnicode>|Family||Family of fonts to enumerate. If none, first member of each font family will be returned.
	// @pyparm function|EnumFontFamProc||The Python function called with each font family. This function is called with 4 arguments.
	// @pyparm object|Param||An arbitrary object to be passed to the callback function
	// @comm The parameters that the callback function will receive are as follows:<nl>
	//	<o PyLOGFONT> - contains the font parameters<nl>
	//	None - Placeholder for a TEXTMETRIC structure, not supported yet<nl>
	//	int - Font type, combination of DEVICE_FONTTYPE, RASTER_FONTTYPE, TRUETYPE_FONTTYPE<nl>
	//	object - The Param originally passed in to EnumFontFamilies

	if (!PyArg_ParseTuple(args, "OOO|O", &obdc, &obFamily, &obProc, &obExtra))
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	if (!PyCallable_Check(obProc)) {
		PyErr_SetString(PyExc_TypeError, "The 3rd argument must be callable");
		return NULL;
	}
	TCHAR *szFamily;
	if (!PyWinObject_AsTCHAR(obFamily, &szFamily, TRUE))
		return NULL;
	PyObject *lparam = Py_BuildValue("OO", obProc, obExtra);
	int rc = EnumFontFamilies(hdc, szFamily, EnumFontFamProc, (LPARAM)lparam);
	Py_XDECREF(lparam);
	PyWinObject_FreeTCHAR(szFamily);
	return PyInt_FromLong(rc);

}

// @pyswig |set_logger|Sets a logger object for exceptions and error information
// @comm Once a logger has been set for the module, unhandled exceptions, such as
// from a window's WNDPROC, will be written (via logger.exception()) to the log
// instead of to stderr.
// <nl>Note that using this with the Python 2.3 logging package will prevent the
// traceback from being written to the log.  However, it is possible to use
// the Python 2.4 logging package directly with Python 2.3
PyObject *set_logger(PyObject *self, PyObject *args)
{
	Py_XDECREF(logger);
	logger = NULL;
	// @pyparm object|logger||A logger object, generally from the standard logger package.
	if (!PyArg_ParseTuple(args, "O:set_logger", &logger))
		return NULL;
	if (logger==Py_None)
		logger = NULL;
	Py_XINCREF(logger);
	Py_INCREF(Py_None);
	return Py_None;
}

// @pyswig object|GetObject|Returns a struct containing the parameters used to create a GDI object
static PyObject *PyGetObject(PyObject *self, PyObject *args)
{
	HGDIOBJ hob;
	PyObject *ob;
	// @pyparm <o PyHANDLE>|handle||Handle to the object.
	if (!PyArg_ParseTuple(args, "O", &ob))
		return NULL;
	if (!PyWinObject_AsHANDLE(ob, &hob))
		return NULL;
	DWORD typ = GetObjectType(hob);
	if (typ==0)
		return PyWin_SetAPIError("GetObjectType");
	// @comm The result depends on the type of the handle.
	switch (typ) {
		// @flagh Object type as determined by <om win32gui.GetObjectType>|Returned object
		// @flag OBJ_FONT|<o PyLOGFONT>
		case OBJ_FONT: {
			LOGFONT lf;
			if (GetObject(hob, sizeof(LOGFONT), &lf)==0)
				return PyWin_SetAPIError("GetObject");
			return new PyLOGFONT(&lf);
		}
		// @flag OBJ_BITMAP|<o PyBITMAP>
		case OBJ_BITMAP: {
			BITMAP bm;
			if (GetObject(hob, sizeof(BITMAP), &bm)==0)
				return PyWin_SetAPIError("GetObject");
			return new PyBITMAP(&bm);
		}
		// @flag OBJ_PEN|Dict representing a LOGPEN struct
		case OBJ_PEN:{
			LOGPEN lp;
			if (GetObject(hob, sizeof(LOGPEN), &lp)==0)
				return PyWin_SetAPIError("GetObject");
			return Py_BuildValue("{s:I, s:l, s:k}",
				"Style", lp.lopnStyle,
				"Width", lp.lopnWidth.x,	// Docs say y member is not used, so ignore it
				"Color", lp.lopnColor);
		}
		default:
			PyErr_Format(PyExc_ValueError, "This GDI object type is not supported: %d", typ);
			return NULL;
	}
}

// @pyswig int|GetObjectType|Returns the type (OBJ_* constant) of a GDI handle
static PyObject *PyGetObjectType(PyObject *self, PyObject *args)
{
	HANDLE h;
	DWORD t;
	PyObject *ob;
	// @pyparm <o PyHANDLE>|h||A handle to a GDI object
	if (!PyArg_ParseTuple(args, "O:GetObjectType", &ob))
		return NULL;
	if (!PyWinObject_AsHANDLE(ob, &h))
		return NULL;
	t=GetObjectType(h);
	if (t==0)
		return PyWin_SetAPIError("GetObjectType");
	return PyLong_FromUnsignedLong(t);
}

// NOTE: PyMakeBuffer() is a dumb name for lots of reasons, including that
// it implies the memory is "new" and "owned" by the caller.  The "natural"
// order of the params is wrong too.  So it's deprecated!

static PyObject *PyMakeBuffer(PyObject *self, PyObject *args)
{
	PyErr_Warn(PyExc_PendingDeprecationWarning, "PyMakeBuffer is deprecated; use PyGetMemory instead");
	size_t len;
	void *addr=NULL;
#ifdef _WIN64
	static char *input_fmt="L|L:PyMakeBuffer";
#else
	static char *input_fmt="l|l:PyMakeBuffer";
#endif
	if (!PyArg_ParseTuple(args, input_fmt, &len,&addr))
		return NULL;

	if(NULL == addr) 
		return PyBuffer_New(len);
	else {
		if (IsBadReadPtr(addr, len)) {
			PyErr_SetString(PyExc_ValueError,
			                "The value is not a valid address for reading");
			return NULL;
		}
		return PyBuffer_FromMemory(addr, len);
	}
}

// @pyswig object|PyGetMemory|Returns a buffer object from and address and length
static PyObject *PyGetMemory(PyObject *self, PyObject *args)
{
	void *addr;
	size_t len;
#ifdef _WIN64
	static char *input_fmt="LL:PyGetMemory";
#else
	static char *input_fmt="ll:PyGetMemory";
#endif
	// @pyparm int|addr||Address of the memory to reference.
	// @pyparm int|len||Number of bytes to return.
	// @comm If zero is passed a ValueError will be raised.
	if (!PyArg_ParseTuple(args, input_fmt, &addr, &len))
		return NULL;
	if (IsBadReadPtr(addr, len)) {
		PyErr_SetString(PyExc_ValueError,
		                "The value is not a valid address for reading");
		return NULL;
	}
	return PyBuffer_FromMemory(addr, len);
}

// @pyswig string|PyGetString|Returns a string from an address.
// @rdesc If win32gui.UNICODE is True, this will return a unicode object.
static PyObject *PyGetString(PyObject *self, PyObject *args)
{
	TCHAR *addr = 0;
	size_t len = -1;
#ifdef _WIN64
	static char *input_fmt="L|L:PyGetString";
#else
	static char *input_fmt="l|l:PyGetString";
#endif
	// @pyparm int|addr||Address of the memory to reference
	// @pyparm int|len||Number of characters to read.  If not specified, the
	// string must be NULL terminated.
	if (!PyArg_ParseTuple(args, input_fmt, &addr, &len))
		return NULL;
	if (addr==NULL){
		PyErr_SetString(PyExc_ValueError, "PyGetString: NULL is not valid pointer");
		return NULL;
	}
	if (len != -1){
		if (IsBadReadPtr(addr, len)) {
			PyErr_SetString(PyExc_ValueError, "The value is not a valid address for reading");
			return NULL;
			}
		return PyWinObject_FromTCHAR(addr, len);
	}
	// This should probably be in a __try just in case.
	if (IsBadStringPtr(addr, (DWORD_PTR)-1)) {
		PyErr_SetString(PyExc_ValueError, "The value is not a valid null-terminated string");
		return NULL;
	}
	return PyWinObject_FromTCHAR(addr);
}

// @pyswig object|PySetString|Copies a string to an address (null terminated).
// You almost certainly should use <om win32gui.PySetMemory> instead.
static PyObject *PySetString(PyObject *self, PyObject *args)
{
	TCHAR *addr = 0;
	PyObject *str;
	TCHAR *source;
	size_t maxLen = 0;
#ifdef _WIN64
	static char *input_fmt="LO|L:PySetString";
#else
	static char *input_fmt="lO|l:PySetString";
#endif

	// @pyparm int|addr||Address of the memory to reference 
	// @pyparm str|String||The string to copy
	// @pyparm int|maxLen||Maximum number of chars to copy (optional)
	if (!PyArg_ParseTuple(args, input_fmt, &addr,&str,&maxLen))
		return NULL;

	if (!PyWinObject_AsTCHAR(str, &source)) {
		PyErr_SetString(PyExc_TypeError,"String must by string type");
		return NULL;
	}

    if (!maxLen)
        maxLen = _tcslen(source)+1;

    if (IsBadWritePtr(addr, maxLen)) {
        PyErr_SetString(PyExc_ValueError,
                        "The value is not a valid address for writing");
        return NULL;
    }
    _tcsncpy( addr, source, maxLen);
	Py_INCREF(Py_None);
	return Py_None;
}

// @pyswig object|PySetMemory|Copies bytes to an address.
static PyObject *PySetMemory(PyObject *self, PyObject *args)
{
	void *addr;
	const void *src;
	PyObject *obaddr, *obsrc;
	Py_ssize_t nbytes;

	// @pyparm int|addr||Address of the memory to reference 
	// @pyparm string or buffer|String||The string to copy
	if (!PyArg_ParseTuple(args, "OO:PySetMemory", &obaddr, &obsrc))
		return NULL;
	if (!PyWinLong_AsVoidPtr(obaddr, &addr))
		return NULL;
	if (PyObject_AsReadBuffer(obsrc, &src, &nbytes)==-1)
		return NULL;
	if (IsBadWritePtr(addr, nbytes)) {
		PyErr_SetString(PyExc_ValueError,
		                "The value is not a valid address for writing");
		return NULL;
	}
	memcpy(addr, src, nbytes);
	Py_INCREF(Py_None);
	return Py_None;
}

// @pyswig object|PyGetArraySignedLong|Returns a signed long from an array object at specified index
static PyObject *PyGetArraySignedLong(PyObject *self, PyObject *args)
{
	PyObject *ob;
	int offset;
	Py_ssize_t maxlen;

	// @pyparm array|array||array object to use
	// @pyparm int|index||index of offset
	if (!PyArg_ParseTuple(args, "Oi:PyGetArraySignedLong",&ob,&offset))
		return NULL;
	long *l;
	if (PyObject_AsReadBuffer(ob, (const void **) &l, &maxlen)==-1)
		return NULL;

	if(offset * sizeof(*l) > maxlen) {
		PyErr_SetString(PyExc_ValueError,"array index out of bounds");
		return NULL;
		}
	return PyInt_FromLong(l[offset]);
}

// @pyswig object|PyGetBufferAddressAndLen|Returns a buffer object address and len
static PyObject *PyGetBufferAddressAndLen(PyObject *self, PyObject *args)
{
	PyObject *ob;
	const void *addr;
	Py_ssize_t len = 0;

	// @pyparm buffer|obj||the buffer object
	if (!PyArg_ParseTuple(args, "O:PyGetBufferAddressAndLen", &ob))
		return NULL;
	if (PyObject_AsReadBuffer(ob, &addr, &len) == -1)
		return NULL;
	return Py_BuildValue("NN", PyWinLong_FromVoidPtr(addr), PyInt_FromSsize_t(len));
}
typedef TCHAR * STRING_OR_ATOM_CW;
typedef TCHAR * RESOURCE_ID;
typedef TCHAR * RESOURCE_ID_NULLOK;

PyObject *PyFlashWindowEx(PyObject *self, PyObject *args)
{
	PyObject *ret, *obhwnd;
	BOOL rc;
	FLASHWINFO f;
	f.cbSize = sizeof f;
	// @pyparm <o PyHANDLE>|hwnd||Handle to a window
	// @pyparm int|dwFlags||Combination of win32con.FLASHW_* flags
	// @pyparm int|uCount||Nbr of times to flash
	// @pyparm int|dwTimeout||Elapsed time between flashes, in milliseconds
	if (!PyArg_ParseTuple(args, "Oiii", &obhwnd, &f.dwFlags, &f.uCount, &f.dwTimeout))
		return NULL;
	if (!PyWinObject_AsHANDLE(obhwnd, (HANDLE *)&f.hwnd))
		return NULL;
    // not on NT
	HMODULE hmod = GetModuleHandle(_T("user32"));
    BOOL (WINAPI *pfnFW)(PFLASHWINFO) = NULL;
    if (hmod)
        pfnFW = (BOOL (WINAPI *)(PFLASHWINFO))GetProcAddress(hmod, "FlashWindowEx");
    if (pfnFW==NULL)
        return PyErr_Format(PyExc_NotImplementedError,
                            "FlashWindowsEx is not supported on this version of windows");
	Py_BEGIN_ALLOW_THREADS
	rc = (*pfnFW)(&f);
	Py_END_ALLOW_THREADS
	ret = rc ? Py_True : Py_False;
	Py_INCREF(ret);
	return ret;
}

static PyObject *PySetWindowLong(PyObject *self, PyObject *args)
{
	HWND hwnd;
	int index;
	PyObject *ob, *obhwnd;
	LONG_PTR oldval, newval;
	if (!PyArg_ParseTuple(args, "OiO", 
		&obhwnd,	// @pyparm <o PyHANDLE>|hwnd||The handle to the window
		&index,		// @pyparm int|index||The index of the item to set.
		&ob))		// @pyparm object|value||The value to set.
		return NULL;
	if (!PyWinObject_AsHANDLE(obhwnd, (HANDLE *)&hwnd))
		return NULL;
	switch (index) {
		// @comm If index is GWLP_WNDPROC, then the value parameter
		// must be a callable object (or a dictionary) to use as the
		// new window procedure.
		case GWLP_WNDPROC:
		{
			if (!PyCallable_Check(ob) && !PyDict_Check(ob)) {
				PyErr_SetString(PyExc_TypeError, "object must be callable or a dictionary");
				return NULL;
			}

			PyObject *key = PyWinLong_FromHANDLE(hwnd);
			PyObject *value = Py_BuildValue("ON", ob, PyWinLong_FromVoidPtr((void *)GetWindowLongPtr(hwnd, GWLP_WNDPROC)));
			PyDict_SetItem(g_HWNDMap, key, value);
			Py_DECREF(value);
			Py_DECREF(key);
			newval = (LONG_PTR)PyWndProcHWND;
			break;
		}
		default:
			if (!PyWinLong_AsVoidPtr(ob, (void **)&newval))
				return NULL;
	}
	oldval = SetWindowLongPtr(hwnd, index, newval);
	return PyWinLong_FromVoidPtr((void *)oldval);
}

static PyObject *PyCallWindowProc(PyObject *self, PyObject *args)
{
	MYWNDPROC wndproc;
	WPARAM wparam;
	LPARAM lparam;
	HWND hwnd;
	PyObject *obwndproc, *obhwnd, *obwparam, *oblparam;
	UINT msg;
	if (!PyArg_ParseTuple(args, "OOIOO",
		&obwndproc,	// @pyparm int|wndproc||The wndproc to call - this is generally the return value of SetWindowLong(GWL_WNDPROC)
		&obhwnd,	// @pyparm <o PyHANDLE>|hwnd||Handle to the window
		&msg,		// @pyparm int|msg||A window message
		&obwparam,	// @pyparm int/str|wparam||Type is dependent on the message
		&oblparam))	// @pyparm int/str|lparam||Type is dependent on the message
		return NULL;
	if (!PyWinLong_AsVoidPtr(obwndproc, (void **)&wndproc))
		return NULL;
	if (!PyWinObject_AsHANDLE(obhwnd, (HANDLE *)&hwnd))
		return NULL;
	if (!PyWinObject_AsPARAM(obwparam, &wparam))
		return NULL;
	if (!PyWinObject_AsPARAM(oblparam, (WPARAM *)&lparam))
		return NULL;
	LRESULT rc;
    Py_BEGIN_ALLOW_THREADS
	rc = CallWindowProc(wndproc, hwnd, msg, wparam, lparam);
    Py_END_ALLOW_THREADS
	return PyWinLong_FromVoidPtr((void *)rc);
}

// @pyswig int|SendMessage|Sends a message to the window.
// @pyparm int|hwnd||The handle to the Window
// @pyparm int|message||The ID of the message to post
// @pyparm int/str|wparam|None|Type depends on the message
// @pyparm int/str|lparam|None|Type depends on the message
static PyObject *PySendMessage(PyObject *self, PyObject *args)
{
	HWND hwnd;
	PyObject *obhwnd, *obwparam=Py_None, *oblparam=Py_None;
	UINT msg;
	if (!PyArg_ParseTuple(args, "Oi|OO", &obhwnd, &msg, &obwparam, &oblparam))
		return NULL;
	if (!PyWinObject_AsHANDLE(obhwnd, (HANDLE *)&hwnd))
		return NULL;
	WPARAM wparam;
	LPARAM lparam;
	if (!PyWinObject_AsPARAM(obwparam, &wparam))
		return NULL;
	if (!PyWinObject_AsPARAM(oblparam, (WPARAM *)&lparam))
		return NULL;

	LRESULT rc;
    Py_BEGIN_ALLOW_THREADS
	rc = SendMessage(hwnd, msg, wparam, lparam);
    Py_END_ALLOW_THREADS

	return PyWinLong_FromVoidPtr((void *)rc);
}

// @pyswig int,int|SendMessageTimeout|Sends a message to the window.
// @pyparm int|hwnd||The handle to the Window
// @pyparm int|message||The ID of the message to post
// @pyparm int|wparam||An integer whose value depends on the message
// @pyparm int|lparam||An integer whose value depends on the message
// @pyparm int|flags||Send options
// @pyparm int|timeout||Timeout duration in milliseconds.
static PyObject *PySendMessageTimeout(PyObject *self, PyObject *args)
{
	HWND hwnd;
	PyObject *obhwnd, *obwparam, *oblparam;
	UINT msg;
	UINT flags, timeout;
	if (!PyArg_ParseTuple(args, "OiOOii", &obhwnd, &msg, &obwparam, &oblparam, &flags, &timeout))
		return NULL;
	if (!PyWinObject_AsHANDLE(obhwnd, (HANDLE *)&hwnd))
		return NULL;
	WPARAM wparam;
	LPARAM lparam;
	if (!PyWinObject_AsPARAM(obwparam, &wparam))
		return NULL;
	if (!PyWinObject_AsPARAM(oblparam, (WPARAM *)&lparam))
		return NULL;

	LRESULT rc;
	DWORD_PTR dwresult;
	Py_BEGIN_ALLOW_THREADS
	rc = SendMessageTimeout(hwnd, msg, wparam, lparam, flags, timeout, &dwresult);
	Py_END_ALLOW_THREADS
	if (rc==0)
		return PyWin_SetAPIError("SendMessageTimeout");
	// @rdesc The result is the result of the SendMessageTimeout call, plus the last 'result' param.
	// If the timeout period expires, a pywintypes.error exception will be thrown,
	// with zero as the error code.  See the Microsoft documentation for more information.
	return Py_BuildValue("NN", PyWinLong_FromVoidPtr((void *)rc), PyWinObject_FromDWORD_PTR(dwresult));
}

struct PyEnumWindowsCallback {
	PyObject *func;
	PyObject *extra;
};

BOOL CALLBACK PyEnumWindowsProc(
  HWND hwnd,      // handle to parent window
  LPARAM lParam   // application-defined value
) {
	BOOL result = TRUE;
	PyEnumWindowsCallback *cb = (PyEnumWindowsCallback *)lParam;
	CEnterLeavePython _celp;
	PyObject *args = Py_BuildValue("(NO)", PyWinLong_FromHANDLE(hwnd), cb->extra);
	if (args == NULL)
		return FALSE;
	PyObject *ret = PyEval_CallObject(cb->func, args);
	Py_DECREF(args);
	if (ret == NULL)		
		return FALSE;
	if (ret != Py_None){
		result = PyInt_AsLong(ret);
		if (result == -1 && PyErr_Occurred())
			result = FALSE;
		}
	Py_DECREF(ret);
	return result;
}

// @pyswig |EnumWindows|Enumerates all top-level windows on the screen by passing the handle to each window, in turn, to an application-defined callback function.
static PyObject *PyEnumWindows(PyObject *self, PyObject *args)
{
	BOOL rc;
	PyObject *obFunc, *obOther;
	// @pyparm function|callback||A Python function to be used as the callback.  Function can return False to stop enumeration, or raise an exception.
	// @pyparm object|extra||Any python object - this is passed to the callback function as the second param (first is the hwnd).
	if (!PyArg_ParseTuple(args, "OO", &obFunc, &obOther))
		return NULL;
	if (!PyCallable_Check(obFunc)) {
		PyErr_SetString(PyExc_TypeError, "First param must be a callable object");
		return NULL;
	}
	PyEnumWindowsCallback cb;
	cb.func = obFunc;
	cb.extra = obOther;
    Py_BEGIN_ALLOW_THREADS
	rc = EnumWindows(PyEnumWindowsProc, (LPARAM)&cb);
    Py_END_ALLOW_THREADS
	if (!rc){
		// Callback may have raised an exception already
		if (PyErr_Occurred())
			return NULL;
		return PyWin_SetAPIError("EnumWindows");
		}
	Py_INCREF(Py_None);
	return Py_None;
}

#ifndef MS_WINCE
// @pyswig |EnumThreadWindows|Enumerates all top-level windows associated with a thread on the screen by passing the handle to each window, in turn, to an application-defined callback function. EnumThreadWindows continues until the last top-level window associated with the thread is enumerated or the callback function returns FALSE
static PyObject *PyEnumThreadWindows(PyObject *self, PyObject *args)
{
	BOOL rc;
	PyObject *obFunc, *obOther;
	DWORD dwThreadId;
	// @pyparm int|dwThreadId||The id of the thread for which the windows need to be enumerated.
	// @pyparm object|callback||A Python function to be used as the callback.
	// @pyparm object|extra||Any python object - this is passed to the callback function as the second param (first is the hwnd).
	if (!PyArg_ParseTuple(args, "lOO", &dwThreadId, &obFunc, &obOther))
		return NULL;
	if (!PyCallable_Check(obFunc)) {
		PyErr_SetString(PyExc_TypeError, "Second param must be a callable object");
		return NULL;
	}
	PyEnumWindowsCallback cb;
	cb.func = obFunc;
	cb.extra = obOther;
    Py_BEGIN_ALLOW_THREADS
	rc = EnumThreadWindows(dwThreadId, PyEnumWindowsProc, (LPARAM)&cb);
    Py_END_ALLOW_THREADS
	if (!rc)
		return PyWin_SetAPIError("EnumThreadWindows");
	Py_INCREF(Py_None);
	return Py_None;
}

// @pyswig |EnumChildWindows|Enumerates the child windows that belong to the specified parent window by passing the handle to each child window, in turn, to an application-defined callback function. EnumChildWindows continues until the last child window is enumerated or the callback function returns FALSE.
static PyObject *PyEnumChildWindows(PyObject *self, PyObject *args)
{
	BOOL rc;
	PyObject *obhwnd, *obFunc, *obOther;
	HWND hwnd;
	// @pyparm <o PyHANDLE>|hwnd||The handle to the window to enumerate.
	// @pyparm object|callback||A Python function to be used as the callback.
	// @pyparm object|extra||Any python object - this is passed to the callback function as the second param (first is the hwnd).
	if (!PyArg_ParseTuple(args, "OOO", &obhwnd, &obFunc, &obOther))
		return NULL;
	if (!PyWinObject_AsHANDLE(obhwnd, (HANDLE *)&hwnd))
		return NULL;
	if (!PyCallable_Check(obFunc)) {
		PyErr_SetString(PyExc_TypeError, "First param must be a callable object");
		return NULL;
	}
	PyEnumWindowsCallback cb;
	cb.func = obFunc;
	cb.extra = obOther;
    Py_BEGIN_ALLOW_THREADS
	rc = EnumChildWindows(hwnd, PyEnumWindowsProc, (LPARAM)&cb);
    Py_END_ALLOW_THREADS
	if (!rc)
		return PyWin_SetAPIError("EnumChildWindows");
	Py_INCREF(Py_None);
	return Py_None;
}

#endif	/* not MS_WINCE */

static PyObject *PyDialogBox(PyObject *self, PyObject *args)
{
	/// XXX - todo - add support for a dialogproc!
	HINSTANCE hinst;
	HWND hwnd;
	LPARAM param=0;
	PyObject *obResId, *obDlgProc, *obhinst, *obhwnd;
	if (!PyArg_ParseTuple(args, "OOOO|l", 
		&obhinst,	// @pyparm <o PyHANDLE>|hInstance||Handle to module that contains the dialog template
		&obResId,	// @pyparm <o PyResourceId>|TemplateName||Name or resource id of the dialog resource
		&obhwnd,	// @pyparm <o PyHANDLE>|hWndParent||Handle to dialog's parent window
		&obDlgProc,	// @pyparm function|DialogFunc||Dialog box procedure to process messages
		&param))	// @pyparm int|InitParam|0|Initialization data to be passed to above procedure during WM_INITDIALOG processing
		return NULL;
	if (!PyWinObject_AsHANDLE(obhinst, (HANDLE *)&hinst))
		return NULL;
	if (!PyWinObject_AsHANDLE(obhwnd, (HANDLE *)&hwnd))
		return NULL;
	LPTSTR resid;
	if (!PyWinObject_AsResourceId(obResId, &resid))
		return NULL;

	PyObject *obExtra = Py_BuildValue("Ol", obDlgProc, param);
	INT_PTR rc;
    Py_BEGIN_ALLOW_THREADS
	rc = DialogBoxParam(hinst, resid, hwnd, PyDlgProcHDLG, (LPARAM)obExtra);
    Py_END_ALLOW_THREADS
	
	PyWinObject_FreeResourceId(resid);
	Py_DECREF(obExtra);
	if (rc==-1)
		return PyWin_SetAPIError("DialogBox");
	return PyWinLong_FromVoidPtr((void *)rc);
}

static PyObject *PyDialogBoxIndirect(PyObject *self, PyObject *args)
{
	HINSTANCE hinst;
	HWND hwnd;
	PyObject *obParam = Py_None;
	PyObject *obhinst, *obhwnd, *obList, *obDlgProc;
	BOOL bFreeString = FALSE;

	if (!PyArg_ParseTuple(args, "OOOO|O", 
		&obhinst,		// @pyparm <o PyHANDLE>|hInstance||Handle to module creating the dialog box
		&obList,		// @pyparm <o PyDialogTemplate>|controlList||Sequence of items defining the dialog box and subcontrols
		&obhwnd,		// @pyparm <o PyHANDLE>|hWndParent||Handle to dialog's parent window
		&obDlgProc,		// @pyparm function|DialogFunc||Dialog box procedure to process messages
		&obParam))		// @pyparm long|InitParam|0|Initialization data to be passed to above procedure during WM_INITDIALOG processing
		return NULL;
	if (!PyWinObject_AsHANDLE(obhinst, (HANDLE *)&hinst))
		return NULL;
	if (!PyWinObject_AsHANDLE(obhwnd, (HANDLE *)&hwnd))
		return NULL;
	// We unpack the object in the dlgproc - but check validity now
	if (obParam != Py_None && !PyInt_Check(obParam) && !PyLong_Check(obParam)) {
		return PyErr_Format(PyExc_TypeError, "optional param must be None, or an integer (got %s)",
		                    obParam->ob_type->tp_name);
	}

	HGLOBAL h = MakeResourceFromDlgList(obList);
	if (h == NULL)
		return NULL;

	HGLOBAL templ = (HGLOBAL) GlobalLock(h);
	if (!templ) {
		GlobalFree(h);
		return PyWin_SetAPIError("GlobalLock (for template)");
	}

	PyObject *obExtra = Py_BuildValue("OO", obDlgProc, obParam);

	INT_PTR rc;
    Py_BEGIN_ALLOW_THREADS
	rc = DialogBoxIndirectParam(hinst, (const DLGTEMPLATE *) templ, hwnd, PyDlgProcHDLG, (LPARAM)obExtra);
	GlobalUnlock(h);
	GlobalFree(h);
    Py_END_ALLOW_THREADS
	Py_DECREF(obExtra);
	if (rc==-1)
		return PyWin_SetAPIError("DialogBoxIndirect");

	return PyWinLong_FromVoidPtr((void *)rc);
}

static PyObject *PyCreateDialogIndirect(PyObject *self, PyObject *args)
{
	/// XXX - todo - add support for a dialogproc!
	HINSTANCE hinst;
	HWND hwnd;
	LPARAM param=0;
	PyObject *obhinst, *obhwnd, *obList, *obDlgProc;
	BOOL bFreeString = FALSE;
	if (!PyArg_ParseTuple(args, "OOOO|l",
		&obhinst,		// @pyparm <o PyHANDLE>|hInstance||Handle to module creating the dialog box
		&obList,		// @pyparm <o PyDialogTemplate>|controlList||Sequence containing a <o PyDLGTEMPLATE>, followed by variable number of <o PyDLGITEMTEMPLATE>s
		&obhwnd,		// @pyparm <o PyHANDLE>|hWndParent||Handle to dialog's parent window
		&obDlgProc,		// @pyparm function|DialogFunc||Dialog box procedure to process messages
		&param))		// @pyparm int|InitParam|0|Initialization data to be passed to above procedure during WM_INITDIALOG processing
		return NULL;
	if (!PyWinObject_AsHANDLE(obhinst, (HANDLE *)&hinst))
		return NULL;
	if (!PyWinObject_AsHANDLE(obhwnd, (HANDLE *)&hwnd))
		return NULL;

	HGLOBAL h = MakeResourceFromDlgList(obList);
	if (h == NULL)
		return NULL;

	PyObject *obExtra = Py_BuildValue("Ol", obDlgProc, param);

	HWND rc;
    Py_BEGIN_ALLOW_THREADS
	HGLOBAL templ = (HGLOBAL) GlobalLock(h);
	rc = CreateDialogIndirectParam(hinst, (const DLGTEMPLATE *) templ, hwnd, PyDlgProcHDLG, (LPARAM)obExtra);
	GlobalUnlock(h);
	GlobalFree(h);
    Py_END_ALLOW_THREADS
	Py_DECREF(obExtra);
	if (NULL == rc)
		return PyWin_SetAPIError("CreateDialogIndirect");

	return PyWinLong_FromHANDLE(rc);

}

static PyObject *PyGetDlgItemInt(PyObject *self, PyObject *args)
{
	BOOL bTranslated, bSigned;
	int id;
	UINT val;
	HWND hDlg;
	PyObject *obhDlg;
	if (!PyArg_ParseTuple(args, "Oii:GetDlgItemInt", 
		&obhDlg,	// @pyparm <o PyHANDLE>|hDlg||Handle to a dialog window
		&id,		// @pyparm int|IDDlgItem||Identifier of one of the dialog's controls
		&bSigned))	// @pyparm boolean|Signed||Indicates whether control value should be interpreted as signed
		return NULL;
	if (!PyWinObject_AsHANDLE(obhDlg, (HANDLE *)&hDlg))
		return NULL;

	val=GetDlgItemInt(hDlg, id, &bTranslated, bSigned);
	if (!bTranslated)
		return PyWin_SetAPIError("GetDlgItemInt");
	if (bSigned)
		return PyLong_FromLong(val);
	return PyLong_FromUnsignedLong(val);
}

static PyObject *PyGetDlgItemText(PyObject *self, PyObject *args)
{	
	int dlgitem;
	HWND hwnd;
	TCHAR *buf=NULL;
	UINT chars_returned;
	DWORD chars_allocated=128, bufsize;
	#ifdef Py_DEBUG
	chars_allocated=3;
	#endif
	PyObject *ret=NULL, *obhwnd;
	if (!PyArg_ParseTuple(args, "Oi",
		&obhwnd,	// @pyparm <o PyHANDLE>|hDlg||Handle to a dialog window
		&dlgitem))	// @pyparm int|IDDlgItem||The Id of a control within the dialog
		return NULL;
	if (!PyWinObject_AsHANDLE(obhwnd, (HANDLE *)&hwnd))
		return NULL;
	// If text is too long for buffer, it's truncated and truncated size returned
	// Loop until fewer characters returned than were allocated
	while(TRUE){
		if (buf!=NULL){
			free(buf);
			chars_allocated*=2;
			}
		bufsize=chars_allocated*sizeof(TCHAR);
		buf=(TCHAR *)malloc(bufsize);
		if (buf==NULL)
			return PyErr_Format(PyExc_MemoryError, "Unable to allocate %d bytes", bufsize);
		chars_returned=GetDlgItemText(hwnd, dlgitem, buf, chars_allocated);
		if (chars_returned==0 && GetLastError()!=0){
			PyWin_SetAPIError("GetDlgItemText");
			break;
			}
		// Return count doesn't include trailing NULL
		if (chars_returned+1 < chars_allocated){
			ret=PyWinObject_FromTCHAR(buf, chars_returned);
			break;
			}
		}
	if (buf!=NULL)
		free(buf);
	return ret;
}

// @pyswig string|GetWindowText|Get the window text.
static PyObject *PyGetWindowText(PyObject *self, PyObject *args)
{
    HWND hwnd;
    int len;
	PyObject *obhwnd;
	TCHAR buffer[512];
	// @pyparm <o PyHANDLE>|hwnd||The handle to the window
	if (!PyArg_ParseTuple(args, "O", &obhwnd))
		return NULL;
	if (!PyWinObject_AsHANDLE(obhwnd, (HANDLE *)&hwnd))
		return NULL;
    Py_BEGIN_ALLOW_THREADS
    len = GetWindowText(hwnd, buffer, sizeof(buffer)/sizeof(TCHAR));
    Py_END_ALLOW_THREADS
    // @comm Note that previous versions of PyWin32 returned a (empty) Unicode 
    // object when the string was empty, or an MBCS encoded string value 
    // otherwise.  A String is now returned in all cases.
	return PyWinObject_FromTCHAR(buffer, len);
}

// @pyswig |InitCommonControlsEx|Initializes specific common controls.
static PyObject *PyInitCommonControlsEx(PyObject *self, PyObject *args)
{
	int flag;
	// @pyparm int|flag||One of the ICC_ constants
	if (!PyArg_ParseTuple(args, "i", &flag))
		return NULL;
	INITCOMMONCONTROLSEX cc;
	cc.dwSize = sizeof(cc);
	cc.dwICC = flag;
	if (!InitCommonControlsEx(&cc))
		return PyWin_SetAPIError("InitCommonControlsEx");
	Py_INCREF(Py_None);
	return Py_None;
}

// @pyswig flags, hcursor, (x,y)|GetCursorInfo|Retrieves information about the global cursor.
PyObject *PyGetCursorInfo(PyObject *self, PyObject *args)
{
	CURSORINFO ci;
	ci.cbSize = sizeof(ci);
	if (!PyArg_ParseTuple(args,":GetCursorInfo"))
		return NULL;
	if (!::GetCursorInfo(&ci))
		return PyWin_SetAPIError("GetCursorInfo");
	return Py_BuildValue("iN(ii)", ci.flags, PyWinLong_FromHANDLE(ci.hCursor), ci.ptScreenPos.x, ci.ptScreenPos.y);
}

PyObject *PyCreateAcceleratorTable(PyObject *self, PyObject *args)
{
    DWORD num, i;
    ACCEL *accels = NULL;
    PyObject *ret = NULL;
    PyObject *obAccels, *Accels_tuple;
    HACCEL ha;
    // @pyparm ( (int, int, int), ...)|accels||A sequence of (fVirt, key, cmd),
    // as per the Win32 ACCEL structure.
    if (!PyArg_ParseTuple(args, "O:CreateAcceleratorTable", &obAccels))
        return NULL;
    if ((Accels_tuple=PyWinSequence_Tuple(obAccels, &num)) == NULL)
		return NULL;

    if (num==0) {
        PyErr_SetString(PyExc_ValueError, "Can't create an accelerator with zero items");
        goto done;
    }
    accels = (ACCEL *)malloc(num * sizeof(ACCEL));
    if (!accels) {
        PyErr_NoMemory();
        goto done;
    }
    for (i=0;i<num;i++) {
        ACCEL *p = accels+i;
        PyObject *ob = PyTuple_GET_ITEM(Accels_tuple, i);
        if (!PyArg_ParseTuple(ob, "BHH:ACCEL", &p->fVirt, &p->key, &p->cmd))
            goto done;
    }
    ha = ::CreateAcceleratorTable(accels, num);
    if (ha)
        ret = PyWinLong_FromHANDLE(ha);
    else
        PyWin_SetAPIError("CreateAcceleratorTable");
done:
	Py_DECREF(Accels_tuple);
    if (accels)
        free(accels);
    return ret;
}

// @pyswig <o PyHANDLE>|CreateIconFromResource|Creates an icon or cursor from resource bits describing the icon.
static PyObject *PyCreateIconFromResource(PyObject *self, PyObject *args)
{
	// @pyparm string|bits||The bits
	// @pyparm bool|fIcon||True if an icon, False if a cursor.
	// @pyparm int|ver|0x00030000|Specifies the version number of the icon or cursor
	// format for the resource bits pointed to by the presbits parameter.
	// This parameter can be 0x00030000.
	PBYTE bits;
	DWORD nBits;
	int isIcon;
	DWORD ver = 0x00030000;
	PyObject *obbits;
	if (!PyArg_ParseTuple(args, "Oi|i", &obbits, &isIcon, &ver))
		return NULL;
	if (!PyWinObject_AsReadBuffer(obbits, (void **)&bits, &nBits, FALSE))
		return NULL;
	HICON ret = CreateIconFromResource(bits, nBits, isIcon, ver);
	if (!ret)
	    return PyWin_SetAPIError("CreateIconFromResource");
	return PyWinLong_FromHANDLE(ret);
}

// @pyswig |DeleteObject|Deletes a logical pen, brush, font, bitmap, region, or palette, freeing all system resources associated with the object. After the object is deleted, the specified handle is no longer valid.
static PyObject *PyDeleteObject(PyObject *self, PyObject *args)
{
	PyObject *obhgdiobj;
	if (!PyArg_ParseTuple(args, "O:DeleteObject",
		&obhgdiobj))	// @pyparm <o PyGdiHANDLE>|handle||handle to the object to delete.
		return NULL;
	if (PyHANDLE_Check(obhgdiobj)){
		// Make sure we don't call Close() for any other type of PyHANDLE
		if (strcmp(((PyHANDLE *)obhgdiobj)->GetTypeName(),"PyGdiHANDLE")!=0){
			PyErr_SetString(PyExc_TypeError,"DeleteObject requires a PyGdiHANDLE");
			return NULL;
			}
		if (!((PyHANDLE *)obhgdiobj)->Close())
			return NULL;
		Py_INCREF(Py_None);
		return Py_None;
		}
	HGDIOBJ hgdiobj;
	if (!PyWinObject_AsHANDLE(obhgdiobj, &hgdiobj))
		return NULL;
	if (!DeleteObject(hgdiobj))
		return PyWin_SetAPIError("DeleteObject");
	Py_INCREF(Py_None);
	return Py_None;
}

// @pyswig |TransparentBlt|Transfers color from one DC to another, with one color treated as transparent
static PyObject *PyTransparentBlt(PyObject *self, PyObject *args)
{
	CHECK_PFN(TransparentBlt);
	PyObject *obsrc, *obdst;
	HDC src, dst;
	int src_x, src_y, src_width, src_height;
	int dst_x, dst_y, dst_width, dst_height;
	UINT transparent;
	BOOL ret;
	if (!PyArg_ParseTuple(args,"OiiiiOiiiiI:TransparentBlt",
		&obdst,			// @pyparm <o PyHANDLE>|Dest||Destination device context handle
		&dst_x,			// @pyparm int|XOriginDest||X pos of dest rect
		&dst_y,			// @pyparm int|YOriginDest||Y pos of dest rect
		&dst_width,		// @pyparm int|WidthDest||Width of dest rect
		&dst_height,	// @pyparm int|HeightDest||Height of dest rect
		&obsrc,			// @pyparm <o PyHANDLE>|Src||Source DC handle
		&src_x,			// @pyparm int|XOriginSrc||X pos of src rect
		&src_y,			// @pyparm int|YOriginSrc||Y pos of src rect
		&src_width,		// @pyparm int|WidthSrc||Width of src rect
		&src_height,	// @pyparm int|HeightSrc||Height of src rect
		&transparent))	// @pyparm int|Transparent||RGB color value that will be transparent
		return NULL;
	if (!PyWinObject_AsHANDLE(obdst, (HANDLE *)&dst))
		return NULL;
	if (!PyWinObject_AsHANDLE(obsrc, (HANDLE *)&src))
		return NULL;
	Py_BEGIN_ALLOW_THREADS
	ret=(*pfnTransparentBlt)(
		dst, dst_x, dst_y, dst_width, dst_height,
		src, src_x, src_y, src_width, src_height,
		transparent);
	Py_END_ALLOW_THREADS
	if (!ret)
		return PyWin_SetAPIError("TransparentBlt");
	Py_INCREF(Py_None);
	return Py_None;
}

// @pyswig |MaskBlt|Combines the color data for the source and destination
// bitmaps using the specified mask and raster operation.
// @comm This function is not supported on Win9x.
// @pyseeapi MaskBlt
static PyObject *PyMaskBlt(PyObject *self, PyObject *args)
{
	CHECK_PFN(MaskBlt);
	PyObject *obsrc, *obdst, *obmask;
	HDC src, dst;
	HBITMAP mask;
	int dst_x, dst_y, dst_width, dst_height;
	int src_x, src_y;
	int mask_x, mask_y;
	DWORD rop;
	if (!PyArg_ParseTuple(args,"OiiiiOiiOiik:MaskBlt",
		&obdst,			// @pyparm <o PyHANDLE>|Dest||Destination device context handle
		&dst_x,			// @pyparm int|XDest||X pos of dest rect
		&dst_y,			// @pyparm int|YDest||Y pos of dest rect
		&dst_width,		// @pyparm int|Width||Width of rect to be copied
		&dst_height,	// @pyparm int|Height||Height of rect to be copied
		&obsrc,			// @pyparm <o PyHANDLE>|Src||Source DC handle
		&src_x,			// @pyparm int|XSrc||X pos of src rect
		&src_y,			// @pyparm int|YSrc||Y pos of src rect
		&obmask,		// @pyparm <o PyGdiHANDLE>|Mask||Handle to monochrome bitmap used to mask color
		&mask_x,		// @pyparm int|xMask||X pos in mask
		&mask_y,		// @pyparm int|yMask||Y pos in mask
		&rop))			// @pyparm int|Rop||Foreground and background raster operations.  See MSDN docs for how to construct this value.
		return NULL;
	if (!PyWinObject_AsHANDLE(obdst, (HANDLE *)&dst))
		return NULL;
	if (!PyWinObject_AsHANDLE(obsrc, (HANDLE *)&src))
		return NULL;
	if (!PyWinObject_AsHANDLE(obmask, (HANDLE *)&mask))
		return NULL;
	if (!(*pfnMaskBlt)(
		dst, dst_x, dst_y, dst_width, dst_height,
		src, src_x, src_y,
		mask, mask_x, mask_y, rop))
		return PyWin_SetAPIError("MaskBlt");
	Py_INCREF(Py_None);
	return Py_None;
}

// @pyswig |AlphaBlend|Transfers color information using alpha blending
static PyObject *PyAlphaBlend(PyObject *self, PyObject *args)
{
	CHECK_PFN(AlphaBlend);
	PyObject *obsrc, *obdst, *obbl;
	HDC src, dst;
	int src_x, src_y, src_width, src_height;
	int dst_x, dst_y, dst_width, dst_height;
	BLENDFUNCTION bl;
	if (!PyArg_ParseTuple(args,"OiiiiOiiiiO:AlphaBlend",
		&obdst,			// @pyparm <o PyHANDLE>|Dest||Destination device context handle
		&dst_x,			// @pyparm int|XOriginDest||X pos of dest rect
		&dst_y,			// @pyparm int|YOriginDest||Y pos of dest rect
		&dst_width,		// @pyparm int|WidthDest||Width of dest rect
		&dst_height,	// @pyparm int|HeightDest||Height of dest rect
		&obsrc,			// @pyparm <o PyHANDLE>|Src||Source DC handle
		&src_x,			// @pyparm int|XOriginSrc||X pos of src rect
		&src_y,			// @pyparm int|YOriginSrc||Y pos of src rect
		&src_width,		// @pyparm int|WidthSrc||Width of src rect
		&src_height,	// @pyparm int|HeightSrc||Height of src rect
		&obbl))			// @pyparm <o PyBLENDFUNCTION>|blendFunction||Alpha blending parameters
		return NULL;
	if (!PyWinObject_AsHANDLE(obdst, (HANDLE *)&dst))
		return NULL;
	if (!PyWinObject_AsHANDLE(obsrc, (HANDLE *)&src))
		return NULL;
	if (!PyWinObject_AsBLENDFUNCTION(obbl, &bl))
		return NULL;
	if (!(*pfnAlphaBlend)(
		dst, dst_x, dst_y, dst_width, dst_height,
		src, src_x, src_y, src_width, src_height,
		bl))
		return PyWin_SetAPIError("AlphaBlend");
	Py_INCREF(Py_None);
	return Py_None;
}

// @pyswig tuple|GetWindowPlacement|Returns placement information about the current window.
static PyObject *
PyGetWindowPlacement(PyObject *self, PyObject *args)
{
	HWND hwnd;
	PyObject *obhwnd;
	if (!PyArg_ParseTuple(args, "O:GetWindowPlacement", &obhwnd))
		return NULL;
	if (!PyWinObject_AsHANDLE(obhwnd, (HANDLE *)&hwnd))
		return NULL;

	WINDOWPLACEMENT pment;
	pment.length=sizeof(pment);
	BOOL ok;
	Py_BEGIN_ALLOW_THREADS
	ok = GetWindowPlacement(hwnd, &pment );
	Py_END_ALLOW_THREADS
	if (!ok)
		return PyWin_SetAPIError("GetWindowPlacement");
	// @rdesc The result is a tuple of
	// (flags, showCmd, (minposX, minposY), (maxposX, maxposY), (normalposX, normalposY))
	// @flagh Item|Description
	// @flag flags|One of the WPF_* constants
	// @flag showCmd|Current state - one of the SW_* constants.
	// @flag minpos|Specifies the coordinates of the window's upper-left corner when the window is minimized.
	// @flag maxpos|Specifies the coordinates of the window's upper-left corner when the window is maximized. 
	// @flag normalpos|Specifies the window's coordinates when the window is in the restored position.
	return Py_BuildValue("(ii(ii)(ii)(iiii))",pment.flags, pment.showCmd,
	                     pment.ptMinPosition.x,pment.ptMinPosition.y,
	                     pment.ptMaxPosition.x,pment.ptMaxPosition.y,
	                     pment.rcNormalPosition.left, pment.rcNormalPosition.top,
	                     pment.rcNormalPosition.right, pment.rcNormalPosition.bottom);
}
// @pyswig |SetWindowPlacement|Sets the windows placement
static PyObject *
PySetWindowPlacement(PyObject *self, PyObject *args)
{
	PyObject *obhwnd;
	HWND hwnd;
	WINDOWPLACEMENT pment;
	pment.length=sizeof(pment);
	// @pyparm <o PyHANDLE>|hWnd||Handle to a window
	// @pyparm (tuple)|placement||A tuple representing the WINDOWPLACEMENT structure.
	if (!PyArg_ParseTuple(args,"O(ii(ii)(ii)(iiii)):SetWindowPlacement",
	                      &obhwnd,
	                      &pment.flags, &pment.showCmd,
	                      &pment.ptMinPosition.x,&pment.ptMinPosition.y,
	                      &pment.ptMaxPosition.x,&pment.ptMaxPosition.y,
	                      &pment.rcNormalPosition.left, &pment.rcNormalPosition.top,
	                      &pment.rcNormalPosition.right, &pment.rcNormalPosition.bottom))
		return NULL;
	if (!PyWinObject_AsHANDLE(obhwnd, (HANDLE *)&hwnd))
		return NULL;
	BOOL rc;
	Py_BEGIN_ALLOW_THREADS
	rc = SetWindowPlacement(hwnd, &pment );
	Py_END_ALLOW_THREADS
	if (!rc)
		return PyWin_SetAPIError("SetWindowPlacement");
	Py_INCREF(Py_None);
	return Py_None;
}


// @pyswig int|RegisterClass|Registers a window class.
static PyObject *PyRegisterClass(PyObject *self, PyObject *args)
{
	PyObject *obwc;
	// @pyparm <o PyWNDCLASS>|wndClass||An object describing the window class.
	if (!PyArg_ParseTuple(args, "O", &obwc))
		return NULL;
	if (!PyWNDCLASS_Check(obwc)) {
		PyErr_SetString(PyExc_TypeError, "The object must be a WNDCLASS object");
		return NULL;
	}
	ATOM at = RegisterClass( &((PyWNDCLASS *)obwc)->m_WNDCLASS );
	if (at==0)
		return PyWin_SetAPIError("RegisterClass");

	// Save atom/PyWNDCLASS and name/atom pairs in global dict.  These are used in
	// CreateWindow to lookup the python window proc function for the class
	PyObject *ret = PyInt_FromLong(at);
	if (ret==NULL)
		return NULL;
	if (PyDict_SetItem(g_AtomMap, ((PyWNDCLASS *)obwc)->m_obClassName, ret)==-1){
		Py_DECREF(ret);
		return NULL;
		}
	if (PyDict_SetItem(g_AtomMap, ret, obwc)==-1){
		PyDict_DelItem(g_AtomMap, ((PyWNDCLASS *)obwc)->m_obClassName);
		Py_DECREF(ret);
		return NULL;
		}
	return ret;
}

// @pyswig |UnregisterClass|Unregisters a window class created by <om win32gui.RegisterClass>
static PyObject *PyUnregisterClass(PyObject *self, PyObject *args)
{
	LPTSTR atom;
	HINSTANCE hinst;
	PyObject *obhinst, *obatom, *ret=NULL;
	if (!PyArg_ParseTuple(args, "OO", 
		&obatom,		// @pyparm <o PyResourceId>|atom||The atom or classname identifying the class previously registered.
		&obhinst))		// @pyparm <o PyHANDLE>|hinst||The handle to the instance unregistering the class, can be None
		return NULL;
	if (!PyWinObject_AsHANDLE(obhinst, (HANDLE *)&hinst))
		return NULL;
	if (!PyWinObject_AsResourceId(obatom, &atom))
		return NULL;
	BOOL bsuccess=UnregisterClass(atom, hinst);
	if (!bsuccess){
		PyWinObject_FreeResourceId(atom);
		return PyWin_SetAPIError("UnregisterClass");
		}

	// Delete the atom/PyWNDCLASS and name/atom from the global dictionary.
	PyObject *val=PyDict_GetItem(g_AtomMap, obatom);
	if (val!=NULL){
		if (IS_INTRESOURCE(atom))	// val is the PyWNDCLASS, use it's name to delete the name/atom pair
			PyDict_DelItem(g_AtomMap, ((PyWNDCLASS *)val)->m_obClassName);
		else	// val is numeric atom, use it to delete the atom/PyWNDCLASS pair
			PyDict_DelItem(g_AtomMap, val);
		PyDict_DelItem(g_AtomMap, obatom);
		}

	// Don't throw an exception if dict items can't be deleted since UnregisterClass has already succeeded
	PyWinObject_FreeResourceId(atom);
	if (PyErr_Occurred())
		PyErr_Print();
	Py_INCREF(Py_None);
	return Py_None;
}

// @pyswig |PumpMessages|Runs a message loop until a WM_QUIT message is received.
// @rdesc Returns exit code from PostQuitMessage when a WM_QUIT message is received
static PyObject *PyPumpMessages(PyObject *self, PyObject *args)
{
	if (!PyArg_ParseTuple(args, ""))
		return NULL;

	MSG msg;
	int rc;

    Py_BEGIN_ALLOW_THREADS
	while ((rc=GetMessage(&msg, 0, 0, 0))==1) {
		if(NULL == hDialogCurrent || !IsDialogMessage(hDialogCurrent,&msg)) {
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}
    Py_END_ALLOW_THREADS

	if (-1 == rc)
		return PyWin_SetAPIError("GetMessage");

	return PyWinLong_FromVoidPtr((void *)msg.wParam);

	// @xref <om win32gui.PumpWaitingMessages>
}

// @pyswig int|PumpWaitingMessages|Pumps all waiting messages for the current thread.
// @rdesc Returns non-zero (exit code from PostQuitMessage) if a WM_QUIT message was received, else 0
static PyObject *PyPumpWaitingMessages(PyObject *self, PyObject *args)
{
	UINT firstMsg = 0, lastMsg = 0;
	if (!PyArg_ParseTuple (args, "|ii:PumpWaitingMessages", &firstMsg, &lastMsg))
		return NULL;
	// @pyseeapi PeekMessage and DispatchMessage

    MSG msg;
	WPARAM result = 0;
	// Read all of the messages in this next loop, 
	// removing each message as we read it.
	Py_BEGIN_ALLOW_THREADS
	while (PeekMessage(&msg, NULL, firstMsg, lastMsg, PM_REMOVE)) {
		// If it's a quit message, we're out of here.
		if (msg.message == WM_QUIT) {
			if(0 != msg.wParam)
				result = msg.wParam;
			else
				result = 1;
			break;
		}
		// Otherwise, dispatch the message.
		if(NULL == hDialogCurrent || !IsDialogMessage(hDialogCurrent,&msg)) {
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	} // End of PeekMessage while loop
	// @xref <om win32gui.PumpMessages>
	Py_END_ALLOW_THREADS
	return PyWinLong_FromVoidPtr((void *)result);
}


static PyObject *
PyHIWORD(PyObject *self, PyObject *args)
{	int n;
	if(!PyArg_ParseTuple(args, "i:HIWORD", &n))
		return NULL;
	return PyInt_FromLong(HIWORD(n));
}

static PyObject *
PyLOWORD(PyObject *self, PyObject *args)
{	int n;
	if(!PyArg_ParseTuple(args, "i:LOWORD", &n))
		return NULL;
	return PyInt_FromLong(LOWORD(n));
}

#ifdef MS_WINCE
BOOL PyObject_AsNOTIFYICONDATA(PyObject *ob, NOTIFYICONDATA *pnid)
{
	PyObject *obTip=NULL;
	PyObject *obhwnd, *obhicon=Py_None;
	memset(pnid, 0, sizeof(*pnid));
	pnid->cbSize = sizeof(*pnid);
	if (!PyArg_ParseTuple(ob, "O|iiiOO:NOTIFYICONDATA tuple", &obhwnd, &pnid->uID, &pnid->uFlags, &pnid->uCallbackMessage, &obhicon, &obTip))
		return FALSE;
	if (!PyWinObject_AsHANDLE(obhwnd, (HANDLE *)&pnid->hWnd))
		return NULL;
	if (!PyWinObject_AsHANDLE(obhicon, (HANDLE *)&pnid->hIcon))
		return NULL;
	if (obTip) {
		TCHAR *szTip;
		if (!PyWinObject_AsTCHAR(obTip, &szTip))
			return NULL;
		_tcsncpy(pnid->szTip, szTip, sizeof(pnid->szTip)/sizeof(TCHAR));
		PyWinObject_FreeTCHAR(szTip);
	}
	return TRUE;
}
#else	// MS_WINCE
BOOL PyObject_AsNOTIFYICONDATA(PyObject *ob, NOTIFYICONDATA *pnid)
{
	PyObject *obTip=NULL, *obInfo=NULL, *obInfoTitle=NULL;
	PyObject *obhwnd, *obhicon=Py_None;
	memset(pnid, 0, sizeof(*pnid));
	pnid->cbSize = sizeof(*pnid);
	// @object PyNOTIFYICONDATA|Tuple used to fill a NOTIFYICONDATA struct as used with <om win32gui.Shell_NotifyIcon>
	// @pyseeapi NOTIFYICONDATA
	if (!PyArg_ParseTuple(ob, "O|iiiOOOiOi:NOTIFYICONDATA tuple", 
		&obhwnd,		// @tupleitem 0|<o PyHANDLE>|hWnd|Handle to window that will process icon's messages
		&pnid->uID,		// @tupleitem 1|int|ID|Unique id used when hWnd processes messages from more than one icon
		&pnid->uFlags,	// @tupleitem 2|int|Flags|Combination of win32gui.NIF_* flags
		&pnid->uCallbackMessage,	// @tupleitem 3|int|CallbackMessage|Message id to be pass to hWnd when processing messages
		&obhicon,		// @tupleitem 4|<o PyHANDLE>|hIcon|Handle to the icon to be displayed
		&obTip,			// @tupleitem 5|str|Tip|Tooltip text (optional)
		&obInfo,		// @tupleitem 6|str|Info|Balloon tooltip text (optional)
		&pnid->uTimeout,	// @tupleitem 7|int|Timeout|Timeout for balloon tooltip, in milliseconds (optional)
		&obInfoTitle,	// @tupleitem 8|str|InfoTitle|Title for balloon tooltip (optional)
		&pnid->dwInfoFlags))	// @tupleitem 9|int|InfoFlags|Combination of win32gui.NIIF_* flags (optional)
		return FALSE;
	if (!PyWinObject_AsHANDLE(obhwnd, (HANDLE *)&pnid->hWnd))
		return NULL;
	if (!PyWinObject_AsHANDLE(obhicon, (HANDLE *)&pnid->hIcon))
		return NULL;
	if (obTip) {
		TCHAR *szTip;
		if (!PyWinObject_AsTCHAR(obTip, &szTip))
			return NULL;
		_tcsncpy(pnid->szTip, szTip, sizeof(pnid->szTip)/sizeof(TCHAR));
		PyWinObject_FreeTCHAR(szTip);
	}
	if (obInfo) {
		TCHAR *szInfo;
		if (!PyWinObject_AsTCHAR(obInfo, &szInfo))
			return NULL;
		_tcsncpy(pnid->szInfo, szInfo, sizeof(pnid->szInfo)/sizeof(TCHAR));
		PyWinObject_FreeTCHAR(szInfo);
	}
	if (obInfoTitle) {
		TCHAR *szInfoTitle;
		if (!PyWinObject_AsTCHAR(obInfoTitle, &szInfoTitle))
			return NULL;
		_tcsncpy(pnid->szInfoTitle, szInfoTitle, sizeof(pnid->szInfoTitle)/sizeof(TCHAR));
		PyWinObject_FreeTCHAR(szInfoTitle);
	}
	return TRUE;
}
#endif // MS_WINCE

static PyObject *PyEdit_GetLine(PyObject *self, PyObject *args)
{
	HWND hwnd;
	PyObject *obhwnd;
	int line, size=0;
	if (!PyArg_ParseTuple(args, "Oi|i", &obhwnd, &line, &size))
		return NULL;
	if (!PyWinObject_AsHANDLE(obhwnd, (HANDLE *)&hwnd))
		return NULL;
	int numChars;
	TCHAR *buf;
	Py_BEGIN_ALLOW_THREADS
	if (size==0)
		size = Edit_LineLength(hwnd, line)+1;
	buf = (TCHAR *)malloc(size * sizeof(TCHAR));
	numChars = Edit_GetLine(hwnd, line, buf, size);
	Py_END_ALLOW_THREADS
	PyObject *ret;
	if (numChars==0) {
		Py_INCREF(Py_None);
		ret = Py_None;
	} else
		ret = PyWinObject_FromTCHAR(buf, numChars);
	free(buf);
	return ret;
}

#include "commdlg.h"

PyObject *Pylpstr(PyObject *self, PyObject *args) {
	char *address;
	PyObject *obaddress;
	if (!PyArg_ParseTuple(args, "O", &obaddress))
		return NULL;
	if (!PyWinLong_AsVoidPtr(obaddress, (void **)&address))
		return NULL;
	return PyString_FromString(address);
}

static PyObject *PyExtractIconEx(PyObject *self, PyObject *args)
{
    int i;
    PyObject *obFname;
    TCHAR *fname;
    int index, nicons=1, nicons_got;
    if (!PyArg_ParseTuple(args, "Oi|i", &obFname, &index, &nicons))
        return NULL;
    if (!PyWinObject_AsTCHAR(obFname, &fname, TRUE))
		return NULL;
#ifndef MS_WINCE // CE doesn't have this special "-1" handling.
    if (index==-1) {
        nicons = (int)ExtractIconEx(fname, index, NULL, NULL, 0);
        PyWinObject_FreeTCHAR(fname);
        return PyInt_FromLong(nicons);
    }
#endif // MS_WINCE
    if (nicons<=0) {
        PyWinObject_FreeTCHAR(fname);
        return PyErr_Format(PyExc_ValueError, "Must supply a valid number of icons to fetch.");
    }
    HICON *rgLarge = NULL;
    HICON *rgSmall = NULL;
    PyObject *ret = NULL;
    PyObject *objects_large = NULL;
    PyObject *objects_small = NULL;
    rgLarge = (HICON *)calloc(nicons, sizeof(HICON));
    if (rgLarge==NULL) {
        PyErr_NoMemory();
        goto done;
    }
    rgSmall = (HICON *)calloc(nicons, sizeof(HICON));
    if (rgSmall==NULL) {
        PyErr_NoMemory();
        goto done;
    }
    nicons_got = (int)ExtractIconEx(fname, index, rgLarge, rgSmall, nicons);
    if (nicons_got==-1) {
        PyWin_SetAPIError("ExtractIconEx");
        goto done;
    }
#ifdef MS_WINCE
    /* On WinCE >= 2.1 the API actually returns a HICON */
    nicons_got = 1;
#endif
    // Asking for 1 always says it got 2!?
    nicons = min(nicons, nicons_got);
    objects_large = PyList_New(nicons);
    if (!objects_large) goto done;
    objects_small = PyList_New(nicons);
    if (!objects_small) goto done;
    for (i=0;i<nicons;i++) {
        PyList_SET_ITEM(objects_large, i, PyWinLong_FromHANDLE(rgLarge[i]));
        PyList_SET_ITEM(objects_small, i, PyWinLong_FromHANDLE(rgSmall[i]));
    }
    ret = Py_BuildValue("OO", objects_large, objects_small);
done:
    PyWinObject_FreeTCHAR(fname);
    Py_XDECREF(objects_large);
    Py_XDECREF(objects_small);
    if (rgLarge) free(rgLarge);
    if (rgSmall) free(rgSmall);
    return ret;
}

// @pyswig cx, cy|GetTextExtentPoint32|Computes the width and height of the specified string of text.
static PyObject *PyGetTextExtentPoint32(PyObject *self, PyObject *args)
{
	// @pyparm <o PyHANDLE>|hdc||The device context
	// @pyparm string|str||The string to measure.
	HDC hdc;
	PyObject *obString, *obdc;
	if (!PyArg_ParseTuple(args, "OO:GetTextExtentPoint32", &obdc, &obString))
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	TCHAR *szString = NULL;
	DWORD nchars;
	if (!PyWinObject_AsTCHAR(obString, &szString, FALSE, &nchars))
		return FALSE;
	SIZE size = {0,0};
	BOOL rc;
	Py_BEGIN_ALLOW_THREADS
	rc = GetTextExtentPoint32(hdc, szString, nchars, &size);
	Py_END_ALLOW_THREADS
	PyWinObject_FreeTCHAR(szString);
	if (!rc)
		return PyWin_SetAPIError("GetTextExtentPoint32");
	return Py_BuildValue("ll", size.cx, size.cy);
}

// @pyswig dict|GetTextMetrics|Returns info for the font selected into a DC
static PyObject *PyGetTextMetrics(PyObject *self, PyObject *args)
{
	HDC hdc;
	PyObject *obdc;
	TEXTMETRICW tm;
	if (!PyArg_ParseTuple(args, "O:GetTextMetrics",
		&obdc))
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	if (!GetTextMetricsW(hdc, &tm))
		return PyWin_SetAPIError("GetTextMetrics");
	return Py_BuildValue("{s:l,s:l,s:l,s:l,s:l,s:l,s:l,s:l,s:l,s:l,s:l,s:N,s:N,s:N,s:N,s:B,s:B,s:B,s:B,s:B}",
		"Height", tm.tmHeight,
		"Ascent", tm.tmAscent,
		"Descent", tm.tmDescent,
		"InternalLeading", tm.tmInternalLeading,
		"ExternalLeading", tm.tmExternalLeading,
		"AveCharWidth", tm.tmAveCharWidth,
		"MaxCharWidth", tm.tmMaxCharWidth,
		"Weight", tm.tmWeight,
		"Overhang", tm.tmOverhang,
		"DigitizedAspectX", tm.tmDigitizedAspectX,
		"DigitizedAspectY", tm.tmDigitizedAspectY,
		"FirstChar", PyWinObject_FromWCHAR(&tm.tmFirstChar, 1),
		"LastChar", PyWinObject_FromWCHAR(&tm.tmLastChar, 1),
		"DefaultChar", PyWinObject_FromWCHAR(&tm.tmDefaultChar, 1),
		"BreakChar", PyWinObject_FromWCHAR(&tm.tmBreakChar, 1),
		"Italic", tm.tmItalic,
		"Underlined", tm.tmUnderlined,
		"StruckOut", tm.tmStruckOut,
		"PitchAndFamily", tm.tmPitchAndFamily,
		"CharSet", tm.tmCharSet); 
}

// @pyswig int|GetTextCharacterExtra|Returns the space between characters
static PyObject *PyGetTextCharacterExtra(PyObject *self, PyObject *args)
{
	HDC hdc;
	PyObject *obdc;
	int ret;
	if (!PyArg_ParseTuple(args, "O:GetTextCharacterExtra",
		&obdc))		// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	ret=GetTextCharacterExtra(hdc);
	if (ret==0x80000000)
		return PyWin_SetAPIError("GetTextCharacterExtra");
	return PyInt_FromLong(ret);
}

// @pyswig int|SetTextCharacterExtra|Sets the spacing between characters
// @rdesc Returns the previous spacing
static PyObject *PySetTextCharacterExtra(PyObject *self, PyObject *args)
{
	HDC hdc;
	PyObject *obdc;
	int newspacing, prevspacing;
	if (!PyArg_ParseTuple(args, "Oi:SetTextCharacterExtra",
		&obdc,			// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		&newspacing))	// @pyparm int|CharExtra||Space between adjacent chars, in logical units
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	prevspacing=SetTextCharacterExtra(hdc, newspacing);
	if (prevspacing==0x80000000)
		return PyWin_SetAPIError("SetTextCharacterExtra");
	return PyInt_FromLong(prevspacing);
}

// @pyswig int|GetTextAlign|Returns horizontal and vertical alignment for text in a device context
// @rdesc Returns combination of win32con.TA_* flags
static PyObject *PyGetTextAlign(PyObject *self, PyObject *args)
{
	HDC hdc;
	PyObject *obdc;
	int prevalign;
	if (!PyArg_ParseTuple(args, "O:GetTextAlign",
		&obdc))			// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	prevalign=GetTextAlign(hdc);
	if (prevalign==GDI_ERROR)
		return PyWin_SetAPIError("GetTextAlign");
	return PyInt_FromLong(prevalign);
}

// @pyswig int|SetTextAlign|Sets horizontal and vertical alignment for text in a device context
// @rdesc Returns the previous alignment flags
static PyObject *PySetTextAlign(PyObject *self, PyObject *args)
{
	HDC hdc;
	PyObject *obdc;
	int newalign, prevalign;
	if (!PyArg_ParseTuple(args, "Oi:SetTextAlign",
		&obdc,		// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		&newalign))	// @pyparm int|Mode||Combination of win32con.TA_* constants
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	prevalign=SetTextAlign(hdc, newalign);
	if (prevalign==GDI_ERROR)
		return PyWin_SetAPIError("SetTextAlign");
	return PyInt_FromLong(prevalign);
}

// @pyswig <o PyUnicode>|GetTextFace|Retrieves the name of the font currently selected in a DC
// @comm Calls unicode api function (GetTextFaceW)
static PyObject *PyGetTextFace(PyObject *self, PyObject *args)
{
	HDC hdc;
	PyObject *obdc;
	WCHAR face[256];
	int returned_size;
	if (!PyArg_ParseTuple(args, "O:GetTextFace",
		&obdc))		// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	returned_size=GetTextFaceW(hdc, 256, face);
	if (returned_size==0)
		return PyWin_SetAPIError("GetTextFace");
	// Char count includes trailing null
	return PyWinObject_FromWCHAR(face, returned_size-1);
}

// @pyswig int|GetMapMode|Returns the method a device context uses to translate logical units to physical units
// @rdesc Returns one of win32con.MM_* values
static PyObject *PyGetMapMode(PyObject *self, PyObject *args)
{
	HDC hdc;
	PyObject *obdc;
	int ret;
	if (!PyArg_ParseTuple(args, "O:GetMapMode",
		&obdc))		// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	ret=GetMapMode(hdc);
	if (ret==0)
		return PyWin_SetAPIError("GetMapMode");
	return PyInt_FromLong(ret);
}

// @pyswig int|SetMapMode|Sets the method used for translating logical units to device units
// @rdesc Returns the previous mapping mode, one of win32con.MM_* constants
static PyObject *PySetMapMode(PyObject *self, PyObject *args)
{
	HDC hdc;
	PyObject *obdc;
	int newmode, prevmode;
	if (!PyArg_ParseTuple(args, "Oi:SetMapMode",
		&obdc,			// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		&newmode))		// @pyparm int|MapMode||The new mapping mode (win32con.MM_*)
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	prevmode=SetMapMode(hdc, newmode);
	if (prevmode==0)
		return PyWin_SetAPIError("SetMapMode");
	return PyInt_FromLong(prevmode);
}

// @pyswig int|GetGraphicsMode|Determines if advanced GDI features are enabled for a device context
// @rdesc Returns GM_COMPATIBLE or GM_ADVANCED 
static PyObject *PyGetGraphicsMode(PyObject *self, PyObject *args)
{
	HDC hdc;
	PyObject *obdc;
	int ret;
	if (!PyArg_ParseTuple(args, "O:GetGraphicsMode",
		&obdc))		// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	ret=GetGraphicsMode(hdc);
	if (ret==0)
		return PyWin_SetAPIError("GetGraphicsMode");
	return PyInt_FromLong(ret);
}

// @pyswig int|SetGraphicsMode|Enables or disables advanced graphics features for a DC
// @rdesc Returns the previous mode, one of win32con.GM_COMPATIBLE or win32con.GM_ADVANCED 
static PyObject *PySetGraphicsMode(PyObject *self, PyObject *args)
{
	HDC hdc;
	PyObject *obdc;
	int newmode, prevmode;
	if (!PyArg_ParseTuple(args, "Oi:SetGraphicsMode",
		&obdc,			// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		&newmode))		// @pyparm int|Mode||GM_COMPATIBLE or GM_ADVANCED (from win32con)
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	prevmode=SetGraphicsMode(hdc, newmode);
	if (prevmode==0)
		return PyWin_SetAPIError("SetGraphicsMode");
	return PyInt_FromLong(prevmode);
}

// @pyswig int|GetLayout|Retrieves the layout mode of a device context
// @rdesc Returns one of win32con.LAYOUT_*
static PyObject *PyGetLayout(PyObject *self, PyObject *args)
{
	CHECK_PFN(GetLayout);
	HDC hdc;
	PyObject *obdc;
	DWORD prevlayout;
	if (!PyArg_ParseTuple(args, "O:GetLayout",
		&obdc))			// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	prevlayout=(*pfnGetLayout)(hdc);
	if (prevlayout==GDI_ERROR)
		return PyWin_SetAPIError("GetLayout");
	return PyLong_FromUnsignedLong(prevlayout);
}

// @pyswig int|SetLayout|Sets the layout for a device context
// @rdesc Returns the previous layout mode
static PyObject *PySetLayout(PyObject *self, PyObject *args)
{
	CHECK_PFN(SetLayout);
	HDC hdc;
	PyObject *obdc;
	DWORD newlayout, prevlayout;
	if (!PyArg_ParseTuple(args, "Ok:SetLayout",
		&obdc,			// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		&newlayout))	// @pyparm int|Layout||One of win32con.LAYOUT_* constants
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	prevlayout=(*pfnSetLayout)(hdc, newlayout);
	if (prevlayout==GDI_ERROR)
		return PyWin_SetAPIError("SetLayout");
	return PyLong_FromUnsignedLong(prevlayout);
}

// @pyswig int|GetPolyFillMode|Returns the polygon filling mode for a device context
// @rdesc Returns win32con.ALTERNATE or win32con.WINDING 
static PyObject *PyGetPolyFillMode(PyObject *self, PyObject *args)
{
	HDC hdc;
	PyObject *obdc;
	int ret;
	if (!PyArg_ParseTuple(args, "O:GetPolyFillMode",
		&obdc))		// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	ret=GetPolyFillMode(hdc);
	if (ret==0)
		return PyWin_SetAPIError("GetPolyFillMode");
	return PyInt_FromLong(ret);
}

// @pyswig int|SetPolyFillMode|Sets the polygon filling mode for a device context
// @rdesc Returns the previous mode, one of win32con.ALTERNATE or win32con.WINDING 
static PyObject *PySetPolyFillMode(PyObject *self, PyObject *args)
{
	HDC hdc;
	PyObject *obdc;
	int newmode, prevmode;
	if (!PyArg_ParseTuple(args, "Oi:SetPolyFillMode",
		&obdc,			// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		&newmode))		// @pyparm int|PolyFillMode||One of ALTERNATE or WINDING 
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	prevmode=SetPolyFillMode(hdc, newmode);
	if (prevmode==0)
		return PyWin_SetAPIError("SetPolyFillMode");
	return PyInt_FromLong(prevmode);
}

// @object PyXFORM|Dict representing an XFORM struct used as a world transformation matrix
//	All members are optional, defaulting to 0.0.
// @pyseeapi XFORM struct
BOOL PyWinObject_AsXFORM(PyObject *obxform, XFORM *pxform)
{
	static char *keywords[]={"M11","M12","M21","M22","Dx","Dy", NULL};
	ZeroMemory(pxform, sizeof(XFORM));
	if (!PyDict_Check(obxform)){
		PyErr_SetString(PyExc_TypeError,"XFORM must be a dict");
		return FALSE;
		}
	PyObject *dummy_tuple=PyTuple_New(0);
	if (dummy_tuple==NULL)
		return FALSE;
	BOOL ret=PyArg_ParseTupleAndKeywords(dummy_tuple, obxform, "|ffffff", keywords,
		&pxform->eM11,	// @prop float|M11|Usage is dependent on operation performed, see MSDN docs
		&pxform->eM12,	// @prop float|M12|Usage is dependent on operation performed, see MSDN docs
		&pxform->eM21,	// @prop float|M21|Usage is dependent on operation performed, see MSDN docs
		&pxform->eM22,	// @prop float|M22|Usage is dependent on operation performed, see MSDN docs
		&pxform->eDx,	// @prop float|Dx|Horizontal offset in logical units
		&pxform->eDy);	// @prop float|Dy|Vertical offset in logical units
	Py_DECREF(dummy_tuple);
	return ret;
}

PyObject *PyWinObject_FromXFORM(XFORM *pxform)
{
	return Py_BuildValue("{s:f,s:f,s:f,s:f,s:f,s:f}",
		"M11",	pxform->eM11,
		"M12",	pxform->eM12,
		"M21",	pxform->eM21,
		"M22",	pxform->eM22,
		"Dx",	pxform->eDx,
		"Dy",	pxform->eDy);
}

// @pyswig <o PyXFORM>|GetWorldTransform|Retrieves a device context's coordinate space translation matrix
// @comm DC's mode must be set to GM_ADVANCED.  See <om win32gui.SetGraphicsMode>.
static PyObject *PyGetWorldTransform(PyObject *self, PyObject *args)
{
	CHECK_PFN(GetWorldTransform);
	PyObject *obdc;
	HDC hdc;
	XFORM xform;
	if (!PyArg_ParseTuple(args, "O:GetWorldTransform",
		&obdc))		// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	if (!(*pfnGetWorldTransform)(hdc, &xform))
		return PyWin_SetAPIError("GetWorldTransform");
	return PyWinObject_FromXFORM(&xform);
}

// @pyswig |SetWorldTransform|Transforms a device context's coordinate space
// @comm DC's mode must be set to GM_ADVANCED.  See <om win32gui.SetGraphicsMode>.
static PyObject *PySetWorldTransform(PyObject *self, PyObject *args)
{
	CHECK_PFN(SetWorldTransform);
	PyObject *obdc, *obxform;
	HDC hdc;
	XFORM xform;
	if (!PyArg_ParseTuple(args, "OO:SetWorldTransform",
		&obdc,		// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		&obxform))	// @pyparm <o PyXFORM>|Xform||Matrix defining the transformation
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	if (!PyWinObject_AsXFORM(obxform, &xform))
		return NULL;
	if (!(*pfnSetWorldTransform)(hdc, &xform))
		return PyWin_SetAPIError("SetWorldTransform");
	Py_INCREF(Py_None);
	return Py_None;
}

// @pyswig |ModifyWorldTransform|Combines a coordinate tranformation with device context's current transformation
// @comm DC's mode must be set to GM_ADVANCED.  See <om win32gui.SetGraphicsMode>.
static PyObject *PyModifyWorldTransform(PyObject *self, PyObject *args)
{
	CHECK_PFN(ModifyWorldTransform);
	PyObject *obdc, *obxform;
	HDC hdc;
	XFORM xform;
	DWORD mode;
	if (!PyArg_ParseTuple(args, "OOk:ModifyWorldTransform",
		&obdc,		// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		&obxform,	// @pyparm <o PyXFORM>|Xform||Transformation to be applied.  Ignored if Mode is MWT_IDENTITY.
		&mode))		// @pyparm int|Mode||One of win32con.MWT_* values specifying how transformations will be combined
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	if (!PyWinObject_AsXFORM(obxform, &xform))
		return NULL;
	if (!(*pfnModifyWorldTransform)(hdc, &xform, mode))
		return PyWin_SetAPIError("ModifyWorldTransform");
	Py_INCREF(Py_None);
	return Py_None;
}

// @pyswig <o PyXFORM>|CombineTransform|Combines two coordinate space transformations
static PyObject *PyCombineTransform(PyObject *self, PyObject *args)
{
	CHECK_PFN(CombineTransform);
	PyObject *obxform1, *obxform2;
	XFORM xform1, xform2, ret_xform;
	if (!PyArg_ParseTuple(args, "OO:CombineTransform",
		&obxform1,		// @pyparm <o PyXFORM>|xform1||First transformation
		&obxform2))		// @pyparm <o PyXFORM>|xform2||Second transformation
		return NULL;
	if (!PyWinObject_AsXFORM(obxform1, &xform1))
		return NULL;
	if (!PyWinObject_AsXFORM(obxform2, &xform2))
		return NULL;

	if (!(*pfnCombineTransform)(&ret_xform, &xform1, &xform2))
		return PyWin_SetAPIError("CombineTransform");
	return PyWinObject_FromXFORM(&ret_xform);
}

PyObject *PyWinObject_FromSIZE(PSIZE psize)
{
	return Py_BuildValue("ll", psize->cx, psize->cy);
}

// @pyswig (int,int)|GetWindowExtEx|Retrieves the window extents for a DC
// @rdesc Returns the extents as (x,y) in logical units
static PyObject *PyGetWindowExtEx(PyObject *self, PyObject *args)
{
	PyObject *obdc;
	HDC hdc;
	SIZE sz;
	if (!PyArg_ParseTuple(args, "O:GetWindowExtEx",
		&obdc))		// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	if (!GetWindowExtEx(hdc, &sz))
		return PyWin_SetAPIError("GetWindowExtEx");
	return PyWinObject_FromSIZE(&sz);
}

// @pyswig (int,int)|SetWindowExtEx|Changes the window extents for a DC
// @rdesc Returns the previous extents
static PyObject *PySetWindowExtEx(PyObject *self, PyObject *args)
{
	PyObject *obdc;
	HDC hdc;
	SIZE sz;
	int x,y;
	if (!PyArg_ParseTuple(args, "Oii:SetWindowExtEx",
		&obdc,		// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		&x,			// @pyparm int|XExtent||New X extent in logical units
		&y))		// @pyparm int|YExtent||New Y extent in logical units
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	if (!SetWindowExtEx(hdc, x, y, &sz))
		return PyWin_SetAPIError("SetWindowExtEx");
	return PyWinObject_FromSIZE(&sz);
}

// @pyswig (int,int)|GetViewportExtEx|Retrieves the viewport extents for a DC
// @rdesc Returns the extents as (x,y) in logical units
static PyObject *PyGetViewportExtEx(PyObject *self, PyObject *args)
{
	PyObject *obdc;
	HDC hdc;
	SIZE sz;
	if (!PyArg_ParseTuple(args, "O:GetViewportExtEx",
		&obdc))		// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	if (!GetViewportExtEx(hdc, &sz))
		return PyWin_SetAPIError("GetViewportExtEx");
	return PyWinObject_FromSIZE(&sz);
}

// @pyswig (int,int)|SetViewportExtEx|Changes the viewport extents for a DC
// @rdesc Returns the previous extents as (x,y) in logical units
static PyObject *PySetViewportExtEx(PyObject *self, PyObject *args)
{
	PyObject *obdc;
	HDC hdc;
	SIZE sz;
	int x,y;
	if (!PyArg_ParseTuple(args, "Oii:SetViewportExtEx",
		&obdc,		// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		&x,			// @pyparm int|XExtent||New X extent in logical units
		&y))		// @pyparm int|YExtent||New Y extent in logical units
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	if (!SetViewportExtEx(hdc, x, y, &sz))
		return PyWin_SetAPIError("SetViewportExtEx");
	return PyWinObject_FromSIZE(&sz);
}

// @object PyTRIVERTEX|Dict representing a TRIVERTEX struct containing color information at a point
// @pyseeapi TRIVERTEX
BOOL PyWinObject_AsTRIVERTEX(PyObject *obtv, TRIVERTEX *ptv)
{
	static char *keywords[]={"x","y","Red","Green","Blue","Alpha", NULL};
	if (!PyDict_Check(obtv)){
		PyErr_SetString(PyExc_TypeError,"TRIVERTEX must be a dict");
		return FALSE;
		}
	PyObject *dummy_tuple=PyTuple_New(0);
	if (dummy_tuple==NULL)
		return FALSE;
	BOOL ret=PyArg_ParseTupleAndKeywords(dummy_tuple, obtv, "llHHHH", keywords,
		&ptv->x,		// @prop int|x|X coord in logical units
		&ptv->y,		// @prop int|y|Y coord in logical units
		&ptv->Red,		// @prop int|Red|Red component
		&ptv->Green,	// @prop int|Green|Green component
		&ptv->Blue,		// @prop int|Blue|Blue component
		&ptv->Alpha);	// @prop int|Alpha|Transparency value
	Py_DECREF(dummy_tuple);
	return ret;
}

BOOL PyWinObject_AsTRIVERTEXArray(PyObject *obtvs, TRIVERTEX **ptvs, DWORD *item_cnt)
{
	BOOL ret=TRUE;
	DWORD bufsize, tuple_index;
	PyObject *trivertex_tuple=NULL, *tuple_item;
	*ptvs=NULL;
	*item_cnt=0;

	if ((trivertex_tuple=PyWinSequence_Tuple(obtvs, item_cnt))==NULL)
		return FALSE;
	bufsize=*item_cnt * sizeof(TRIVERTEX);
	*ptvs=(TRIVERTEX *)malloc(bufsize);
	if (*ptvs==NULL){
		PyErr_Format(PyExc_MemoryError, "Unable to allocate %d bytes", bufsize);
		ret=FALSE;
		}
	else
		for (tuple_index=0; tuple_index<*item_cnt; tuple_index++){
			tuple_item=PyTuple_GET_ITEM(trivertex_tuple,tuple_index);
			if (!PyWinObject_AsTRIVERTEX(tuple_item, &(*ptvs)[tuple_index])){
				ret=FALSE;
				break;
				}
			}
	if (!ret)
		if (*ptvs!=NULL){
			free(*ptvs);
			*ptvs=NULL;
			*item_cnt=0;
			}
	Py_XDECREF(trivertex_tuple);
	return ret;
}

BOOL PyWinObject_AsMeshArray(PyObject *obmesh, ULONG mode, void **pmesh, DWORD *item_cnt)
{
	BOOL ret=TRUE, triangle;
	DWORD bufsize, tuple_index;
	PyObject *mesh_tuple=NULL, *tuple_item;
	*pmesh=NULL;
	*item_cnt=0;

	if ((mesh_tuple=PyWinSequence_Tuple(obmesh, item_cnt))==NULL)
		return FALSE;
	switch (mode){
		case GRADIENT_FILL_TRIANGLE:
			bufsize=*item_cnt * sizeof(GRADIENT_TRIANGLE);
			triangle=TRUE;
			break;
		case GRADIENT_FILL_RECT_H:
		case GRADIENT_FILL_RECT_V:
			bufsize=*item_cnt * sizeof(GRADIENT_RECT);
			triangle=FALSE;
			break;
		default:
			PyErr_Format(PyExc_ValueError,"Unrecognized value for gradient fill mode: %d", mode);
			return FALSE;
		}

	*pmesh=malloc(bufsize);
	if (*pmesh==NULL){
		PyErr_Format(PyExc_MemoryError, "Unable to allocate %d bytes", bufsize);
		ret=FALSE;
		}
	else
		for (tuple_index=0; tuple_index<*item_cnt; tuple_index++){
			tuple_item=PyTuple_GET_ITEM(mesh_tuple,tuple_index);
			if (!PyTuple_Check(tuple_item)){
				PyErr_SetString(PyExc_TypeError,"Mesh elements must be tuples of 2 or 3 ints");
				ret=FALSE;
				break;
				}
			if (triangle){
				if (!PyArg_ParseTuple(tuple_item, "kkk:GRADIENT_TRIANGLE",
					&((GRADIENT_TRIANGLE *)(*pmesh))[tuple_index].Vertex1,
					&((GRADIENT_TRIANGLE *)(*pmesh))[tuple_index].Vertex2,
					&((GRADIENT_TRIANGLE *)(*pmesh))[tuple_index].Vertex3)){
					ret=FALSE;
					break;
					}
				}
			else
				if (!PyArg_ParseTuple(tuple_item, "kk:GRADIENT_RECT", 
					&((GRADIENT_RECT *)(*pmesh))[tuple_index].UpperLeft,
					&((GRADIENT_RECT *)(*pmesh))[tuple_index].LowerRight)){
					ret=FALSE;
					break;
					}
			}
	if (!ret)
		if (*pmesh!=NULL){
			free(*pmesh);
			*pmesh=NULL;
			*item_cnt=0;
			}
	Py_XDECREF(mesh_tuple);
	return ret;
}

// @pyswig |GradientFill|Shades triangles or rectangles by interpolating between vertex colors
static PyObject *PyGradientFill(PyObject *self, PyObject *args)
{
	CHECK_PFN(GradientFill);
	HDC hdc;
	PTRIVERTEX ptv=NULL;
	ULONG tv_cnt, mesh_cnt, mode;
	PVOID pmesh=NULL;
	BOOL bres;
	PyObject *obdc, *obtvs, *obmesh, *ret=NULL;
	if (!PyArg_ParseTuple(args, "OOOk:GradientFill",
		&obdc,		// @pyparm int|hdc||Handle to device context
		&obtvs,		// @pyparm (<o PyTRIVERTEX>,...)|Vertex||Sequence of TRIVERTEX dicts defining color info
		&obmesh,	// @pyparm tuple|Mesh||Sequence of tuples containing either 2 or 3 ints that index into the trivertex array to define either triangles or rectangles
		&mode))		// @pyparm int|Mode||win32con.GRADIENT_FILL_* value defining whether to fill by triangle or by rectangle
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	if (!PyWinObject_AsTRIVERTEXArray(obtvs, &ptv, &tv_cnt))
		goto cleanup;
	if (!PyWinObject_AsMeshArray(obmesh, mode, &pmesh, &mesh_cnt))
		goto cleanup;
	Py_BEGIN_ALLOW_THREADS
	bres=(*pfnGradientFill)(hdc, ptv, tv_cnt, pmesh, mesh_cnt, mode);
	Py_END_ALLOW_THREADS
	if (!bres)
		PyWin_SetAPIError("GradientFill");
	else{
		Py_INCREF(Py_None);
		ret=Py_None;
		}
	cleanup:
	if (ptv)
		free(ptv);
	if (pmesh)
		free(pmesh);
	return ret;
}

PyObject *PySetMenuInfo(PyObject *self, PyObject *args)
{
	CHECK_PFN(SetMenuInfo);
	PyObject *obMenu, *obInfo;
	HMENU hmenu;
	Py_ssize_t cbInfo;
	MENUINFO *pInfo;
	BOOL result;
	// @pyparm int|hmenu||handle to menu
	// @pyparm <o MENUINFO>|info||menu information in the format of a buffer.
	if (!PyArg_ParseTuple(args, "OO", &obMenu, &obInfo))
		return NULL;

	if (!PyWinObject_AsHANDLE(obMenu, (HANDLE *)&hmenu))
		return NULL;

	if (0 != PyObject_AsReadBuffer(obInfo, (const void **)&pInfo, &cbInfo))
		return NULL;
	if (sizeof MENUINFO != cbInfo)
		return PyErr_Format(PyExc_TypeError, "Argument must be a %d byte string/buffer (got %d bytes)", sizeof MENUINFO, cbInfo);

	Py_BEGIN_ALLOW_THREADS
	result = (*pfnSetMenuInfo)(hmenu, pInfo);
	Py_END_ALLOW_THREADS
	if (!result)
		return PyWin_SetAPIError("SetMenuInfo");
	Py_INCREF(Py_None);
	return Py_None;
}

PyObject *PyGetMenuInfo(PyObject *self, PyObject *args)
{
	CHECK_PFN(GetMenuInfo);
	PyObject *obMenu, *obInfo;
	HMENU hmenu;
	Py_ssize_t cbInfo;
	MENUINFO *pInfo;
	BOOL result;
	// @pyparm int|hmenu||handle to menu
	// @pyparm buffer|info||A buffer to fill with the information.
	if (!PyArg_ParseTuple(args, "OO", &obMenu, &obInfo))
		return NULL;

	if (!PyWinObject_AsHANDLE(obMenu, (HANDLE *)&hmenu))
		return NULL;

	if (0 != PyObject_AsWriteBuffer(obInfo, (void **)&pInfo, &cbInfo))
		return NULL;
	if (sizeof MENUINFO != cbInfo)
		return PyErr_Format(PyExc_TypeError, "Argument must be a %d byte buffer (got %d bytes)", sizeof MENUINFO, cbInfo);

	Py_BEGIN_ALLOW_THREADS
	result = (*pfnGetMenuInfo)(hmenu, pInfo);
	Py_END_ALLOW_THREADS
	if (!result)
		return PyWin_SetAPIError("GetMenuInfo");
	Py_INCREF(Py_None);
	return Py_None;
}

// @pyswig |AngleArc|Draws a line from current pos and a section of a circle's arc
static PyObject *PyAngleArc(PyObject *self, PyObject *args)
{
	CHECK_PFN(AngleArc);
	HDC hdc;
	int x,y;
	DWORD radius;
	FLOAT startangle, sweepangle;
	PyObject *obdc;
	if (!PyArg_ParseTuple(args, "Oiikff:AngleArc",
		&obdc,			// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		&x,				// @pyparm int|Y||x pos of circle
		&y,				// @pyparm int|Y||y pos of circle
		&radius,		// @pyparm int|Radius||Radius of circle
		&startangle,	// @pyparm float|StartAngle||Angle where arc starts, in degrees
		&sweepangle))	// @pyparm float|SweepAngle||Angle that arc covers, in degrees
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	if (!(*pfnAngleArc)(hdc, x, y, radius, startangle, sweepangle))
		return PyWin_SetAPIError("AngleArc");
	Py_INCREF(Py_None);
	return Py_None;
}

// @pyswig int|SetPixel|Set the color of a single pixel
// @rdesc Returns the RGB color actually set, which may be different from the one passed in
static PyObject *PySetPixel(PyObject *self, PyObject *args)
{
	PyObject *obdc;
	HDC hdc;
	int x,y;
	COLORREF color, ret;
	if (!PyArg_ParseTuple(args, "Oiik:SetPixel",
		&obdc,		// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		&x,			// @pyparm int|X||Horizontal pos
		&y,			// @pyparm int|Y||Vertical pos
		&color))	// @pyparm int|Color||RGB color to be set.
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	ret=SetPixel(hdc, x, y, color);
	if (ret==CLR_INVALID)
		return PyWin_SetAPIError("SetPixel");
	return PyLong_FromUnsignedLong(ret);
}

// @pyswig int|GetPixel|Returns the RGB color of a single pixel
static PyObject *PyGetPixel(PyObject *self, PyObject *args)
{
	PyObject *obdc;
	HDC hdc;
	int x,y;
	COLORREF ret;
	if (!PyArg_ParseTuple(args, "Oii:GetPixel",
		&obdc,		// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		&x,			// @pyparm int|XPos||Horizontal pos
		&y))		// @pyparm int|YPos||Vertical pos
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	ret=GetPixel(hdc, x, y);
	if (ret==CLR_INVALID)
		return PyWin_SetAPIError("GetPixel");
	return PyLong_FromUnsignedLong(ret);
}

// @pyswig int|GetROP2|Returns the foreground mixing mode of a DC
// @rdesc Returns one of win32con.R2_* values
static PyObject *PyGetROP2(PyObject *self, PyObject *args)
{
	PyObject *obdc;
	HDC hdc;
	int ret;
	if (!PyArg_ParseTuple(args, "O:GetROP2",
		&obdc))		// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	ret=GetROP2(hdc);
	if (ret==0)
		return PyWin_SetAPIError("GetROP2");
	return PyInt_FromLong(ret);
}

// @pyswig int|SetROP2|Sets the foreground mixing mode of a DC
// @rdesc Returns previous mode
static PyObject *PySetROP2(PyObject *self, PyObject *args)
{
	PyObject *obdc;
	HDC hdc;
	int newmode, oldmode;
	if (!PyArg_ParseTuple(args, "Oi:SetROP2",
		&obdc,		// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		&newmode))	// @pyparm int|DrawMode||Mixing mode, one of win32con.R2_*.
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	oldmode=SetROP2(hdc, newmode);
	if (oldmode==0)
		return PyWin_SetAPIError("SetROP2");
	return PyInt_FromLong(oldmode);
}

BOOL PyWinObject_AsPOINTArray(PyObject *obpoints, POINT **ppoints, DWORD *item_cnt)
{
	BOOL ret=TRUE;
	DWORD bufsize, tuple_index;
	PyObject *points_tuple=NULL, *tuple_item;
	*ppoints=NULL;
	*item_cnt=0;

	if ((points_tuple=PyWinSequence_Tuple(obpoints, item_cnt))==NULL)
		return FALSE;

	bufsize=*item_cnt * sizeof(POINT);
	*ppoints=(POINT *)malloc(bufsize);
	if (*ppoints==NULL){
		PyErr_Format(PyExc_MemoryError, "Unable to allocate %d bytes", bufsize);
		ret=FALSE;
		}
	else
		for (tuple_index=0; tuple_index<*item_cnt; tuple_index++){
			tuple_item=PyTuple_GET_ITEM(points_tuple,tuple_index);
			if (!PyWinObject_AsPOINT(tuple_item, &(*ppoints)[tuple_index])){
				ret=FALSE;
				break;
				}
			}
	if (!ret)
		if (*ppoints!=NULL){
			free(*ppoints);
			*ppoints=NULL;
			*item_cnt=0;
			}
	Py_XDECREF(points_tuple);
	return ret;
}

// @pyswig |Polygon|Draws a closed filled polygon defined by a sequence of points
static PyObject *PyPolygon(PyObject *self, PyObject *args)
{
	HDC hdc;
	POINT *points=NULL;
	DWORD point_cnt;
	PyObject *obpoints, *obdc, *ret=NULL;
	if (!PyArg_ParseTuple(args, "OO:PolyGon",
		&obdc,		// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		&obpoints))	// @pyparm [(int,int),...]|Points||Sequence of POINT tuples: ((x,y),...)
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	if (!PyWinObject_AsPOINTArray(obpoints, &points, &point_cnt))
		return NULL;
	if (!Polygon(hdc, points, point_cnt))
		PyWin_SetAPIError("PolyGon");
	else{
		Py_INCREF(Py_None);
		ret=Py_None;
		}
	if (points)
		free(points);
	return ret;
}

// @pyswig |Polyline|Connects a sequence of points using currently selected pen
static PyObject *PyPolyline(PyObject *self, PyObject *args)
{
	HDC hdc;
	POINT *points=NULL;
	DWORD point_cnt;
	PyObject *obpoints, *obdc, *ret=NULL;
	if (!PyArg_ParseTuple(args, "OO:Polyline", 
		&obdc,		// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		&obpoints))	// @pyparm [(int,int),...]|Points||Sequence of POINT tuples: ((x,y),...)
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	if (!PyWinObject_AsPOINTArray(obpoints, &points, &point_cnt))
		return NULL;
	if (!Polyline(hdc, points, point_cnt))
		PyWin_SetAPIError("Polyline");
	else{
		Py_INCREF(Py_None);
		ret=Py_None;
		}
	if (points)
		free(points);
	return ret;
}

// @pyswig |PolylineTo|Draws a series of lines starting from current position.  Updates current position with end point.
static PyObject *PyPolylineTo(PyObject *self, PyObject *args)
{
	HDC hdc;
	POINT *points=NULL;
	DWORD point_cnt;
	PyObject *obpoints, *obdc, *ret=NULL;
	if (!PyArg_ParseTuple(args, "OO:PolylineTo", 
		&obdc,		// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		&obpoints))	// @pyparm [(int,int),...]|Points||Sequence of POINT tuples: ((x,y),...)
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	if (!PyWinObject_AsPOINTArray(obpoints, &points, &point_cnt))
		return NULL;
	if (!PolylineTo(hdc, points, point_cnt))
		PyWin_SetAPIError("PolylineTo");
	else{
		Py_INCREF(Py_None);
		ret=Py_None;
		}
	if (points)
		free(points);
	return ret;
}

// @pyswig |PolyBezier|Draws a series of Bezier curves starting from first point specified.
// @comm Number of points must be a multiple of 3 plus 1.
static PyObject *PyPolyBezier(PyObject *self, PyObject *args)
{
	HDC hdc;
	POINT *points=NULL;
	DWORD point_cnt;
	PyObject *obpoints, *obdc, *ret=NULL;
	if (!PyArg_ParseTuple(args, "OO:PolyBezier", 
		&obdc,		// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		&obpoints))	// @pyparm [(int,int),...]|Points||Sequence of POINT tuples: ((x,y),...).
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	if (!PyWinObject_AsPOINTArray(obpoints, &points, &point_cnt))
		return NULL;
	if (!PolyBezier(hdc, points, point_cnt))
		PyWin_SetAPIError("PolyBezier");
	else{
		Py_INCREF(Py_None);
		ret=Py_None;
		}
	if (points)
		free(points);
	return ret;
}

// @pyswig |PolyBezierTo|Draws a series of Bezier curves starting from current drawing position.
// @comm Points must contain 3 points for each curve.  Current position is updated with last endpoint.
static PyObject *PyPolyBezierTo(PyObject *self, PyObject *args)
{
	HDC hdc;
	POINT *points=NULL;
	DWORD point_cnt;
	PyObject *obpoints, *obdc, *ret=NULL;
	if (!PyArg_ParseTuple(args, "OO:PolyBezierTo", 
		&obdc,		// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		&obpoints))	// @pyparm [(int,int),...]|Points||Sequence of POINT tuples: ((x,y),...).
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	if (!PyWinObject_AsPOINTArray(obpoints, &points, &point_cnt))
		return NULL;
	if (!PolyBezierTo(hdc, points, point_cnt))
		PyWin_SetAPIError("PolyBezierTo");
	else{
		Py_INCREF(Py_None);
		ret=Py_None;
		}
	if (points)
		free(points);
	return ret;
}

// @pyswig |PlgBlt|Copies color from a rectangle into a parallelogram
static PyObject *PyPlgBlt(PyObject *self, PyObject *args)
{
	CHECK_PFN(PlgBlt);
	HDC srcdc, dstdc;
	POINT *points=NULL;
	int x, y, width, height, xmask=0, ymask=0;
	DWORD point_cnt;
	HBITMAP mask;
	PyObject *obsrc, *obdst, *obmask=Py_None, *obpoints, *ret=NULL;
	if (!PyArg_ParseTuple(args, "OOOiiii|Oii:PlgBlt",
		&obdst,		// @pyparm <o PyHANDLE>|Dest||Destination DC
		&obpoints,	// @pyparm tuple|Point||Sequence of 3 POINT tuples (x,y) describing a paralellogram
		&obsrc,		// @pyparm <o PyHANDLE>|Src||Source device context
		&x,			// @pyparm int|XSrc||Left edge of source rectangle
		&y,			// @pyparm int|YSrc||Top of source rectangle
		&width,		// @pyparm int|Width||Width of source rectangle
		&height,	// @pyparm int|Height||Height of source rectangle
		&obmask,	// @pyparm <o PyGdiHANDLE>|Mask|None|Handle to monochrome bitmap to mask source, can be None
		&xmask,		// @pyparm int|xMask|0|x pos in mask
		&ymask))	// @pyparm int|yMask|0|y pos in mask
		return NULL;
	if (!PyWinObject_AsHANDLE(obdst, (HANDLE *)&dstdc))
		return NULL;
	if (!PyWinObject_AsHANDLE(obsrc, (HANDLE *)&srcdc))
		return NULL;
	if (!PyWinObject_AsHANDLE(obmask, (HANDLE *)&mask))
		return NULL;
	if (!PyWinObject_AsPOINTArray(obpoints, &points, &point_cnt))
		return NULL;
	if (point_cnt!=3)
		PyErr_SetString(PyExc_ValueError, "Points must contain exactly 3 points.");
	else if (!(*pfnPlgBlt)(dstdc, points, srcdc, x, y, width, height, mask, xmask, ymask))
		PyWin_SetAPIError("PlgBlt");
	else{
		Py_INCREF(Py_None);
		ret=Py_None;
		}
	free(points);
	return ret;
}

// @pyswig <o PyGdiHANDLE>|CreatePolygonRgn|Creates a region from a sequence of vertices
static PyObject *PyCreatePolygonRgn(PyObject *self, PyObject *args)
{
	POINT *points=NULL;
	DWORD point_cnt;
	int fillmode;
	PyObject *obpoints, *ret=NULL;
	HRGN hrgn;
	if (!PyArg_ParseTuple(args, "Oi:CreatePolygonRgn",
		&obpoints,	// @pyparm [(int,int),...]|Points||Sequence of POINT tuples: ((x,y),...).
		&fillmode))	// @pyparm int|PolyFillMode||Filling mode, one of ALTERNATE, WINDING 
		return NULL;
	if (!PyWinObject_AsPOINTArray(obpoints, &points, &point_cnt))
		return NULL;
	hrgn=CreatePolygonRgn(points, point_cnt, fillmode);
	if (hrgn==NULL)
		PyWin_SetAPIError("CreatePolygonRgn");
	else
		ret=PyWinObject_FromGdiHANDLE(hrgn);
	if (points)
		free(points);
	return ret;
}

//@pyswig int|ExtTextOut|Writes text to a DC.
static PyObject *PyExtTextOut(PyObject *self, PyObject *args)
{
	TCHAR *text=NULL;
	int x, y;
	DWORD strLen;
	UINT options;
	PyObject *obdc, *rectObject, *obtext, *widthObject = Py_None;
	RECT rect, *rectPtr;
	int *widths = NULL;
	HDC hdc;
	if (!PyArg_ParseTuple (args, "OiiiOO|O:ExtTextOut",
		&obdc,	// @pyparm <o PyHANDLE>|hdc||Handle to a device context
		&x,		// @pyparm x|int||The x coordinate to write the text to.
		&y,		// @pyparm y|int||The y coordinate to write the text to.
		&options,	// @pyparm nOptions|int||Specifies the rectangle type. This parameter can be one, both, or neither of ETO_CLIPPED and ETO_OPAQUE
		&rectObject,	// @pyparm <o PyRECT>|rect||Specifies the text's bounding rectangle.  (Can be None.)
		&obtext,	// @pyparm text|string||The text to write.
		&widthObject))	// @pyparm (width1, width2, ...)|tuple||Optional array of values that indicate distance between origins of character cells.
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	// Parse out rectangle object
	if (rectObject != Py_None) {
		if (!PyArg_ParseTuple(rectObject, "iiii", &rect.left,
			&rect.top, &rect.right, &rect.bottom))
			return NULL;
		rectPtr = &rect;
	}
	else
		rectPtr = NULL;

	if (!PyWinObject_AsTCHAR(obtext, &text, FALSE, &strLen))
		return NULL;

	// Parse out widths
	if (widthObject != Py_None) {
		BOOL error = !PyTuple_Check(widthObject);
		if (!error) {
			Py_ssize_t len = PyTuple_Size(widthObject);
			if (len == (strLen - 1)) {
				widths = new int[len + 1];
				for (int i = 0; i < len; i++) {
					PyObject *item = PyTuple_GetItem(widthObject, i);
					if (!PyInt_Check(item))
						error = TRUE;
					else 
						widths[i] = PyInt_AsLong(item);
				}
			}
		}
		if (error) {
			PyWinObject_FreeTCHAR(text);
			delete [] widths;
			return PyErr_Format(PyExc_TypeError,
			                    "The width param must be a tuple of integers with a length one less than that of the string");
		}
	}

	BOOL ok;
	Py_BEGIN_ALLOW_THREADS;
	// @pyseeapi ExtTextOut
	ok = ExtTextOut(hdc, x, y, options, rectPtr, text, strLen, widths);
	Py_END_ALLOW_THREADS;
	PyWinObject_FreeTCHAR(text);
	delete [] widths;
	if (!ok)
		return PyWin_SetAPIError("ExtTextOut");
	Py_INCREF(Py_None);
	return Py_None;
	// @rdesc Always none.  If the function fails, an exception is raised.
}


// @pyswig tuple,tuple|GetPath|Returns a sequence of points that describe the current path
// @rdesc Returns a sequence of POINT tuples, and a sequence of ints designating each point's function (combination of win32con.PT_* values)
static PyObject *PyGetPath(PyObject *self, PyObject *args)
{
	HDC hdc;
	POINT *points=NULL;
	BYTE *types=NULL;
	DWORD point_cnt=0, point_ind;
	PyObject *obpoints=NULL, *obtypes=NULL, *obdc, *ret=NULL;
	if (!PyArg_ParseTuple(args, "O:GetPath", 
		&obdc))		// @pyparm <o PyHANDLE>|hdc||Handle to a device context containing a finalized path.  See <om win32gui.EndPath>
		return NULL;
	if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&hdc))
		return NULL;
	point_cnt=GetPath(hdc, points, types, point_cnt);
	if (point_cnt==-1)
		return PyWin_SetAPIError("GetPath");

	points=(POINT *)malloc(point_cnt*sizeof(POINT));
	if (points==NULL){
		PyErr_Format(PyExc_MemoryError, "Unable to allocate %d bytes",point_cnt*sizeof(POINT));
		goto cleanup;
		}
	types=(BYTE *)malloc(point_cnt);
	if (types==NULL){
		PyErr_Format(PyExc_MemoryError, "Unable to allocate %d bytes",point_cnt);
		goto cleanup;
		}
	point_cnt=GetPath(hdc, points, types, point_cnt);
	if (point_cnt==-1){
		PyWin_SetAPIError("GetPath");
		goto cleanup;
		}
	obpoints=PyTuple_New(point_cnt);
	obtypes=PyTuple_New(point_cnt);
	if ((obpoints==NULL) || (obtypes==NULL))
		goto cleanup;
	for (point_ind=0; point_ind<point_cnt; point_ind++){
		PyObject *tuple_item=Py_BuildValue("ll", points[point_ind].x, points[point_ind].y);
		if (tuple_item==NULL)
			goto cleanup;
		PyTuple_SET_ITEM(obpoints, point_ind, tuple_item);
		tuple_item=PyInt_FromLong(types[point_ind]);
		if (tuple_item==NULL)
			goto cleanup;
		PyTuple_SET_ITEM(obtypes, point_ind, tuple_item);
		}
	ret=Py_BuildValue("OO", obpoints, obtypes);

	cleanup:
	Py_XDECREF(obpoints);
	Py_XDECREF(obtypes);
	if (points!=NULL)
		free(points);
	if (types!=NULL)
		free(types);
	return ret;
}


#define GUI_BGN_SAVE PyThreadState *_save = PyEval_SaveThread()
#define GUI_END_SAVE PyEval_RestoreThread(_save)
#define GUI_BLOCK_THREADS Py_BLOCK_THREADS
#define RETURN_NONE				do {Py_INCREF(Py_None);return Py_None;} while (0)
#define RETURN_ERR(err)			do {PyErr_SetString(ui_module_error,err);return NULL;} while (0)
#define RETURN_MEM_ERR(err)		do {PyErr_SetString(PyExc_MemoryError,err);return NULL;} while (0)
#define RETURN_TYPE_ERR(err)	do {PyErr_SetString(PyExc_TypeError,err);return NULL;} while (0)
#define RETURN_VALUE_ERR(err)	do {PyErr_SetString(PyExc_ValueError,err);return NULL;} while (0)
#define RETURN_API_ERR(fn) return ReturnAPIError(fn)

#define CHECK_NO_ARGS(args)		do {if (!PyArg_ParseTuple(args,"")) return NULL;} while (0)
#define CHECK_NO_ARGS2(args, fnName) do {if (!PyArg_ParseTuple(args,":"#fnName)) return NULL;} while (0)

// @object PySCROLLINFO|A tuple representing a SCROLLINFO structure
// @tupleitem 0|int|addnMask|Additional mask information.  Python automatically fills the mask for valid items, so currently the only valid values are zero, and win32con.SIF_DISABLENOSCROLL.
// @tupleitem 1|int|min|The minimum scrolling position.  Both min and max, or neither, must be provided.
// @tupleitem 2|int|max|The maximum scrolling position.  Both min and max, or neither, must be provided.
// @tupleitem 3|int|page|Specifies the page size. A scroll bar uses this value to determine the appropriate size of the proportional scroll box.
// @tupleitem 4|int|pos|Specifies the position of the scroll box.
// @tupleitem 5|int|trackPos|Specifies the immediate position of a scroll box that the user 
// is dragging. An application can retrieve this value while processing 
// the SB_THUMBTRACK notification message. An application cannot set 
// the immediate scroll position; the <om PyCWnd.SetScrollInfo> function ignores 
// this member.
// @comm When passed to Python, will always be a tuple of size 6, and items may be None if not available.
// @comm When passed from Python, it must have the addn mask attribute, but all other items may be None, or not exist.
BOOL ParseSCROLLINFOTuple( PyObject *args, SCROLLINFO *pInfo)
{
	static char *err_msg="SCROLLINFO must be a tuple of 1-6 ints";
	PyObject *obMin=Py_None, *obMax=Py_None, *obPage=Py_None, *obPos=Py_None, *obTrackPos=Py_None;
	Py_ssize_t len = PyTuple_Size(args);
	if (len<1 || len > 6) {
		PyErr_SetString(PyExc_TypeError, err_msg);
		return FALSE;
	}
	if (!PyArg_ParseTuple(args, "l|OOOOO", &pInfo->fMask, &obMin, &obMax, &obPage, &obPos, &obTrackPos)){
		PyErr_SetString(PyExc_TypeError, err_msg);
		return FALSE;
	}
	PyErr_Clear(); // clear any errors, so I can detect my own.
	// 1/2 - nMin/nMax
	if ((obMin==Py_None && obMax!=Py_None) || (obMin!=Py_None && obMax==Py_None)){
		PyErr_SetString(PyExc_TypeError, "SCROLLINFO - Both min and max, or neither, must be provided.");
		return FALSE;
	}
	if (obMin!=Py_None){
		if (((pInfo->nMin=PyInt_AsLong(obMin))==-1)&&PyErr_Occurred())
			return FALSE;
		if (((pInfo->nMax=PyInt_AsLong(obMax))==-1)&&PyErr_Occurred())
			return FALSE;
		pInfo->fMask |= SIF_RANGE;
	}
	if (obPage!=Py_None){
		if (((pInfo->nPage=PyInt_AsLong(obPage))==-1)&&PyErr_Occurred())
			return FALSE;
		pInfo->fMask |= SIF_PAGE;
	}
	if (obPos!=Py_None){
		if (((pInfo->nPos=PyInt_AsLong(obPos))==-1)&&PyErr_Occurred())
			return FALSE;
		pInfo->fMask |= SIF_POS;
	}
	if (obTrackPos!=Py_None){
		if (((pInfo->nTrackPos=PyInt_AsLong(obTrackPos))==-1)&&PyErr_Occurred())
			return FALSE;
		pInfo->fMask |= SIF_TRACKPOS;
	}
	return TRUE;
}

PyObject *MakeSCROLLINFOTuple(SCROLLINFO *pInfo)
{
	PyObject *ret = PyTuple_New(6);
	if (ret==NULL) return NULL;
	PyTuple_SET_ITEM(ret, 0, PyInt_FromLong(0));
	if (pInfo->fMask & SIF_RANGE) {
		PyTuple_SET_ITEM(ret, 1, PyInt_FromLong(pInfo->nMin));
		PyTuple_SET_ITEM(ret, 2, PyInt_FromLong(pInfo->nMax));
	} else {
		Py_INCREF(Py_None);
		Py_INCREF(Py_None);
		PyTuple_SET_ITEM(ret, 1, Py_None);
		PyTuple_SET_ITEM(ret, 2, Py_None);
	}
	if (pInfo->fMask & SIF_PAGE) {
		PyTuple_SET_ITEM(ret, 3, PyInt_FromLong(pInfo->nPage));
	} else {
		Py_INCREF(Py_None);
		PyTuple_SET_ITEM(ret, 3, Py_None);
	}
	if (pInfo->fMask & SIF_POS) {
		PyTuple_SET_ITEM(ret, 4, PyInt_FromLong(pInfo->nPos));
	} else {
		Py_INCREF(Py_None);
		PyTuple_SET_ITEM(ret, 4, Py_None);
	}
	PyTuple_SET_ITEM(ret, 5, PyInt_FromLong(pInfo->nTrackPos));
	return ret;
}

// @pyswig |SetScrollInfo|Sets information about a scroll-bar
// @rdesc  Returns an int with the current position of the scroll box.
static PyObject *PySetScrollInfo(PyObject *self, PyObject *args) {
	int nBar;
	HWND hwnd;
	BOOL bRedraw = TRUE;
	PyObject *obhwnd, *obInfo;

	// @pyparm int|hwnd||The handle to the window.
	// @pyparm int|nBar||Identifies the bar.
	// @pyparm <o PySCROLLINFO>|scollInfo||Scollbar info.
	// @pyparm int|bRedraw|1|Should the bar be redrawn?
	if (!PyArg_ParseTuple(args, "OiO|i:SetScrollInfo",
		&obhwnd, &nBar, &obInfo, &bRedraw))
		return NULL;
	if (!PyWinObject_AsHANDLE(obhwnd, (HANDLE *)&hwnd))
		return NULL;
	SCROLLINFO info;
	info.cbSize = sizeof(SCROLLINFO);
	if (ParseSCROLLINFOTuple(obInfo, &info) == 0)
		return NULL;

	GUI_BGN_SAVE;
	int rc = SetScrollInfo(hwnd, nBar, &info, bRedraw);
	GUI_END_SAVE;
	return PyInt_FromLong(rc);
}

// @pyswig <o PySCROLLINFO>|GetScrollInfo|Returns information about a scroll bar
static PyObject *
PyGetScrollInfo (PyObject *self, PyObject *args)
{
	HWND hwnd;
	PyObject *obhwnd;
	int nBar;
	UINT fMask = SIF_ALL;
	// @pyparm int|hwnd||The handle to the window.
	// @pyparm int|nBar||The scroll bar to examine.  Can be one of win32con.SB_CTL, win32con.SB_VERT or win32con.SB_HORZ
	// @pyparm int|mask|SIF_ALL|The mask for attributes to retrieve.
	if (!PyArg_ParseTuple(args, "Oi|i:GetScrollInfo", &obhwnd, &nBar, &fMask))
		return NULL;
	if (!PyWinObject_AsHANDLE(obhwnd, (HANDLE *)&hwnd))
		return NULL;
	SCROLLINFO info;
	info.cbSize = sizeof(SCROLLINFO);
	info.fMask = fMask;
	GUI_BGN_SAVE;
	BOOL ok = GetScrollInfo(hwnd, nBar, &info);
	GUI_END_SAVE;
	if (!ok) {
		PyWin_SetAPIError("GetScrollInfo");
		return NULL;
	}
	return MakeSCROLLINFOTuple(&info);
}

// @pyswig string|GetClassName|Retrieves the name of the class to which the specified window belongs. 
static PyObject *
PyGetClassName(PyObject *self, PyObject *args)
{
	HWND hwnd;
	PyObject *obhwnd;
	TCHAR buf[256];
	// @pyparm <o PyHANDLE>|hwnd||The handle to the window
	if (!PyArg_ParseTuple(args, "O:GetClassName", &obhwnd))
		return NULL;
	if (!PyWinObject_AsHANDLE(obhwnd, (HANDLE *)&hwnd))
		return NULL;
	// dont bother with lock - no callback possible.
	int nchars = GetClassName(hwnd, buf, sizeof buf/sizeof buf[0]);
	if (nchars==0)
		return PyWin_SetAPIError("GetClassName");
	return PyWinObject_FromTCHAR(buf, nchars);
}

// Callbacks
struct PySortCallback {
	PyObject *fn;
	PyObject *data;
};

int CALLBACK CompareFunc(); 

int CALLBACK CompareFunc(LPARAM lParam1, LPARAM lParam2, 
LPARAM lParamSort);

static int CALLBACK PySortFunc(
	LPARAM lParam1,
	LPARAM lParam2, 
	LPARAM lParamSort
    )
{
	int rc = 0;
	PyObject *result = NULL;
	PyObject *args = NULL;
	PyGILState_STATE state = PyGILState_Ensure();
	PySortCallback *pc = (PySortCallback *)lParamSort;
	if (!pc) {
		PySys_WriteStderr("Control sort function callback with no data!\n");
		goto done;
	}
	assert(!PyErr_Occurred());
	args = Py_BuildValue("llO", lParam1, lParam2, pc->data);
	if (!args) goto done;
	result = PyEval_CallObject(pc->fn, args);
	// API says must return 0, but there might be a good reason.
	if (!result) goto done;
	if (!PyInt_Check(result)) {
		PyErr_SetString(PyExc_TypeError, "The sort function must return an integer");
		goto done;
	}
	rc = PyInt_AsLong(result);
done:
	if (PyErr_Occurred())
		HandleError("ListView sort callback failed!");
	Py_XDECREF(args);
	Py_XDECREF(result);
	PyGILState_Release(state);
	return rc;
}


// @pyswig |ListView_SortItems|Uses an application-defined comparison function to sort the items of a list view control.
static PyObject *
PyListView_SortItems(PyObject *self, PyObject *args)
{
	HWND hwnd;
	PyObject *ob, *obhwnd;
	PyObject *obParam = Py_None;
	// @pyparm int|hwnd||The handle to the window
	// @pyparm object|callback||A callback object, taking 3 params.
	// @pyparm object|param|None|The third param to the callback function.
	if (!PyArg_ParseTuple(args, "OO|O:ListView_SortItems", &obhwnd, &ob, &obParam))
		return NULL;
	if (!PyWinObject_AsHANDLE(obhwnd, (HANDLE *)&hwnd))
		return NULL;
	if (!PyCallable_Check(ob))
		return PyErr_Format(PyExc_TypeError,
		                    "2nd param must be callable (got type %s)", ob->ob_type->tp_name);
	PySortCallback cb = {ob, obParam};
	BOOL ok;
	GUI_BGN_SAVE;
	ok = ListView_SortItems(hwnd, PySortFunc, &cb);
	GUI_END_SAVE;
	if (!ok) {
		PyWin_SetAPIError("ListView_SortItems");
		return NULL;
	}
	Py_INCREF(Py_None);
	return Py_None;
}

// @pyswig |ListView_SortItemsEx|Uses an application-defined comparison function to sort the items of a list view control.
static PyObject *
PyListView_SortItemsEx(PyObject *self, PyObject *args)
{
	HWND hwnd;
	PyObject *ob, *obhwnd;
	PyObject *obParam = Py_None;
	// @pyparm int|hwnd||The handle to the window
	// @pyparm object|callback||A callback object, taking 3 params.
	// @pyparm object|param|None|The third param to the callback function.
	if (!PyArg_ParseTuple(args, "OO|O:ListView_SortItemsEx", &obhwnd, &ob, &obParam))
		return NULL;
	if (!PyWinObject_AsHANDLE(obhwnd, (HANDLE *)&hwnd))
		return NULL;
	if (!PyCallable_Check(ob))
		return PyErr_Format(PyExc_TypeError,
		                    "2nd param must be callable (got type %s)", ob->ob_type->tp_name);
	PySortCallback cb = {ob, obParam};
	BOOL ok;
	GUI_BGN_SAVE;
	ok = ListView_SortItemsEx(hwnd, PySortFunc, &cb);
	GUI_END_SAVE;
	if (!ok) {
		PyWin_SetAPIError("ListView_SortItemsEx");
		return NULL;
	}
	Py_INCREF(Py_None);
	return Py_None;
}

static PyObject *PyCreateDC(PyObject *self, PyObject *args)
{
	PDEVMODE pdevmode;
	PyObject *obdevmode=NULL;
	PyObject *obdriver, *obdevice;
	TCHAR *driver, *device, *dummyoutput=NULL;
	HDC hdc;
	if (!PyArg_ParseTuple(args, "OOO", &obdriver, &obdevice, &obdevmode))
		return NULL;
	if (!PyWinObject_AsDEVMODE(obdevmode, &pdevmode, TRUE))
		return NULL;
	if (!PyWinObject_AsTCHAR(obdriver, &driver, FALSE))
		return NULL;
	if (!PyWinObject_AsTCHAR(obdevice, &device, TRUE)) {
		PyWinObject_FreeTCHAR(driver);
		return NULL;
	}
	PyObject *ret;
	hdc=CreateDC(driver, device, dummyoutput, pdevmode);
	if (hdc!=NULL)
		ret = PyWinLong_FromHANDLE(hdc);
	else {
		PyWin_SetAPIError("CreateDC",GetLastError());
		ret = NULL;
	}
	PyWinObject_FreeTCHAR(driver);
	PyWinObject_FreeTCHAR(device);
	return ret;
}

void PyWinObject_FreeOPENFILENAMEW(OPENFILENAMEW *pofn)
{
	if (pofn->lpstrFile!=NULL)
		free(pofn->lpstrFile);
	if (pofn->lpstrCustomFilter!=NULL)
		free(pofn->lpstrCustomFilter);				
	// these are all defined as CONST in the structure
	PyWinObject_FreeWCHAR((WCHAR *)pofn->lpstrFilter);
	PyWinObject_FreeWCHAR((WCHAR *)pofn->lpstrInitialDir);
	PyWinObject_FreeWCHAR((WCHAR *)pofn->lpstrTitle);
	PyWinObject_FreeWCHAR((WCHAR *)pofn->lpstrDefExt);
	PyWinObject_FreeResourceId((WCHAR *)pofn->lpTemplateName);
	ZeroMemory(pofn, sizeof(OPENFILENAMEW));
}

// Forward declared so autoduck comments for parms will appear with GetOpenFileNameW
BOOL PyParse_OPENFILENAMEW_Args(PyObject *args, PyObject *kwargs, OPENFILENAMEW *pofn);

PyObject *PyReturn_OPENFILENAMEW_Output(OPENFILENAMEW *pofn)
{
	DWORD filechars, filterchars;
	// If OFN_ALLOWMULTISELECT is set, the terminator is 2 NULLs,
	// otherwise a single NULL.
	if (pofn->Flags & OFN_ALLOWMULTISELECT) {
		for (filechars=0;
		     filechars < pofn->nMaxFile-1 && !(pofn->lpstrFile[filechars]==0 && pofn->lpstrFile[filechars+1]==0);
		     filechars++)
		     ;
	} else {
		filechars = wcslen(pofn->lpstrFile);
	}
	if (pofn->lpstrCustomFilter==NULL)
		return Py_BuildValue("NOk",
			PyWinObject_FromWCHAR(pofn->lpstrFile, filechars),
			Py_None,
			pofn->Flags);
	// if CustomFilter if present, can contain NULL's also
	for (filterchars=pofn->nMaxCustFilter; filterchars>0; filterchars--)
		if (pofn->lpstrCustomFilter[filterchars-1]!=0)
			break;
	return Py_BuildValue("NNk",
		PyWinObject_FromWCHAR(pofn->lpstrFile, filechars),
		// include trailing NULL so returned value can be passed back in as a filter unmodified
		PyWinObject_FromWCHAR(pofn->lpstrCustomFilter, filterchars+1),
		pofn->Flags);
}

// @pyswig (<o PyUNICODE>,<o PyUNICODE>,int)|GetSaveFileNameW|Creates a dialog for user to specify location to save a file or files
// @comm Accepts keyword arguments, all arguments optional
// @rdesc Returns a tuple of 3 values (<o PyUNICODE>, <o PyUNICODE>, int):<nl>
// First is the selected file(s). If multiple files are selected, returned string will be the directory followed by files names
// separated by nulls, otherwise it will be the full path.  In other words, if you use the OFN_ALLOWMULTISELECT flag
// you should split this value on \0 characters and if the length of the result list is 1, it will be
// the full path, otherwise element 0 will be the directory and the rest of the elements will be filenames in
// this directory.<nl>
// Second is a unicode string containing user-selected filter, will be None if CustomFilter was not specified<nl>
// Third item contains flags pertaining to users input, such as OFN_READONLY and OFN_EXTENSIONDIFFERENT
// <nl>If the user presses cancel or an error occurs, a
// win32gui.error is raised.  If the user pressed cancel, the error number (ie, the winerror attribute of the exception) will be zero.
// @pyparm <o PyHANDLE>|hwndOwner|None|Handle to window that owns dialog
// @pyparm <o PyHANDLE>|hInstance|None|Handle to module that contains dialog template
// @pyparm <o PyUNICODE>|Filter|None|Contains pairs of descriptions and filespecs separated by NULLS, with a final trailing NULL.
// Example: 'Python Scripts\0*.py;*.pyw;*.pys\0Text files\0*.txt\0'
// @pyparm <o PyUNICODE>|CustomFilter|None|Description to be used for filter that user selected or typed, can also contain a filespec as above
// @pyparm int|FilterIndex|0|Specifies which of the filters is initially selected, use 0 for CustomFilter
// @pyparm <o PyUNICODE>|File|None|The file name initially displayed
// @pyparm int|MaxFile|1024|Number of characters to allocate for selected filename(s), override if large number of files expected
// @pyparm <o PyUNICODE>|InitialDir|None|The starting directory
// @pyparm <o PyUNICODE>|Title|None|The title of the dialog box
// @pyparm int|Flags|0|Combination of win32con.OFN_* constants
// @pyparm <o PyUNICODE>|DefExt|None|The default extension to use
// @pyparm <o PyResourceId>|TemplateName|None|Name or resource id of dialog box template
static PyObject *PyGetSaveFileNameW(PyObject *self, PyObject *args, PyObject *kwargs)
{	
	PyObject *ret=NULL;
	OPENFILENAMEW ofn;

	if (!PyParse_OPENFILENAMEW_Args(args, kwargs, &ofn))
		return NULL;

	BOOL ok;
	Py_BEGIN_ALLOW_THREADS;
	ok = GetSaveFileNameW(&ofn);
	Py_END_ALLOW_THREADS;
	if (!ok)
		PyWin_SetAPIError("GetSaveFileNameW", CommDlgExtendedError());
	else
		ret=PyReturn_OPENFILENAMEW_Output(&ofn);

	PyWinObject_FreeOPENFILENAMEW(&ofn);
	return ret;
}

// @pyswig (<o PyUNICODE>,<o PyUNICODE>, int)|GetOpenFileNameW|Creates a dialog to allow user to select file(s) to open
// @comm Accepts keyword arguments, all arguments optional
// Input parameters and return values are identical to <om win32gui.GetSaveFileNameW>
static PyObject *PyGetOpenFileNameW(PyObject *self, PyObject *args, PyObject *kwargs)
{	
	PyObject *ret=NULL;
	OPENFILENAMEW ofn;

	if (!PyParse_OPENFILENAMEW_Args(args, kwargs, &ofn))
		return NULL;

	BOOL ok;
	Py_BEGIN_ALLOW_THREADS;
	ok = GetOpenFileNameW(&ofn);
	Py_END_ALLOW_THREADS;
	if (!ok)
		PyWin_SetAPIError("GetOpenFileNameW", CommDlgExtendedError());
	else
		ret=PyReturn_OPENFILENAMEW_Output(&ofn);

	PyWinObject_FreeOPENFILENAMEW(&ofn);
	return ret;
}

BOOL PyParse_OPENFILENAMEW_Args(PyObject *args, PyObject *kwargs, OPENFILENAMEW *pofn)
{
	BOOL ret=FALSE;
	static char * keywords[]={"hwndOwner", "hInstance", "Filter", "CustomFilter",
		"FilterIndex", "File", "MaxFile", "InitialDir",
		"Title", "Flags", "DefExt", "TemplateName", NULL};
	PyObject *obFilter=Py_None, *obCustomFilter=Py_None, *obFile=Py_None, *obInitialDir=Py_None, 
		*obTitle=Py_None, *obDefExt=Py_None, *obTemplateName=Py_None,
		*obOwner=Py_None, *obhInstance=Py_None;
	WCHAR *initfile=NULL, *customfilter=NULL;
	DWORD bufsize, initfilechars, customfilterchars;
	ZeroMemory(pofn, sizeof(OPENFILENAMEW));
	// ??? may need to set size to OPENFILENAME_SIZE_VERSION_400 to be compatible with NT
	pofn->lStructSize=sizeof(OPENFILENAMEW);
	pofn->nMaxFile=1024; 	// default to large buffer since multiple files can be selected

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OOOOlOlOOlOO:OPENFILENAME", keywords,
		&obOwner,				// @pyparm <o PyHANDLE>|hwndOwner|None|Handle to window that owns dialog
		&obhInstance,			// @pyparm <o PyHANDLE>|hInstance|None|Handle to module that contains dialog template
		&obFilter,				// @pyparm <o PyUNICODE>|Filter|None|Contains pairs of descriptions and filespecs separated by NULLS, with a final trailing NULL.
								// Example: 'Python Scripts\0*.py;*.pyw;*.pys\0Text files\0*.txt\0'
		&obCustomFilter,		// @pyparm <o PyUNICODE>|CustomFilter|None|Description to be used for filter that user selected or typed, can also contain a filespec as above
		&pofn->nFilterIndex,	// @pyparm int|FilterIndex|0|Specifies which of the filters is initially selected, use 0 for CustomFilter
		&obFile,				// @pyparm <o PyUNICODE>|File|None|The file name initially displayed
		&pofn->nMaxFile,		// @pyparm int|MaxFile|1024|Number of characters to allocate for selected filename, override if large number of files expected
		&obInitialDir,			// @pyparm <o PyUNICODE>|InitialDir|None|The starting directory
		&obTitle,				// @pyparm <o PyUNICODE>|Title|None|The title of the dialog box
		&pofn->Flags,			// @pyparm int|Flags|0|Combination of win32con.OFN_* constants
		&obDefExt,				// @pyparm <o PyUNICODE>|DefExt|None|The default extension to use
		&obTemplateName))		// @pyparm <o PyResourceId>|TemplateName|None|Name or resource id of dialog box template
		goto done;

	// CustomFilter will have user-selected (or typed) wildcard pattern appended to it
	if (obCustomFilter!=Py_None){
		if (!PyWinObject_AsWCHAR(obCustomFilter, &customfilter, FALSE, &customfilterchars))
			goto done;
		pofn->nMaxCustFilter=customfilterchars+256;
		bufsize=pofn->nMaxCustFilter*sizeof(WCHAR);
		pofn->lpstrCustomFilter=(LPWSTR)malloc(bufsize);
		if (pofn->lpstrCustomFilter==NULL){
			PyErr_Format(PyExc_MemoryError,"Unable to allocate %d bytes for CustomFilter", bufsize);
			goto done;
			}
		ZeroMemory(pofn->lpstrCustomFilter, bufsize);
		memcpy(pofn->lpstrCustomFilter, customfilter, customfilterchars*sizeof(WCHAR));
		}

	// lpstrFile buffer receives full path and possibly multiple file names, allocate extra space
	if (!PyWinObject_AsWCHAR(obFile, &initfile, TRUE, &initfilechars))
		goto done;
	pofn->nMaxFile=max(pofn->nMaxFile, initfilechars+1);
	bufsize=pofn->nMaxFile*sizeof(WCHAR);
	pofn->lpstrFile=(LPWSTR)malloc(bufsize);
	if (pofn->lpstrFile==NULL){
		PyErr_Format(PyExc_MemoryError,"Unable to allocate %d bytes for File buffer", bufsize);
		goto done;
		}
	ZeroMemory(pofn->lpstrFile, bufsize);
	if (initfile!=NULL)
		memcpy(pofn->lpstrFile, initfile, initfilechars*sizeof(WCHAR));

	ret=PyWinObject_AsHANDLE(obOwner, (PHANDLE)&pofn->hwndOwner) &&
		PyWinObject_AsHANDLE(obhInstance, (PHANDLE)&pofn->hInstance) &&
		PyWinObject_AsWCHAR(obFilter, (WCHAR **)&pofn->lpstrFilter, TRUE) &&
		PyWinObject_AsWCHAR(obInitialDir, (WCHAR **)&pofn->lpstrInitialDir, TRUE) &&
		PyWinObject_AsWCHAR(obTitle, (WCHAR **)&pofn->lpstrTitle, TRUE) &&
		PyWinObject_AsWCHAR(obDefExt, (WCHAR **)&pofn->lpstrDefExt, TRUE) &&
		PyWinObject_AsResourceIdW(obTemplateName, (WCHAR **)&pofn->lpTemplateName, TRUE);
		
	done:
	if (!ret)
		PyWinObject_FreeOPENFILENAMEW(pofn);
	PyWinObject_FreeWCHAR(initfile);
	PyWinObject_FreeWCHAR(customfilter);
	return ret;
}

// Swig 1.2 chokes on functions that takes keywords
PyCFunction pfnPyGetSaveFileNameW=(PyCFunction)PyGetSaveFileNameW;
PyCFunction pfnPyGetOpenFileNameW=(PyCFunction)PyGetOpenFileNameW;

BOOL PyObject_AsUINT(PyObject *ob, UINT *puint)
{
	// PyLong_AsUnsignedLong throws a bogus error in 2.3 if passed an int, and there is no PyInt_AsUnsignedLong
	// ref: http://mail.python.org/pipermail/patches/2004-September/016060.html
	// And for some reason none of the Unsigned*Mask functions check for overflow ???

	__int64 UINT_candidate=PyLong_AsLongLong(ob);
	if (UINT_candidate==-1 && PyErr_Occurred())
		return FALSE;
	if (UINT_candidate<0 || UINT_candidate>UINT_MAX){
		PyErr_Format(PyExc_ValueError, "Parameter must be in range 0 - %d", UINT_MAX);
		return FALSE;
		}
	*puint=(UINT)UINT_candidate;
	return TRUE;
}

BOOL PyWinObject_AsNONCLIENTMETRICS(PyObject *ob, NONCLIENTMETRICS *ncm)
{
	static char *keywords[]={"iBorderWidth","iScrollWidth","iScrollHeight",
		"iCaptionWidth","iCaptionHeight","lfCaptionFont",
		"iSmCaptionWidth","iSmCaptionHeight","lfSmCaptionFont",
		"iMenuWidth","iMenuHeight","lfMenuFont","lfStatusFont",
		"lfMessageFont", NULL};
	BOOL ret;
	ZeroMemory(ncm, sizeof(NONCLIENTMETRICS));
	ncm->cbSize=sizeof(NONCLIENTMETRICS);

	if (!PyDict_Check(ob)){
		PyErr_SetString(PyExc_TypeError, "NONCLIENTMETRICS must be a dict");
		return FALSE;
		}
	PyObject *dummy_args=PyTuple_New(0);
	if (dummy_args==NULL)	// should not happen, interpreter apparently caches the empty tuple
		return FALSE;
	ret=PyArg_ParseTupleAndKeywords(dummy_args, ob, "iiiiiO&iiO&iiO&O&O&:NONCLIENTMETRICS", keywords,
		&ncm->iBorderWidth, &ncm->iScrollWidth, &ncm->iScrollHeight,
		&ncm->iCaptionWidth, &ncm->iCaptionHeight, 
		PyWinObject_AsLOGFONT, &ncm->lfCaptionFont,
		&ncm->iSmCaptionWidth, &ncm->iSmCaptionHeight,
		PyWinObject_AsLOGFONT, &ncm->lfSmCaptionFont,
		&ncm->iMenuWidth, &ncm->iMenuHeight, 
		PyWinObject_AsLOGFONT, &ncm->lfMenuFont, 
		PyWinObject_AsLOGFONT, &ncm->lfStatusFont,
		PyWinObject_AsLOGFONT, &ncm->lfMessageFont);
	Py_DECREF(dummy_args);
	return ret;
}

BOOL PyWinObject_AsMINIMIZEDMETRICS(PyObject *ob, MINIMIZEDMETRICS *mm)
{
	static char *keywords[]={"iWidth","iHorzGap","iVertGap","iArrange",NULL};
	BOOL ret;
	ZeroMemory(mm, sizeof(MINIMIZEDMETRICS));
	mm->cbSize=sizeof(MINIMIZEDMETRICS);

	if (!PyDict_Check(ob)){
		PyErr_SetString(PyExc_TypeError, "MINIMIZEDMETRICS must be a dict");
		return FALSE;
		}
	PyObject *dummy_args=PyTuple_New(0);
	if (dummy_args==NULL)	// should not happen, interpreter apparently caches the empty tuple
		return FALSE;
	ret=PyArg_ParseTupleAndKeywords(dummy_args, ob, "iiii:MINIMIZEDMETRICS", keywords,
		&mm->iWidth, &mm->iHorzGap, &mm->iVertGap, &mm->iArrange);
	Py_DECREF(dummy_args);
	return ret;
}

static PyObject *PySystemParametersInfo(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *keywords[]={"Action", "Param", "WinIni",  NULL};
	UINT Action, uiParam=0, WinIni=0;
	PVOID pvParam=NULL;
	PyObject *obParam=Py_None, *ret=NULL;
	DWORD buflen;
	BOOL boolParam;
	UINT uintParam;
#ifndef MS_WINCE
	long longParam;
#endif

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "k|Ok", keywords,	
		&Action,	// @pyparm int|Action||System parameter to query or set, one of the SPI_GET* or SPI_SET* constants
		&obParam,	// @pyparm  object|Param|None|depends on action to be taken
		&WinIni))	// @pyparm int|WinIni|0|Flags specifying whether change should be permanent, and if all windows should be notified of change. Combination of SPIF_UPDATEINIFILE, SPIF_SENDCHANGE, SPIF_SENDWININICHANGE
		return NULL;

	// @flagh Action|Input/return type
	switch (Action){
#ifndef MS_WINCE
		// @flag SPI_GETDESKWALLPAPER|Returns the path to the bmp used as wallpaper
		case SPI_GETDESKWALLPAPER:
			uiParam=MAX_PATH;
			buflen=uiParam*sizeof(TCHAR);
			pvParam=malloc(buflen);
			if (pvParam==NULL){
				PyErr_Format(PyExc_MemoryError, "Unable to allocate %d bytes", buflen);
				goto done;
				}
			break;
		// @flag SPI_SETDESKWALLPAPER|Param should be a string specifying a .bmp file
		case SPI_SETDESKWALLPAPER:
			if (!PyWinObject_AsTCHAR(obParam, (TCHAR **)&pvParam, TRUE, &buflen))
				goto done;
			uiParam=buflen;
			break;
			
		// Below actions return a boolean pointed to by Param
		// @flag SPI_GETDROPSHADOW|Returns a boolean
		case SPI_GETDROPSHADOW:
		// @flag SPI_GETFLATMENU|Returns a boolean
		case SPI_GETFLATMENU:
		// @flag SPI_GETFONTSMOOTHING|Returns a boolean
		case SPI_GETFONTSMOOTHING:
		// @flag SPI_GETICONTITLEWRAP|Returns a boolean
		case SPI_GETICONTITLEWRAP:
		// @flag SPI_GETSNAPTODEFBUTTON|Returns a boolean
		case SPI_GETSNAPTODEFBUTTON:
		// @flag SPI_GETBEEP|Returns a boolean
		case SPI_GETBEEP:
		// @flag SPI_GETBLOCKSENDINPUTRESETS|Returns a boolean
		case SPI_GETBLOCKSENDINPUTRESETS:
		// @flag SPI_GETMENUUNDERLINES|Returns a boolean
		// @flag SPI_GETKEYBOARDCUES|Returns a boolean
		case SPI_GETKEYBOARDCUES:
		// @flag SPI_GETKEYBOARDPREF|Returns a boolean
		case SPI_GETKEYBOARDPREF:
		// @flag SPI_GETSCREENSAVEACTIVE|Returns a boolean
		case SPI_GETSCREENSAVEACTIVE:
		// @flag SPI_GETSCREENSAVERRUNNING|Returns a boolean
		case SPI_GETSCREENSAVERRUNNING:
		// @flag SPI_GETMENUDROPALIGNMENT|Returns a boolean (True indicates left aligned, False right aligned)
		case SPI_GETMENUDROPALIGNMENT:
		// @flag SPI_GETMENUFADE|Returns a boolean
		case SPI_GETMENUFADE:
		// @flag SPI_GETLOWPOWERACTIVE|Returns a boolean
		case SPI_GETLOWPOWERACTIVE:
		// @flag SPI_GETPOWEROFFACTIVE|Returns a boolean
		case SPI_GETPOWEROFFACTIVE:
		// @flag SPI_GETCOMBOBOXANIMATION|Returns a boolean
		case SPI_GETCOMBOBOXANIMATION:
		// @flag SPI_GETCURSORSHADOW|Returns a boolean
		case SPI_GETCURSORSHADOW:
		// @flag SPI_GETGRADIENTCAPTIONS|Returns a boolean
		case SPI_GETGRADIENTCAPTIONS:
		// @flag SPI_GETHOTTRACKING|Returns a boolean
		case SPI_GETHOTTRACKING:
		// @flag SPI_GETLISTBOXSMOOTHSCROLLING|Returns a boolean
		case SPI_GETLISTBOXSMOOTHSCROLLING:
		// @flag SPI_GETMENUANIMATION|Returns a boolean
		case SPI_GETMENUANIMATION:
		// @flag SPI_GETSELECTIONFADE|Returns a boolean
		case SPI_GETSELECTIONFADE:
		// @flag SPI_GETTOOLTIPANIMATION|Returns a boolean
		case SPI_GETTOOLTIPANIMATION:
		// @flag SPI_GETTOOLTIPFADE|Returns a boolean (TRUE=fade, False=slide)
		case SPI_GETTOOLTIPFADE:
		// @flag SPI_GETUIEFFECTS|Returns a boolean
		case SPI_GETUIEFFECTS:
		// @flag SPI_GETACTIVEWINDOWTRACKING|Returns a boolean
		case SPI_GETACTIVEWINDOWTRACKING:
		// @flag SPI_GETACTIVEWNDTRKZORDER|Returns a boolean
		case SPI_GETACTIVEWNDTRKZORDER:
		// @flag SPI_GETDRAGFULLWINDOWS|Returns a boolean
		case SPI_GETDRAGFULLWINDOWS:    
		// @flag SPI_GETSHOWIMEUI|Returns a boolean
		case SPI_GETSHOWIMEUI:
		// @flag SPI_GETMOUSECLICKLOCK|Returns a boolean
		case SPI_GETMOUSECLICKLOCK:
		// @flag SPI_GETMOUSESONAR|Returns a boolean
		case SPI_GETMOUSESONAR:
		// @flag SPI_GETMOUSEVANISH|Returns a boolean
		case SPI_GETMOUSEVANISH:
		// @flag SPI_GETSCREENREADER|Returns a boolean
		case SPI_GETSCREENREADER:
#endif	// !MS_WINCE
		// @flag SPI_GETSHOWSOUNDS|Returns a boolean
		case SPI_GETSHOWSOUNDS:
			pvParam=&boolParam;
			break;
		
#ifndef MS_WINCE
		// Actions in this section accept a boolean as pvParam
		// @flag SPI_SETDROPSHADOW|Param must be a boolean
		case SPI_SETDROPSHADOW:
		// @flag SPI_SETDROPSHADOW|Param must be a boolean
		case SPI_SETFLATMENU:
		// @flag SPI_SETMENUUNDERLINES|Param must be a boolean
		// @flag SPI_SETKEYBOARDCUES|Param must be a boolean
		case SPI_SETKEYBOARDCUES:
		// @flag SPI_SETMENUFADE|Param must be a boolean
		case SPI_SETMENUFADE:
		// @flag SPI_SETCOMBOBOXANIMATION|Param must be a boolean
		case SPI_SETCOMBOBOXANIMATION:
		// @flag SPI_SETCURSORSHADOW|Param must be a boolean
		case SPI_SETCURSORSHADOW:
		// @flag SPI_SETGRADIENTCAPTIONS|Param must be a boolean
		case SPI_SETGRADIENTCAPTIONS:
		// @flag SPI_SETHOTTRACKING|Param must be a boolean
		case SPI_SETHOTTRACKING:
		// @flag SPI_SETLISTBOXSMOOTHSCROLLING|Param must be a boolean
		case SPI_SETLISTBOXSMOOTHSCROLLING:
		// @flag SPI_SETMENUANIMATION|Param must be a boolean
		case SPI_SETMENUANIMATION:
		// @flag SPI_SETSELECTIONFADE|Param must be a boolean
		case SPI_SETSELECTIONFADE:
		// @flag SPI_SETTOOLTIPANIMATION|Param must be a boolean
		case SPI_SETTOOLTIPANIMATION:
		// @flag SPI_SETTOOLTIPFADE|Param must be a boolean
		case SPI_SETTOOLTIPFADE:
		// @flag SPI_SETUIEFFECTS|Param must be a boolean
		case SPI_SETUIEFFECTS:
		// @flag SPI_SETACTIVEWINDOWTRACKING|Param must be a boolean
		case SPI_SETACTIVEWINDOWTRACKING:
		// @flag SPI_SETACTIVEWNDTRKZORDER|Param must be a boolean
		case SPI_SETACTIVEWNDTRKZORDER:
		// @flag SPI_SETMOUSESONAR|Param must be a boolean
		case SPI_SETMOUSESONAR:
		// @flag SPI_SETMOUSEVANISH|Param must be a boolean
		case SPI_SETMOUSEVANISH:
		// @flag SPI_SETMOUSECLICKLOCK|Param must be a boolean
		case SPI_SETMOUSECLICKLOCK:
			pvParam=(PVOID)PyObject_IsTrue(obParam);
			if (pvParam==(PVOID)-1)
				goto done;
			break;

		// These accept a boolean placed in uiParam
		// @flag SPI_SETFONTSMOOTHING|Param should specify a boolean
		case SPI_SETFONTSMOOTHING:
		// @flag SPI_SETICONTITLEWRAP|Param should specify a boolean
		case SPI_SETICONTITLEWRAP:
		// @flag SPI_SETSNAPTODEFBUTTON|Param is a boolean
		case SPI_SETSNAPTODEFBUTTON:
		// @flag SPI_SETBEEP|Param is a boolean
		case SPI_SETBEEP:
		// @flag SPI_SETBLOCKSENDINPUTRESETS|Param is a boolean
		case SPI_SETBLOCKSENDINPUTRESETS:
		// @flag SPI_SETKEYBOARDPREF|Param is a boolean
		case SPI_SETKEYBOARDPREF:
		// @flag SPI_SETMOUSEBUTTONSWAP|Param is a boolean
		case SPI_SETMOUSEBUTTONSWAP:
		// @flag SPI_SETSCREENSAVEACTIVE|Param is a boolean
		case SPI_SETSCREENSAVEACTIVE:
		// @flag SPI_SETMENUDROPALIGNMENT|Param is a boolean (True=left aligned, False=right aligned)
		case SPI_SETMENUDROPALIGNMENT:
		// @flag SPI_SETLOWPOWERACTIVE|Param is a boolean
		case SPI_SETLOWPOWERACTIVE:
		// @flag SPI_SETPOWEROFFACTIVE|Param is a boolean
		case SPI_SETPOWEROFFACTIVE:
		// @flag SPI_SETDRAGFULLWINDOWS|Param is a boolean
		case SPI_SETDRAGFULLWINDOWS:
		// @flag SPI_SETSHOWIMEUI|Param is a boolean
		case SPI_SETSHOWIMEUI:
		// @flag SPI_SETSCREENREADER|Param is a boolean
		case SPI_SETSCREENREADER:
#endif	// !MS_WINCE
		// @flag SPI_SETSHOWSOUNDS|Param is a boolean
		case SPI_SETSHOWSOUNDS:
			uiParam=(UINT)PyObject_IsTrue(obParam);
			if (uiParam==(UINT)-1)
				goto done;
			break;

#ifndef MS_WINCE
		// These accept an int placed in uiParam
		// @flag SPI_SETMOUSETRAILS|Param should be an int specifying the nbr of cursors in the trail (0 or 1 means disabled)
		case SPI_SETMOUSETRAILS:
#endif	// !MS_WINCE
		// @flag SPI_SETWHEELSCROLLLINES|Param is an int specifying nbr of lines
		case SPI_SETWHEELSCROLLLINES:
#ifndef MS_WINCE
		// @flag SPI_SETKEYBOARDDELAY|Param is an int in the range 0 - 3
		case SPI_SETKEYBOARDDELAY:
		// @flag SPI_SETKEYBOARDSPEED|Param is an int in the range 0 - 31
		case SPI_SETKEYBOARDSPEED:
		// @flag SPI_SETDOUBLECLICKTIME|Param is an int (in milliseconds),  Use <om win32gui.GetDoubleClickTime> to retrieve the value.
		case SPI_SETDOUBLECLICKTIME:
		// @flag SPI_SETDOUBLECLKWIDTH|Param is an int.  Use win32api.GetSystemMetrics(SM_CXDOUBLECLK) to retrieve the value.
		case SPI_SETDOUBLECLKWIDTH:
		// @flag SPI_SETDOUBLECLKHEIGHT|Param is an int,  Use win32api.GetSystemMetrics(SM_CYDOUBLECLK) to retrieve the value.
		case SPI_SETDOUBLECLKHEIGHT:
		// @flag SPI_SETMOUSEHOVERHEIGHT|Param is an int
		case SPI_SETMOUSEHOVERHEIGHT:
		// @flag SPI_SETMOUSEHOVERWIDTH|Param is an int
		case SPI_SETMOUSEHOVERWIDTH:
		// @flag SPI_SETMOUSEHOVERTIME|Param is an int
		case SPI_SETMOUSEHOVERTIME:
		// @flag SPI_SETSCREENSAVETIMEOUT|Param is an int specifying the timeout in seconds
		case SPI_SETSCREENSAVETIMEOUT:
		// @flag SPI_SETMENUSHOWDELAY|Param is an int specifying the shortcut menu delay in milliseconds
		case SPI_SETMENUSHOWDELAY:
		// @flag SPI_SETLOWPOWERTIMEOUT|Param is an int (in seconds)
		case SPI_SETLOWPOWERTIMEOUT:
		// @flag SPI_SETPOWEROFFTIMEOUT|Param is an int (in seconds)
		case SPI_SETPOWEROFFTIMEOUT:
		// @flag SPI_SETDRAGHEIGHT|Param is an int. Use win32api.GetSystemMetrics(SM_CYDRAG) to retrieve the value.
		case SPI_SETDRAGHEIGHT:
		// @flag SPI_SETDRAGWIDTH|Param is an int. Use win32api.GetSystemMetrics(SM_CXDRAG) to retrieve the value.
		case SPI_SETDRAGWIDTH:
		// @flag SPI_SETBORDER|Param is an int
		case SPI_SETBORDER:
#endif	// !MS_WINCE
			if (!PyObject_AsUINT(obParam, &uiParam))
				goto done;
			break;

		// below Actions all return a UINT pointed to by Param
		// @flag SPI_GETFONTSMOOTHINGCONTRAST|Returns an int
		case SPI_GETFONTSMOOTHINGCONTRAST:
#ifndef MS_WINCE
		// @flag SPI_GETFONTSMOOTHINGTYPE|Returns an int
		case SPI_GETFONTSMOOTHINGTYPE:
		// @flag SPI_GETMOUSETRAILS|Returns an int specifying the nbr of cursor images in the trail, 0 or 1 indicates disabled
		case SPI_GETMOUSETRAILS:
		// @flag SPI_GETWHEELSCROLLLINES|Returns the nbr of lines to scroll for the mouse wheel
		case SPI_GETWHEELSCROLLLINES:
		// @flag SPI_GETKEYBOARDDELAY|Returns an int
		case SPI_GETKEYBOARDDELAY:
		// @flag SPI_GETKEYBOARDSPEED|Returns an int
		case SPI_GETKEYBOARDSPEED:
		// @flag SPI_GETMOUSESPEED|Returns an int
		case SPI_GETMOUSESPEED:
		// @flag SPI_GETMOUSEHOVERHEIGHT|Returns an int
		case SPI_GETMOUSEHOVERHEIGHT:
		// @flag SPI_GETMOUSEHOVERWIDTH|Returns an int
		case SPI_GETMOUSEHOVERWIDTH:
		// @flag SPI_GETMOUSEHOVERTIME|Returns an int
		case SPI_GETMOUSEHOVERTIME:
#endif	// !MS_WINCE
		// @flag SPI_GETSCREENSAVETIMEOUT|Returns an int (idle time in seconds)
		case SPI_GETSCREENSAVETIMEOUT:
#ifndef MS_WINCE
		// @flag SPI_GETMENUSHOWDELAY|Returns an int (shortcut delay in milliseconds)
		case SPI_GETMENUSHOWDELAY:
		// @flag SPI_GETLOWPOWERTIMEOUT|Returns an int (in seconds)
		case SPI_GETLOWPOWERTIMEOUT:
		// @flag SPI_GETPOWEROFFTIMEOUT|Returns an int (in seconds)
		case SPI_GETPOWEROFFTIMEOUT:
		// @flag SPI_GETACTIVEWNDTRKTIMEOUT|Returns an int (milliseconds)
		case SPI_GETACTIVEWNDTRKTIMEOUT:
		// @flag SPI_GETBORDER|Returns an int
		case SPI_GETBORDER:
		// @flag SPI_GETCARETWIDTH|Returns an int
		case SPI_GETCARETWIDTH:
		// @flag SPI_GETFOREGROUNDFLASHCOUNT|Returns an int
		case SPI_GETFOREGROUNDFLASHCOUNT:
		// @flag SPI_GETFOREGROUNDLOCKTIMEOUT|Returns an int
		case SPI_GETFOREGROUNDLOCKTIMEOUT:
		// @flag SPI_GETFOCUSBORDERHEIGHT|Returns an int
		case SPI_GETFOCUSBORDERHEIGHT:
		// @flag SPI_GETFOCUSBORDERWIDTH|Returns an int
		case SPI_GETFOCUSBORDERWIDTH:
		// @flag SPI_GETMOUSECLICKLOCKTIME|Returns an int (in milliseconds)
		case SPI_GETMOUSECLICKLOCKTIME:
#endif	// !MS_WINCE
			pvParam=&uintParam;
			break;
		
		// Actions that take pvParam as an unsigned int
		// @flag SPI_SETFONTSMOOTHINGCONTRAST|Param should be an int in the range 1000 to 2200
		case SPI_SETFONTSMOOTHINGCONTRAST:
#ifndef MS_WINCE
		// @flag SPI_SETFONTSMOOTHINGTYPE|Param should be one of the FE_FONTSMOOTHING* constants
		case SPI_SETFONTSMOOTHINGTYPE:
		// @flag SPI_SETMOUSESPEED|Param should be an int in the range 1 - 20
		case SPI_SETMOUSESPEED:
		// @flag SPI_SETACTIVEWNDTRKTIMEOUT|Param is an int (in milliseconds)
		case SPI_SETACTIVEWNDTRKTIMEOUT:
		// @flag SPI_SETCARETWIDTH|Param is an int (in pixels)
		case SPI_SETCARETWIDTH:
		// @flag SPI_SETFOREGROUNDFLASHCOUNT|Param is an int
		case SPI_SETFOREGROUNDFLASHCOUNT:
		// @flag SPI_SETFOREGROUNDLOCKTIMEOUT|Param is an int (in milliseconds)
		case SPI_SETFOREGROUNDLOCKTIMEOUT:
		// @flag SPI_SETFOCUSBORDERHEIGHT|Returns an int
		case SPI_SETFOCUSBORDERHEIGHT:
		// @flag SPI_SETFOCUSBORDERWIDTH|Returns an int
		case SPI_SETFOCUSBORDERWIDTH:
		// @flag SPI_SETMOUSECLICKLOCKTIME|Param is an int (in milliseconds)
		case SPI_SETMOUSECLICKLOCKTIME:
#endif	// !MS_WINCE
			if (!PyObject_AsUINT(obParam, (UINT *)&pvParam))
				goto done;
			break;
			
#ifndef MS_WINCE
		// @flag SPI_GETICONTITLELOGFONT|Returns a <o PyLOGFONT>,
		case SPI_GETICONTITLELOGFONT:
			uiParam=sizeof(LOGFONT);
			pvParam=malloc(uiParam);
			if (pvParam==NULL){
				PyErr_Format(PyExc_MemoryError,"Unable to allocate %d bytes", uiParam);
				goto done;
				}
			break;
		// @flag SPI_SETICONTITLELOGFONT|Param must be a <o PyLOGFONT>,
		case SPI_SETICONTITLELOGFONT:
			if (!PyLOGFONT_Check(obParam)){
				PyErr_SetString(PyExc_TypeError, "Param must be a LOGFONT");
				goto done;
				}
			pvParam=((PyLOGFONT *)obParam)->GetLF();
			uiParam=sizeof(LOGFONT);
			break;


		// Set operations that take no parameter
		// @flag SPI_SETLANGTOGGLE|Param is ignored. Sets the language toggle hotkey from registry key HKCU\keyboard layout\toggle 
		case SPI_SETLANGTOGGLE:
		// @flag SPI_SETICONS|Reloads the system icons.  Param is not used
		case SPI_SETICONS:
			break;
#endif	// !MS_WINCE

		// @flag SPI_GETMOUSE|Returns a tuple of 3 ints containing the x and y mouse thresholds and the acceleration factor.
		case SPI_GETMOUSE:
		// @flag SPI_SETMOUSE|Param should be a sequence of 3 ints
		case SPI_SETMOUSE:{
			buflen=3*sizeof(UINT);
			pvParam=malloc(buflen);
			if (pvParam==NULL){
				PyErr_Format(PyExc_MemoryError,"Unable to allocate %d bytes", buflen);
				goto done;
				}
			if (Action==SPI_SETMOUSE){
				PyObject *param_tuple=PySequence_Tuple(obParam);
				if (param_tuple==NULL)
					goto done;
				if (PyTuple_GET_SIZE(param_tuple) != 3){
					PyErr_SetString(PyExc_ValueError,"Param must be a sequence of 3 ints");
					Py_DECREF(param_tuple);
					goto done;
					}
				if (!PyArg_ParseTuple(param_tuple, "kkk", &((UINT *)pvParam)[0], &((UINT *)pvParam)[1], &((UINT *)pvParam)[2])){
					Py_DECREF(param_tuple);
					goto done;
					}
				Py_DECREF(param_tuple);
				}
			break;
			}

#ifndef MS_WINCE
		// @flag SPI_GETDEFAULTINPUTLANG|Returns an int (locale id for default language)
			case SPI_GETDEFAULTINPUTLANG:
			pvParam=&longParam;
			break;
		// @flag SPI_SETDEFAULTINPUTLANG|Param is an int containing a locale id
		case SPI_SETDEFAULTINPUTLANG:
			// input is a HKL, which is actually a HANDLE, which can be treated as a long
			longParam=PyInt_AsLong(obParam);
			if (longParam==-1 && PyErr_Occurred())
				goto done;
			pvParam=&longParam;
			break;
		// @flag SPI_GETANIMATION|Returns an int
		case SPI_GETANIMATION:
		// @flag SPI_SETANIMATION|Param is an int
		case SPI_SETANIMATION:
			buflen=sizeof(ANIMATIONINFO);
			pvParam=malloc(buflen);
			if (pvParam==NULL){
				PyErr_Format(PyExc_MemoryError,"Unable to allocate %d bytes", buflen);
				goto done;
				}
			ZeroMemory(pvParam, buflen);
			uiParam=buflen;
			((ANIMATIONINFO *)pvParam)->cbSize=buflen;
			if (Action==SPI_SETANIMATION){
				((ANIMATIONINFO *)pvParam)->iMinAnimate=PyInt_AsLong(obParam);
				if (((ANIMATIONINFO *)pvParam)->iMinAnimate==-1 && PyErr_Occurred())
					goto done;
				}
			break;
		// @flag SPI_ICONHORIZONTALSPACING|Functions as both a get and set operation.  If Param is None, functions as a get operation, otherwise Param is an int to be set as the new value
		case SPI_ICONHORIZONTALSPACING:
		// @flag SPI_ICONVERTICALSPACING|Functions as both a get and set operation.  If Param is None, functions as a get operation, otherwise Param is an int to be set as the new value
		case SPI_ICONVERTICALSPACING:
			if (obParam==Py_None)	// indicates a get operation
				pvParam=&uintParam;
			else			// for set operation, value is passed in uiParam
				if (!PyObject_AsUINT(obParam, &uiParam))
					goto done;
			break;
		// @flag SPI_GETNONCLIENTMETRICS|Param must be None.  The result is a dict.
		case SPI_GETNONCLIENTMETRICS:
		// @flag SPI_SETNONCLIENTMETRICS|Param is a dict in the form of a NONCLIENTMETRICS struct, as returned by SPI_GETNONCLIENTMETRICS operation
		case SPI_SETNONCLIENTMETRICS:
			buflen = sizeof(NONCLIENTMETRICS);
			pvParam=malloc(buflen);
			if (pvParam==NULL){
				PyErr_Format(PyExc_MemoryError,"Unable to allocate %d bytes", buflen);
				goto done;
			}
			if (Action==SPI_GETNONCLIENTMETRICS){
				if (obParam!=Py_None) {
					PyErr_Format(PyExc_ValueError,
				             "Don't supply a param for SPI_GETNONCLIENTMETRICS");
					goto done;
					}
				memset(pvParam, 0, buflen);
				((NONCLIENTMETRICS *)pvParam)->cbSize = buflen;
				}
			else
				if (!PyWinObject_AsNONCLIENTMETRICS(obParam, (NONCLIENTMETRICS *)pvParam))
					goto done;
			break;

		// @flag SPI_GETMINIMIZEDMETRICS|Returns a dict representing a MINIMIZEDMETRICS struct.  Param is not used.
		case SPI_GETMINIMIZEDMETRICS:		
		// @flag SPI_SETMINIMIZEDMETRICS|Param should be a MINIMIZEDMETRICS dict as returned by SPI_GETMINIMIZEDMETRICS action
		case SPI_SETMINIMIZEDMETRICS:
			buflen = sizeof(MINIMIZEDMETRICS);
			uiParam=buflen;
			pvParam=malloc(buflen);
			if (pvParam==NULL){
				PyErr_Format(PyExc_MemoryError,"Unable to allocate %d bytes", buflen);
				goto done;
			}
			if (Action==SPI_GETMINIMIZEDMETRICS){
				if (obParam!=Py_None) {
					PyErr_Format(PyExc_ValueError,
				             "Don't supply a param for SPI_GETMINIMIZEDMETRICS");
					goto done;
					}
				memset(pvParam, 0, buflen);
				((MINIMIZEDMETRICS *)pvParam)->cbSize = buflen;
				}
			else
				if (!PyWinObject_AsMINIMIZEDMETRICS(obParam, (MINIMIZEDMETRICS *)pvParam))
					goto done;
			break;

#endif	// !MS_WINCE

		// below are not handled yet
		// @flag SPI_SETDESKPATTERN|Unsupported (obsolete)
		// @flag SPI_GETFASTTASKSWITCH|Unsupported (obsolete)
		// @flag SPI_SETFASTTASKSWITCH|Unsupported (obsolete)
		// @flag SPI_SETSCREENSAVERRUNNING|Unsupported (documented as internal use only)
		// @flag SPI_SCREENSAVERRUNNING|Same as SPI_SETSCREENSAVERRUNNING
		// @flag SPI_SETPENWINDOWS|Unsupported (only relevant for win95)
		// @flag SPI_GETWINDOWSEXTENSION|Unsupported (only relevant for win95)
		// @flag SPI_GETGRIDGRANULARITY|Unsupported (obsolete)
		// @flag SPI_SETGRIDGRANULARITY|Unsupported (obsolete)
		// @flag SPI_LANGDRIVER|Unsupported (use is not documented)
		// @flag SPI_GETFONTSMOOTHINGORIENTATION|Unsupported (use is not documented)
		// @flag SPI_SETFONTSMOOTHINGORIENTATION|Unsupported (use is not documented)
		// @flag SPI_SETHANDHELD|Unsupported (use is not documented)
		// @flag SPI_GETICONMETRICS|Not implemented yet
		// @flag SPI_SETICONMETRICS|Not implemented yet
		// @flag SPI_GETWORKAREA|Not implemented yet
		// @flag SPI_SETWORKAREA|Not implemented yet
		// @flag SPI_GETSERIALKEYS|Not implemented yet
		// @flag SPI_SETSERIALKEYS|Not implemented yet
		// @flag SPI_SETMOUSEKEYS|Not implemented yet
		// @flag SPI_GETMOUSEKEYS|Not implemented yet
		// @flag SPI_GETHIGHCONTRAST|Not implemented yet
		// @flag SPI_SETHIGHCONTRAST|Not implemented yet
		// @flag SPI_GETSOUNDSENTRY|Not implemented yet
		// @flag SPI_SETSOUNDSENTRY|Not implemented yet
		// @flag SPI_GETSTICKYKEYS|Not implemented yet
		// @flag SPI_SETSTICKYKEYS|Not implemented yet
		// @flag SPI_GETTOGGLEKEYS|Not implemented yet
		// @flag SPI_SETTOGGLEKEYS|Not implemented yet
		// @flag SPI_GETACCESSTIMEOUT|Not implemented yet
		// @flag SPI_SETACCESSTIMEOUT|Not implemented yet
		// @flag SPI_GETFILTERKEYS|Not implemented yet
		// @flag SPI_SETFILTERKEYS|Not implemented yet
		default:
			PyErr_Format(PyExc_NotImplementedError, "Action %d is not supported yet", Action);
			goto done;
		}
		
	if (!SystemParametersInfo(Action, uiParam, pvParam, WinIni)){
		PyWin_SetAPIError("SystemParametersInfo");
		goto done;
		}

	switch (Action){
#ifndef MS_WINCE
		case SPI_GETDESKWALLPAPER:
			ret=PyWinObject_FromTCHAR((TCHAR *)pvParam);
			break;
		case SPI_GETDROPSHADOW:
		case SPI_GETFLATMENU:
		case SPI_GETFONTSMOOTHING:
		case SPI_GETICONTITLEWRAP:
		case SPI_GETSNAPTODEFBUTTON:
		case SPI_GETBEEP:
		case SPI_GETBLOCKSENDINPUTRESETS:
		case SPI_GETKEYBOARDCUES:
		case SPI_GETKEYBOARDPREF:
		case SPI_GETSCREENSAVEACTIVE:
		case SPI_GETSCREENSAVERRUNNING:
		case SPI_GETMENUDROPALIGNMENT:
		case SPI_GETMENUFADE:
		case SPI_GETLOWPOWERACTIVE:
		case SPI_GETPOWEROFFACTIVE:
		case SPI_GETCOMBOBOXANIMATION:
		case SPI_GETCURSORSHADOW:
		case SPI_GETGRADIENTCAPTIONS:
		case SPI_GETHOTTRACKING:
		case SPI_GETLISTBOXSMOOTHSCROLLING:
		case SPI_GETMENUANIMATION:
		case SPI_GETSELECTIONFADE:
		case SPI_GETTOOLTIPANIMATION:
		case SPI_GETTOOLTIPFADE:
		case SPI_GETUIEFFECTS:
		case SPI_GETACTIVEWINDOWTRACKING:
		case SPI_GETACTIVEWNDTRKZORDER:
		case SPI_GETDRAGFULLWINDOWS:    
		case SPI_GETSHOWIMEUI:
		case SPI_GETMOUSECLICKLOCK:
		case SPI_GETMOUSESONAR:
		case SPI_GETMOUSEVANISH:
		case SPI_GETSCREENREADER:
#endif	// !MS_WINCE
		case SPI_GETSHOWSOUNDS:
			ret=PyBool_FromLong(boolParam);
			break;
#ifndef MS_WINCE
		case SPI_GETFONTSMOOTHINGTYPE:
		case SPI_GETMOUSETRAILS:
		case SPI_GETKEYBOARDDELAY:
		case SPI_GETKEYBOARDSPEED:
		case SPI_GETMOUSESPEED:
		case SPI_GETMOUSEHOVERHEIGHT:
		case SPI_GETMOUSEHOVERWIDTH:
		case SPI_GETMOUSEHOVERTIME:
		case SPI_GETMENUSHOWDELAY:
		case SPI_GETLOWPOWERTIMEOUT:
		case SPI_GETPOWEROFFTIMEOUT:
		case SPI_GETACTIVEWNDTRKTIMEOUT:
		case SPI_GETBORDER:
		case SPI_GETCARETWIDTH:
		case SPI_GETFOREGROUNDFLASHCOUNT:
		case SPI_GETFOREGROUNDLOCKTIMEOUT:
		case SPI_GETFOCUSBORDERHEIGHT:
		case SPI_GETFOCUSBORDERWIDTH:
		case SPI_GETMOUSECLICKLOCKTIME:
#endif	// !MS_WINCE
		case SPI_GETFONTSMOOTHINGCONTRAST:
		case SPI_GETWHEELSCROLLLINES:
		case SPI_GETSCREENSAVETIMEOUT:
			ret=PyLong_FromUnsignedLong(uintParam);
			break;
#ifndef MS_WINCE
		case SPI_GETDEFAULTINPUTLANG:
			ret=PyLong_FromLong(longParam);
			break;
		case SPI_GETICONTITLELOGFONT:
			ret=new PyLOGFONT((LOGFONT *)pvParam);
			break;
#endif	// !MS_WINCE
		case SPI_GETMOUSE:
			ret=Py_BuildValue("kkk", ((UINT *)pvParam)[0], ((UINT *)pvParam)[1], ((UINT *)pvParam)[2]);
			break;
#ifndef MS_WINCE
		case SPI_GETANIMATION:
			ret=PyInt_FromLong(((ANIMATIONINFO *)pvParam)->iMinAnimate);
			break;
		// these 2 can be a get or set, use Param==Py_None to mean a get
		case SPI_ICONHORIZONTALSPACING:
		case SPI_ICONVERTICALSPACING:
			if (obParam==Py_None)
				ret=PyLong_FromUnsignedLong(uintParam);
			else{
				Py_INCREF(Py_None);
				ret=Py_None;
				}
			break;

		case SPI_GETNONCLIENTMETRICS: {
			NONCLIENTMETRICS *p = (NONCLIENTMETRICS *)pvParam;
			ret = Py_BuildValue("{s:i,s:i,s:i,s:i,s:i,s:N,s:i,s:i,s:N,s:i,s:i,s:N,s:N,s:N}",
					"iBorderWidth", p->iBorderWidth,
					"iScrollWidth", p->iScrollWidth,
					"iScrollHeight", p->iScrollHeight,
					"iCaptionWidth", p->iCaptionWidth,
					"iCaptionHeight", p->iCaptionHeight,
					"lfCaptionFont", new PyLOGFONT(&p->lfCaptionFont),
					"iSmCaptionWidth", p->iSmCaptionWidth,
					"iSmCaptionHeight", p->iSmCaptionHeight,
					"lfSmCaptionFont", new PyLOGFONT(&p->lfSmCaptionFont),
					"iMenuWidth", p->iMenuWidth,
					"iMenuHeight", p->iMenuHeight,
					"lfMenuFont", new PyLOGFONT(&p->lfMenuFont),
					"lfStatusFont", new PyLOGFONT(&p->lfStatusFont),
					"lfMessageFont",new PyLOGFONT(&p->lfMessageFont));
			break;
			}
		case SPI_GETMINIMIZEDMETRICS: {
			MINIMIZEDMETRICS *p = (MINIMIZEDMETRICS *)pvParam;
			ret = Py_BuildValue("{s:i,s:i,s:i,s:i}",
					"iWidth", p->iWidth,
					"iHorzGap", p->iHorzGap,
					"iVertGap", p->iVertGap,
					"iArrange", p->iArrange);
			break;
			}
#endif	// !MS_WINCE

		default:
			Py_INCREF(Py_None);
			ret=Py_None;
		}

	done:
	switch (Action){
#ifndef MS_WINCE
		case SPI_GETDESKWALLPAPER:
		case SPI_GETICONTITLELOGFONT:
		case SPI_GETANIMATION:
		case SPI_SETANIMATION:
#endif	// !MS_WINCE
		case SPI_GETNONCLIENTMETRICS:
		case SPI_SETNONCLIENTMETRICS:
		case SPI_GETMINIMIZEDMETRICS:
		case SPI_SETMINIMIZEDMETRICS:
		case SPI_GETMOUSE:
		case SPI_SETMOUSE:
			if (pvParam!=NULL)
				free(pvParam);
			break;
		case SPI_SETDESKWALLPAPER:
			PyWinObject_FreeTCHAR((TCHAR *)pvParam);
			break;
		}
	return ret;
}
PyCFunction pfnPySystemParametersInfo=(PyCFunction)PySystemParametersInfo;

// @pyswig |SetLayeredWindowAttributes|Sets the opacity and transparency color key of a layered window.
// @comm This function only exists on Win2k and later
// @comm Accepts keyword arguments
PyObject *PySetLayeredWindowAttributes(PyObject *self, PyObject *args, PyObject *kwargs)
{
	CHECK_PFN(SetLayeredWindowAttributes);
	static char *keywords[]={"hwnd", "Key", "Alpha", "Flags",  NULL};
	HWND hwnd;
	COLORREF Key;
	BYTE Alpha;
	DWORD Flags;
	PyObject *obhwnd;
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "Okbk:SetLayeredWindowAttributes", keywords,
		&obhwnd,	// @pyparm <o PyHANDLE>|hwnd||handle to the layered window
		&Key,		// @pyparm int|Key||Specifies the color key.  Use <om win32api.RGB> to generate value.
		&Alpha,		// @pyparm int|Alpha||Opacity, in the range 0-255
		&Flags))	// @pyparm int|Flags||Combination of win32con.LWA_* values
		return NULL;
	if (!PyWinObject_AsHANDLE(obhwnd, (HANDLE *)&hwnd))
		return NULL;
	if (!(*pfnSetLayeredWindowAttributes)(hwnd,Key,Alpha,Flags))
		return PyWin_SetAPIError("SetLayeredWindowAttributes");
	Py_INCREF(Py_None);
	return Py_None;
}
PyCFunction pfnPySetLayeredWindowAttributes=(PyCFunction)PySetLayeredWindowAttributes;

// @pyswig (int,int,int)|GetLayeredWindowAttributes|Retrieves the layering parameters of a window with the WS_EX_LAYERED extended style
// @comm This function only exists on WinXP and later.
// @comm Accepts keyword arguments.
// @rdesc Returns a tuple of (color key, alpha, flags)
PyObject *PyGetLayeredWindowAttributes(PyObject *self, PyObject *args, PyObject *kwargs)
{
	CHECK_PFN(GetLayeredWindowAttributes);
	static char *keywords[]={"hwnd",  NULL};
	HWND hwnd;
	COLORREF Key;
	BYTE Alpha;
	DWORD Flags;
	PyObject *obhwnd;
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GetLayeredWindowAttributes", keywords,
		&obhwnd))	// @pyparm <o PyHANDLE>|hwnd||Handle to a layered window
		return NULL;
	if (!PyWinObject_AsHANDLE(obhwnd, (HANDLE *)&hwnd))
		return NULL;
	if (!(*pfnGetLayeredWindowAttributes)(hwnd, &Key, &Alpha, &Flags))
		return PyWin_SetAPIError("GetLayeredWindowAttributes");
	return Py_BuildValue("kbk", Key, Alpha, Flags);
}
PyCFunction pfnPyGetLayeredWindowAttributes=(PyCFunction)PyGetLayeredWindowAttributes;

PyObject *PyUpdateLayeredWindow(PyObject *self, PyObject *args, PyObject *kwargs)
{
	CHECK_PFN(UpdateLayeredWindow);
	static char *keywords[]={"hwnd","hdcDst","ptDst","size","hdcSrc",
		"ptSrc","Key","blend","Flags", NULL};
	HWND hwnd;
	HDC hdcDst, hdcSrc;
	PyObject *obhwnd, *obsrc=Py_None, *obdst=Py_None;
	PyObject *obptSrc=Py_None, *obptDst=Py_None, *obsize=Py_None, *obblend=Py_None;
	COLORREF crKey=0;
	POINT ptSrc, ptDst;
	POINT *pptSrc=NULL, *pptDst=NULL;
	SIZE size;
	SIZE *psize=NULL;
	BLENDFUNCTION blend={0,0,255,0};
	DWORD Flags=0;
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|OOOOOkOk:UpdateLayeredWindow", keywords,
		&obhwnd,	// @pyparm <o PyHANDLE>|hwnd||handle to layered window
		&obdst,		// @pyparm <o PyHANDLE>|hdcDst|None|handle to screen DC, can be None.  *Must* be None if hdcSrc is None
		&obptDst,	// @pyparm (x,y)|ptDst|None|New screen position, can be None.
		&obsize,	// @pyparm (cx, cy)|size|None|New size of the layered window, can be None.  *Must* be None if hdcSrc is None.
		&obsrc,		// @pyparm int|hdcSrc|None|handle to surface DC for the window, can be None
		&obptSrc,	// @pyparm (x,y)|ptSrc|None|layer position, can be None.  *Must* be None if hdcSrc is None.
		&crKey,		// @pyparm int|Key|0|Color key, generate using <om win32api.RGB>
		&obblend,	// @pyparm (int, int, int, int)|blend|(0,0,255,0)|<o PyBLENDFUNCTION> specifying alpha blending parameters
		&Flags))	// @pyparm int|Flags|0|One of the win32con.ULW_* values.  Use 0 if hdcSrc is None.
		return NULL;
	if (!PyWinObject_AsHANDLE(obhwnd, (HANDLE *)&hwnd))
		return NULL;
	if (!PyWinObject_AsHANDLE(obdst, (HANDLE *)&hdcDst))
		return NULL;
	if (!PyWinObject_AsHANDLE(obsrc, (HANDLE *)&hdcSrc))
		return NULL;
	if (obblend!=Py_None)
		if (!PyWinObject_AsBLENDFUNCTION(obblend, &blend))
			return NULL;
	if (obptDst!=Py_None){
		if (!PyWinObject_AsPOINT(obptDst, &ptDst))
			return NULL;
		pptDst=&ptDst;
		}
	if (obsize!=Py_None){
		if (!PyWinObject_AsSIZE(obsize, &size))
			return NULL;
		psize=&size;
		}
	if (obptSrc!=Py_None){
		if (!PyWinObject_AsPOINT(obptSrc, &ptSrc))
			return NULL;
		pptSrc=&ptSrc;
		}

	BOOL ret;
	Py_BEGIN_ALLOW_THREADS
	ret=(*pfnUpdateLayeredWindow)(hwnd, hdcDst, pptDst, psize, hdcSrc, pptSrc, crKey, &blend, Flags);
	Py_END_ALLOW_THREADS
	if (!ret)
		return PyWin_SetAPIError("UpdateLayeredWindow");
	Py_INCREF(Py_None);
	return Py_None;
}
PyCFunction pfnPyUpdateLayeredWindow=(PyCFunction)PyUpdateLayeredWindow;

// @pyswig |AnimateWindow|Enables you to produce special effects when showing or hiding windows. There are three types of animation: roll, slide, and alpha-blended fade.
// @comm This function is available on Win2k and later
// @comm Accepts keyword args
PyObject *PyAnimateWindow(PyObject *self, PyObject *args, PyObject *kwargs)
{
	CHECK_PFN(AnimateWindow);
	static char *keywords[]={"hwnd","Time","Flags", NULL};
	PyObject *obhwnd;
	HWND hwnd;
	DWORD duration, flags;
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "Okk", keywords,
		&obhwnd,	// @pyparm <o PyHANDLE>|hwnd||handle to window
		&duration,	// @pyparm int|Time||Duration of animation in ms
		&flags))	// @pyparm int|Flags||Animation type, combination of win32con.AW_* flags
		return NULL;
	if (!PyWinObject_AsHANDLE(obhwnd, (HANDLE *)&hwnd))
		return NULL;
	BOOL ret;
	Py_BEGIN_ALLOW_THREADS
	ret=(*pfnAnimateWindow)(hwnd, duration, flags);
	Py_END_ALLOW_THREADS
	if (!ret)
		return PyWin_SetAPIError("AnimateWindow");
	Py_INCREF(Py_None);
	return Py_None;
}
PyCFunction pfnPyAnimateWindow=(PyCFunction)PyAnimateWindow;

// @object PyLOGBRUSH|Dict representing a LOGBRUSH struct as used with <om win32gui.CreateBrushIndirect> and <om win32gui.ExtCreatePen>
// @pyseeapi LOGBRUSH
BOOL PyWinObject_AsLOGBRUSH(PyObject *oblb, LOGBRUSH *plb)
{
	static char *keywords[]={"Style","Color","Hatch", NULL};
	PyObject *obhatch;
	if (!PyDict_Check(oblb)){
		PyErr_SetString(PyExc_TypeError,"LOGBRUSH must be a dict");
		return FALSE;
		}
	PyObject *dummy_tuple=PyTuple_New(0);
	if (dummy_tuple==NULL)
		return FALSE;
	BOOL ret=PyArg_ParseTupleAndKeywords(dummy_tuple, oblb, "kkO", keywords,
		&plb->lbStyle,	// @prop int|Style|Brush style, one of win32con.BS_* values
		&plb->lbColor,	// @prop int|Color|RGB color value.  Can also be DIB_PAL_COLORS or DIB_RGB_COLORS if Style is BS_DIBPATTERN or BS_DIBPATTERNPT=
		&obhatch)		// @prop int/<o PyHANDLE>|Hatch|For BS_HATCH style, one of win32con.HS_*. Not used For BS_SOLID or BS_HOLLOW.
						// For a pattern brush, this should be a handle to a bitmap
		&&PyWinObject_AsHANDLE(obhatch, (HANDLE *)&plb->lbHatch);
	Py_DECREF(dummy_tuple);
	return ret;
}

// @pyswig <o PyGdiHANDLE>|CreateBrushIndirect|Creates a GDI brush from a LOGBRUSH struct
static PyObject *PyCreateBrushIndirect(PyObject *self, PyObject *args)
{
	PyObject *oblb;
	LOGBRUSH lb;
	HBRUSH hbrush;
	if (!PyArg_ParseTuple(args, "O:CreateBrushIndirect",
		&oblb))	// @pyparm <o PyLOGBRUSH>|lb||Dict containing brush creation parameters
	return NULL;
	if (!PyWinObject_AsLOGBRUSH(oblb, &lb))
		return NULL;
	hbrush=CreateBrushIndirect(&lb);
	if (hbrush==NULL)
		return PyWin_SetAPIError("CreateBrushIndirect");
	return PyWinObject_FromGdiHANDLE(hbrush);
}

// @pyswig <o PyHANDLE>|ExtCreatePen|Creates a GDI pen object
static PyObject *PyExtCreatePen(PyObject *self, PyObject *args)
{
	PyObject *oblb, *obcustom_style=Py_None;
	LOGBRUSH lb;
	HPEN hpen;
	DWORD style, width, custom_style_cnt;
	DWORD *custom_style=NULL;
	if (!PyArg_ParseTuple(args, "kkO|O:ExtCreatePen",
		&style,		// @pyparm int|PenStyle||Combination of win32con.PS_*.  Must contain either PS_GEOMETRIC or PS_COSMETIC.
		&width,		// @pyparm int|Width||Width of pen in logical units.  Must be 1 for PS_COSMETIC.
		&oblb,		// @pyparm <o PyLOGBRUSH>|lb||Dict containing brush creation parameters
		&obcustom_style))	// @pyparm (int, ...)|Style|None|Sequence containing lengths of dashes and spaces  Used only with PS_USERSTYLE, otherwise must be None.
		return NULL;
	if (!PyWinObject_AsLOGBRUSH(oblb, &lb))
		return NULL;
	if (!PyWinObject_AsDWORDArray(obcustom_style, &custom_style, &custom_style_cnt, TRUE))
		return NULL;
	hpen=ExtCreatePen(style, width, &lb, custom_style_cnt, custom_style);
	if (custom_style)
		free(custom_style);
	if (hpen==NULL)
		return PyWin_SetAPIError("ExtCreatePen");
	return PyWinObject_FromGdiHANDLE(hpen);
}

PyObject *PyDrawTextW(PyObject *self, PyObject *args, PyObject *kwargs)
{
	CHECK_PFN(DrawTextW);
	static char *keywords[]={"hDC","String","Count","Rect","Format", NULL};
	HDC hdc;
	WCHAR *input_text;
	int len, height;
	RECT rc;
	UINT fmt;
	PyObject *obhdc, *obtxt, *obrc;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOiOI:DrawTextW", keywords,
		&obhdc,		// @pyparm <o PyHANDLE>|hDC||Handle to a device context
		&obtxt,		// @pyparm <o PyUnicode>|String||Text to be drawn
		&len,		// @pyparm int|Count||Number of characters to draw, use -1 for entire null terminated string
		&obrc,		// @pyparm <o PyRECT>|Rect||Rectangle in which to draw text
		&fmt))		// @pyparm int|Format||Formatting flags, combination of win32con.DT_* values
		return NULL;
	if (!PyWinObject_AsHANDLE(obhdc, (HANDLE *)&hdc))
		return NULL;
	if (!PyWinObject_AsRECT(obrc, &rc))
		return NULL;
	if (!PyWinObject_AsWCHAR(obtxt, &input_text, FALSE))
		return NULL;

	height=(*pfnDrawTextW)(hdc, input_text, len, &rc, fmt);
	PyWinObject_FreeWCHAR(input_text);
	if (!height)
		return PyWin_SetAPIError("DrawTextW");
	return Py_BuildValue("iN",
		height,
		PyWinObject_FromRECT(&rc));
}
PyCFunction pfnPyDrawTextW=(PyCFunction)PyDrawTextW;

BOOL CALLBACK PyEnumPropsExCallback(HWND hwnd, LPWSTR propname, HANDLE propdata, ULONG_PTR callback_data)
{
	PyObject *args=NULL, *obret=NULL;
	BOOL ret;
	CEnterLeavePython _celp;
	PyObject **callback_objects=(PyObject **)callback_data;
	args=Py_BuildValue("NNNO",
		PyWinLong_FromHANDLE(hwnd),
		IS_INTRESOURCE(propname) ? PyWinLong_FromVoidPtr(propname):PyWinObject_FromWCHAR(propname),
		PyWinLong_FromHANDLE(propdata),
		callback_objects[1]);
	if (args==NULL)
		return FALSE;
	obret=PyObject_Call(callback_objects[0], args, NULL);
	if (obret==NULL)
		ret=FALSE;
	else
		ret=TRUE;

	Py_XDECREF(args);
	Py_XDECREF(obret);
	return ret;
}

// @pyswig |EnumPropsEx|Enumerates properties attached to a window.
// Each property is passed to a callback function, which receives 4 arguments:<nl>
//	Handle to the window, name of the property, handle to the property data, and Param object passed to this function
//  
PyObject *PyEnumPropsEx(PyObject *self, PyObject *args)
{
	HWND hwnd;
	PyObject *obhwnd, *callback, *callback_data;
	PyObject *callback_objects[2];

	if (!PyArg_ParseTuple(args, "OOO:EnumPropsEx",
		&obhwnd,			// @pyparm <o PyHANDLE>|hWnd||Handle to a window
		&callback,			// @pyparm function|EnumFunc||Callback function
		&callback_data))	// @pyparm object|Param||Arbitrary object to be passed to callback function
		return NULL;
	if (!PyWinObject_AsHANDLE(obhwnd, (HANDLE *)&hwnd))
		return NULL;
	if (!PyCallable_Check(callback)){
		PyErr_SetString(PyExc_TypeError,"EnumFunc must be callable");
		return NULL;
		}
	callback_objects[0]=callback;
	callback_objects[1]=callback_data;
	BOOL ok;
	Py_BEGIN_ALLOW_THREADS
	ok = EnumPropsExW(hwnd, PyEnumPropsExCallback, (LPARAM)callback_objects);
	Py_END_ALLOW_THREADS
	if (!ok){
		if (!PyErr_Occurred())
			PyWin_SetAPIError("EnumPropsEx");
		return NULL;
		}
	Py_INCREF(Py_None);
	return Py_None;
}

// @pyswig <o PyHDEVNOTIFY>|RegisterDeviceNotification|Registers the device or type of device for which a window will receive notifications.
PyObject *PyRegisterDeviceNotification(PyObject *self, PyObject *args)
{
	unsigned int flags;
	PyObject *obh, *obFilter;
	if (!PyArg_ParseTuple(args, "OOk:RegisterDeviceNotification",
			      &obh, // @pyparm <o PyHANDLE>|handle||The handle to a window or a service
			      &obFilter, // @pyparm buffer|filter||A buffer laid out like one of the DEV_BROADCAST_* structures, generally built by one of the win32gui_struct helpers.
			      &flags)) // @pyparm int|flags||
		return NULL;
	HANDLE handle;
	if (!PyWinObject_AsHANDLE(obh, &handle))
		return NULL;
	const void *filter;
	Py_ssize_t nbytes;
	if (PyObject_AsReadBuffer(obFilter, &filter, &nbytes)==-1)
		return NULL;
	// basic sanity check.
	Py_ssize_t struct_bytes = ((DEV_BROADCAST_HDR *)filter)->dbch_size;
	if (nbytes != struct_bytes)
		return PyErr_Format(PyExc_ValueError,
				"buffer isn't a DEV_BROADCAST_* structure: "
				"structure says it has %d bytes, but %d was provided",
				(int)struct_bytes, (int)nbytes);
	// @pyseeapi RegisterDeviceNotification
	HDEVNOTIFY not;
	Py_BEGIN_ALLOW_THREADS
	not = RegisterDeviceNotification(handle, (void *)filter, flags);
	Py_END_ALLOW_THREADS
	if (not == NULL)
		return PyWin_SetAPIError("RegisterDeviceNotification");
	return PyWinObject_FromHDEVNOTIFY(not);
}
static PyObject *_wrap_CreateFontIndirect(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HFONT  _result;
    LOGFONT * _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:CreateFontIndirect",&_obj0)) 
        return NULL;
{
	if (!PyLOGFONT_Check(_obj0))
		return PyErr_Format(PyExc_TypeError, "Must be a LOGFONT object (got %s)",
		                    _obj0->ob_type->tp_name);
	_arg0 = &(((PyLOGFONT *)_obj0)->m_LOGFONT);
}
{
	Py_BEGIN_ALLOW_THREADS
	    _result = (HFONT )CreateFontIndirect(_arg0);

	Py_END_ALLOW_THREADS
	if (_result==NULL){
		
		return PyWin_SetAPIError("CreateFontIndirect");
		}
}{
	_resultobj = PyWinObject_FromGdiHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_FlashWindow(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOL  _result;
    HWND  _arg0;
    BOOL  _arg1;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oi:FlashWindow",&_obj0,&_arg1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOL )FlashWindow(_arg0,_arg1);

      Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_GetWindowLong(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    long  _result;
    HWND  _arg0;
    int  _arg1;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oi:GetWindowLong",&_obj0,&_arg1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
    _result = (long )GetWindowLong(_arg0,_arg1);
    _resultobj = Py_BuildValue("l",_result);
    return _resultobj;
}

static PyObject *_wrap_GetClassLong(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    long  _result;
    HWND  _arg0;
    int  _arg1;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oi:GetClassLong",&_obj0,&_arg1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
    _result = (long )GetClassLong(_arg0,_arg1);
    _resultobj = Py_BuildValue("l",_result);
    return _resultobj;
}

static PyObject *_wrap_PostMessage(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HWND  _arg0;
    UINT  _arg1;
    WPARAM  _arg2 = 0;
    LPARAM  _arg3 = 0;
    PyObject * _obj0 = 0;
    PyObject * _obj2 = 0;
    PyObject * _obj3 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oi|OO:PostMessage",&_obj0,&_arg1,&_obj2,&_obj3)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
    if (_obj2)
{
   if (!PyWinObject_AsPARAM(_obj2, &_arg2))
       return NULL;
}
    if (_obj3)
{
   if (!PyWinObject_AsPARAM(_obj3, (WPARAM *)&_arg3))
       return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )PostMessage(_arg0,_arg1,_arg2,_arg3);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("PostMessage");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_PostThreadMessage(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    DWORD  _arg0;
    UINT  _arg1;
    WPARAM  _arg2;
    LPARAM  _arg3;
    PyObject * _obj0 = 0;
    PyObject * _obj2 = 0;
    PyObject * _obj3 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OiOO:PostThreadMessage",&_obj0,&_arg1,&_obj2,&_obj3)) 
        return NULL;
{
	// PyLong_AsUnsignedLongMask isn't ideal - no overflow checking - but
	// this is what the 'k' format specifier in PyArg_ParseTuple uses, and
	// that is what much of pywin32 uses for DWORDS, so we use it here too
	_arg0 = PyLong_AsUnsignedLongMask(_obj0);
	if (_arg0==(DWORD)-1 && PyErr_Occurred())
		return NULL;
}
{
   if (!PyWinObject_AsPARAM(_obj2, &_arg2))
       return NULL;
}
{
   if (!PyWinObject_AsPARAM(_obj3, (WPARAM *)&_arg3))
       return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )PostThreadMessage(_arg0,_arg1,_arg2,_arg3);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("PostThreadMessage");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_ReplyMessage(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    int  _arg0;

    self = self;
    if(!PyArg_ParseTuple(args,"i:ReplyMessage",&_arg0)) 
        return NULL;
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )ReplyMessage(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("ReplyMessage");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_RegisterWindowMessage(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    UINT  _result;
    TCHAR * _arg0;
    PyObject * _obj0 = 0;

    self = self;
{
	_arg0 = NULL;
}
    if(!PyArg_ParseTuple(args,"O:RegisterWindowMessage",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsTCHAR(_obj0, &_arg0, FALSE))
		return NULL;
}
{
    Py_BEGIN_ALLOW_THREADS
        _result = (UINT )RegisterWindowMessage(_arg0);

    Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
{
	PyWinObject_FreeTCHAR(_arg0);
}
    return _resultobj;
}

static PyObject *_wrap_DefWindowProc(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    LRESULT  _result;
    HWND  _arg0;
    UINT  _arg1;
    WPARAM  _arg2;
    LPARAM  _arg3;
    PyObject * _obj0 = 0;
    PyObject * _obj2 = 0;
    PyObject * _obj3 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OiOO:DefWindowProc",&_obj0,&_arg1,&_obj2,&_obj3)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
   if (!PyWinObject_AsPARAM(_obj2, &_arg2))
       return NULL;
}
{
   if (!PyWinObject_AsPARAM(_obj3, (WPARAM *)&_arg3))
       return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (LRESULT )DefWindowProc(_arg0,_arg1,_arg2,_arg3);

      Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("l",_result);
    return _resultobj;
}

static PyObject *_wrap_EndDialog(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HWND  _arg0;
    int  _arg1;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oi:EndDialog",&_obj0,&_arg1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )EndDialog(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("EndDialog");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_GetDlgItem(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HWND  _result;
    HWND  _arg0;
    int  _arg1;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oi:GetDlgItem",&_obj0,&_arg1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HWND )GetDlgItem(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("GetDlgItem", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_SetDlgItemInt(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HWND  _arg0;
    int  _arg1;
    UINT  _arg2;
    BOOL  _arg3;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oiii:SetDlgItemInt",&_obj0,&_arg1,&_arg2,&_arg3)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )SetDlgItemInt(_arg0,_arg1,_arg2,_arg3);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("SetDlgItemInt");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_GetDlgCtrlID(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    HWND  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:GetDlgCtrlID",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
    Py_BEGIN_ALLOW_THREADS
        _result = (int )GetDlgCtrlID(_arg0);

    Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_SetDlgItemText(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HWND  _arg0;
    int  _arg1;
    TCHAR * _arg2;
    PyObject * _obj0 = 0;
    PyObject * _obj2 = 0;

    self = self;
{
	_arg2 = NULL;
}
    if(!PyArg_ParseTuple(args,"OiO:SetDlgItemText",&_obj0,&_arg1,&_obj2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsTCHAR(_obj2, &_arg2, FALSE))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )SetDlgItemText(_arg0,_arg1,_arg2);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           {
	PyWinObject_FreeTCHAR(_arg2);
}

           return PyWin_SetAPIError("SetDlgItemText");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
{
	PyWinObject_FreeTCHAR(_arg2);
}
    return _resultobj;
}

static PyObject *_wrap_GetNextDlgTabItem(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HWND  _result;
    HWND  _arg0;
    HWND  _arg1;
    BOOL  _arg2;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OOi:GetNextDlgTabItem",&_obj0,&_obj1,&_arg2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj1, (HANDLE *)&_arg1))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HWND )GetNextDlgTabItem(_arg0,_arg1,_arg2);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("GetNextDlgTabItem", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_GetNextDlgGroupItem(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HWND  _result;
    HWND  _arg0;
    HWND  _arg1;
    BOOL  _arg2;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OOi:GetNextDlgGroupItem",&_obj0,&_obj1,&_arg2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj1, (HANDLE *)&_arg1))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HWND )GetNextDlgGroupItem(_arg0,_arg1,_arg2);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("GetNextDlgGroupItem", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_SetWindowText(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HWND  _arg0;
    TCHAR * _arg1;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
{
	_arg1 = NULL;
}
    if(!PyArg_ParseTuple(args,"OO:SetWindowText",&_obj0,&_obj1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsTCHAR(_obj1, &_arg1, FALSE))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )SetWindowText(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           {
	PyWinObject_FreeTCHAR(_arg1);
}

           return PyWin_SetAPIError("SetWindowText");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
{
	PyWinObject_FreeTCHAR(_arg1);
}
    return _resultobj;
}

static PyObject *_wrap_GetWindowTextLength(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    HWND  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:GetWindowTextLength",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
    Py_BEGIN_ALLOW_THREADS
        _result = (int )GetWindowTextLength(_arg0);

    Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_InitCommonControls(PyObject *self, PyObject *args) {
    PyObject * _resultobj;

    self = self;
    if(!PyArg_ParseTuple(args,":InitCommonControls")) 
        return NULL;
    InitCommonControls();
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static PyObject *_wrap_LoadCursor(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HCURSOR  _result;
    HINSTANCE  _arg0;
    RESOURCE_ID  _arg1;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
{
	_arg1=NULL;
}
    if(!PyArg_ParseTuple(args,"OO:LoadCursor",&_obj0,&_obj1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsResourceId(_obj1, &_arg1, FALSE))
		return NULL;
}
    _result = (HCURSOR )LoadCursor(_arg0,_arg1);
{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
{
	PyWinObject_FreeResourceId(_arg1);
}
    return _resultobj;
}

static PyObject *_wrap_SetCursor(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HCURSOR  _result;
    HCURSOR  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:SetCursor",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
    _result = (HCURSOR )SetCursor(_arg0);
{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_GetCursor(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HCURSOR  _result;

    self = self;
    if(!PyArg_ParseTuple(args,":GetCursor")) 
        return NULL;
    _result = (HCURSOR )GetCursor();
{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_DestroyAcceleratorTable(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HACCEL  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:DestroyAcceleratorTable",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )DestroyAcceleratorTable(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("DestroyAcceleratorTable");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_LoadMenu(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HMENU  _result;
    HINSTANCE  _arg0;
    RESOURCE_ID  _arg1;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
{
	_arg1=NULL;
}
    if(!PyArg_ParseTuple(args,"OO:LoadMenu",&_obj0,&_obj1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsResourceId(_obj1, &_arg1, FALSE))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HMENU )LoadMenu(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           {
	PyWinObject_FreeResourceId(_arg1);
}

           return PyWin_SetAPIError("LoadMenu", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
{
	PyWinObject_FreeResourceId(_arg1);
}
    return _resultobj;
}

static PyObject *_wrap_DestroyMenu(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HMENU  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:DestroyMenu",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )DestroyMenu(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("DestroyMenu");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_SetMenu(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HWND  _arg0;
    HMENU  _arg1;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OO:SetMenu",&_obj0,&_obj1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj1, (HANDLE *)&_arg1))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )SetMenu(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("SetMenu");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_GetMenu(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HMENU  _result;
    HWND  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:GetMenu",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HMENU )GetMenu(_arg0);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("GetMenu", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_LoadIcon(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HICON  _result;
    HINSTANCE  _arg0;
    RESOURCE_ID  _arg1;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
{
	_arg1=NULL;
}
    if(!PyArg_ParseTuple(args,"OO:LoadIcon",&_obj0,&_obj1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsResourceId(_obj1, &_arg1, FALSE))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HICON )LoadIcon(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           {
	PyWinObject_FreeResourceId(_arg1);
}

           return PyWin_SetAPIError("LoadIcon", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
{
	PyWinObject_FreeResourceId(_arg1);
}
    return _resultobj;
}

static PyObject *_wrap_CopyIcon(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HICON  _result;
    HICON  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:CopyIcon",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HICON )CopyIcon(_arg0);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("CopyIcon", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_DrawIcon(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    int  _arg1;
    int  _arg2;
    HICON  _arg3;
    PyObject * _obj0 = 0;
    PyObject * _obj3 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OiiO:DrawIcon",&_obj0,&_arg1,&_arg2,&_obj3)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj3, (HANDLE *)&_arg3))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )DrawIcon(_arg0,_arg1,_arg2,_arg3);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("DrawIcon");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_DrawIconEx(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    int  _arg1;
    int  _arg2;
    HICON  _arg3;
    int  _arg4;
    int  _arg5;
    int  _arg6;
    HBRUSH  _arg7;
    int  _arg8;
    PyObject * _obj0 = 0;
    PyObject * _obj3 = 0;
    PyObject * _obj7 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OiiOiiiOi:DrawIconEx",&_obj0,&_arg1,&_arg2,&_obj3,&_arg4,&_arg5,&_arg6,&_obj7,&_arg8)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj3, (HANDLE *)&_arg3))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj7, (HANDLE *)&_arg7))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )DrawIconEx(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("DrawIconEx");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_CreateIconIndirect(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HICON  _result;
    ICONINFO * _arg0;
    ICONINFO  iconinfo_input;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:CreateIconIndirect",&_obj0)) 
        return NULL;
{
	PyObject *obmask, *obcolor;
	if (PyTuple_Check(_obj0)) {
		if (!PyArg_ParseTuple(_obj0, "lllOO", 
			&iconinfo_input.fIcon,		// @tupleitem 0|boolean|Icon|True indicates an icon, False for a cursor
			&iconinfo_input.xHotspot,	// @tupleitem 1|int|xHotSpot|For a cursor, X coord of hotspot.  Ignored for icons
			&iconinfo_input.yHotspot,	// @tupleitem 2|int|yHotSpot|For a cursor, Y coord of hotspot.  Ignored for icons
            &obmask,					// @tupleitem 3|<o PyGdiHANDLE>|hbmMask|Monochrome mask bitmap
			&obcolor))					// @tupleitem 4|<o PyGdiHANDLE>|hbmColor|Color bitmap, may be None for black and white icon
			return PyErr_Format(PyExc_TypeError, "%s: an ICONINFO must be a tuple of (int,int,int,HANDLE,HANDLE)", "CreateIconIndirect");

		if (!PyWinObject_AsHANDLE(obmask, (HANDLE *)&iconinfo_input.hbmMask))
			return NULL;
		if (!PyWinObject_AsHANDLE(obcolor, (HANDLE *)&iconinfo_input.hbmColor))
			return NULL;
		_arg0 = &iconinfo_input;
    } else {
		return PyErr_Format(PyExc_TypeError, "%s: an ICONINFO must be a tuple of (int,int,int,HANDLE,HANDLE)", "CreateIconIndirect");
	}
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HICON )CreateIconIndirect(_arg0);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("CreateIconIndirect", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_LoadImage(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HANDLE  _result;
    HINSTANCE  _arg0;
    RESOURCE_ID  _arg1;
    UINT  _arg2;
    int  _arg3;
    int  _arg4;
    UINT  _arg5;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
{
	_arg1=NULL;
}
    if(!PyArg_ParseTuple(args,"OOiiii:LoadImage",&_obj0,&_obj1,&_arg2,&_arg3,&_arg4,&_arg5)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsResourceId(_obj1, &_arg1, FALSE))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (HANDLE )LoadImage(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5);

      Py_END_ALLOW_THREADS
      if (_result==0 || _result==INVALID_HANDLE_VALUE)  {
           {
	PyWinObject_FreeResourceId(_arg1);
}

           return PyWin_SetAPIError("LoadImage");
      }
}{
  _resultobj = PyWinLong_FromHANDLE(_result);
}
{
	PyWinObject_FreeResourceId(_arg1);
}
    return _resultobj;
}

static PyObject *_wrap_BitBlt(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    int  _arg1;
    int  _arg2;
    int  _arg3;
    int  _arg4;
    HDC  _arg5;
    int  _arg6;
    int  _arg7;
    DWORD  _arg8;
    PyObject * _obj0 = 0;
    PyObject * _obj5 = 0;
    PyObject * _obj8 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OiiiiOiiO:BitBlt",&_obj0,&_arg1,&_arg2,&_arg3,&_arg4,&_obj5,&_arg6,&_arg7,&_obj8)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj5, (HANDLE *)&_arg5))
		return NULL;
}
{
	// PyLong_AsUnsignedLongMask isn't ideal - no overflow checking - but
	// this is what the 'k' format specifier in PyArg_ParseTuple uses, and
	// that is what much of pywin32 uses for DWORDS, so we use it here too
	_arg8 = PyLong_AsUnsignedLongMask(_obj8);
	if (_arg8==(DWORD)-1 && PyErr_Occurred())
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )BitBlt(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("BitBlt");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_StretchBlt(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    int  _arg1;
    int  _arg2;
    int  _arg3;
    int  _arg4;
    HDC  _arg5;
    int  _arg6;
    int  _arg7;
    int  _arg8;
    int  _arg9;
    DWORD  _arg10;
    PyObject * _obj0 = 0;
    PyObject * _obj5 = 0;
    PyObject * _obj10 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OiiiiOiiiiO:StretchBlt",&_obj0,&_arg1,&_arg2,&_arg3,&_arg4,&_obj5,&_arg6,&_arg7,&_arg8,&_arg9,&_obj10)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj5, (HANDLE *)&_arg5))
		return NULL;
}
{
	// PyLong_AsUnsignedLongMask isn't ideal - no overflow checking - but
	// this is what the 'k' format specifier in PyArg_ParseTuple uses, and
	// that is what much of pywin32 uses for DWORDS, so we use it here too
	_arg10 = PyLong_AsUnsignedLongMask(_obj10);
	if (_arg10==(DWORD)-1 && PyErr_Occurred())
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )StretchBlt(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8,_arg9,_arg10);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("StretchBlt");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_PatBlt(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    int  _arg1;
    int  _arg2;
    int  _arg3;
    int  _arg4;
    DWORD  _arg5;
    PyObject * _obj0 = 0;
    PyObject * _obj5 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OiiiiO:PatBlt",&_obj0,&_arg1,&_arg2,&_arg3,&_arg4,&_obj5)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	// PyLong_AsUnsignedLongMask isn't ideal - no overflow checking - but
	// this is what the 'k' format specifier in PyArg_ParseTuple uses, and
	// that is what much of pywin32 uses for DWORDS, so we use it here too
	_arg5 = PyLong_AsUnsignedLongMask(_obj5);
	if (_arg5==(DWORD)-1 && PyErr_Occurred())
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )PatBlt(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("PatBlt");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_SetStretchBltMode(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    HDC  _arg0;
    int  _arg1;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oi:SetStretchBltMode",&_obj0,&_arg1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
    Py_BEGIN_ALLOW_THREADS
        _result = (int )SetStretchBltMode(_arg0,_arg1);

    Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_GetStretchBltMode(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    HDC  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:GetStretchBltMode",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
    Py_BEGIN_ALLOW_THREADS
        _result = (int )GetStretchBltMode(_arg0);

    Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_ImageList_Add(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    HIMAGELIST  _arg0;
    HBITMAP  _arg1;
    HBITMAP  _arg2;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;
    PyObject * _obj2 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OOO:ImageList_Add",&_obj0,&_obj1,&_obj2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj1, (HANDLE *)&_arg1))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj2, (HANDLE *)&_arg2))
		return NULL;
}
{
    Py_BEGIN_ALLOW_THREADS
        _result = (int )ImageList_Add(_arg0,_arg1,_arg2);

    Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_ImageList_Create(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HIMAGELIST  _result;
    int  _arg0;
    int  _arg1;
    UINT  _arg2;
    int  _arg3;
    int  _arg4;

    self = self;
    if(!PyArg_ParseTuple(args,"iiiii:ImageList_Create",&_arg0,&_arg1,&_arg2,&_arg3,&_arg4)) 
        return NULL;
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HIMAGELIST )ImageList_Create(_arg0,_arg1,_arg2,_arg3,_arg4);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("ImageList_Create", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_ImageList_Destroy(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HIMAGELIST  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:ImageList_Destroy",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )ImageList_Destroy(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("ImageList_Destroy");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_ImageList_Draw(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HIMAGELIST  _arg0;
    int  _arg1;
    HDC  _arg2;
    int  _arg3;
    int  _arg4;
    UINT  _arg5;
    PyObject * _obj0 = 0;
    PyObject * _obj2 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OiOiii:ImageList_Draw",&_obj0,&_arg1,&_obj2,&_arg3,&_arg4,&_arg5)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj2, (HANDLE *)&_arg2))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )ImageList_Draw(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("ImageList_Draw");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_ImageList_DrawEx(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HIMAGELIST  _arg0;
    int  _arg1;
    HDC  _arg2;
    int  _arg3;
    int  _arg4;
    int  _arg5;
    int  _arg6;
    COLORREF  _arg7;
    COLORREF  _arg8;
    UINT  _arg9;
    PyObject * _obj0 = 0;
    PyObject * _obj2 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OiOiiiilli:ImageList_DrawEx",&_obj0,&_arg1,&_obj2,&_arg3,&_arg4,&_arg5,&_arg6,&_arg7,&_arg8,&_arg9)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj2, (HANDLE *)&_arg2))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )ImageList_DrawEx(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8,_arg9);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("ImageList_DrawEx");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_ImageList_GetIcon(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HICON  _result;
    HIMAGELIST  _arg0;
    int  _arg1;
    UINT  _arg2;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oii:ImageList_GetIcon",&_obj0,&_arg1,&_arg2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HICON )ImageList_GetIcon(_arg0,_arg1,_arg2);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("ImageList_GetIcon", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_ImageList_GetImageCount(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    HIMAGELIST  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:ImageList_GetImageCount",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
    Py_BEGIN_ALLOW_THREADS
        _result = (int )ImageList_GetImageCount(_arg0);

    Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_ImageList_LoadImage(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HIMAGELIST  _result;
    HINSTANCE  _arg0;
    RESOURCE_ID  _arg1;
    int  _arg2;
    int  _arg3;
    COLORREF  _arg4;
    UINT  _arg5;
    UINT  _arg6;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
{
	_arg1=NULL;
}
    if(!PyArg_ParseTuple(args,"OOiilii:ImageList_LoadImage",&_obj0,&_obj1,&_arg2,&_arg3,&_arg4,&_arg5,&_arg6)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsResourceId(_obj1, &_arg1, FALSE))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HIMAGELIST )ImageList_LoadImage(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           {
	PyWinObject_FreeResourceId(_arg1);
}

           return PyWin_SetAPIError("ImageList_LoadImage", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
{
	PyWinObject_FreeResourceId(_arg1);
}
    return _resultobj;
}

static PyObject *_wrap_ImageList_LoadBitmap(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HIMAGELIST  _result;
    HINSTANCE  _arg0;
    TCHAR * _arg1;
    int  _arg2;
    int  _arg3;
    COLORREF  _arg4;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
{
	_arg1 = NULL;
}
    if(!PyArg_ParseTuple(args,"OOiil:ImageList_LoadBitmap",&_obj0,&_obj1,&_arg2,&_arg3,&_arg4)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsTCHAR(_obj1, &_arg1, FALSE))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HIMAGELIST )ImageList_LoadBitmap(_arg0,_arg1,_arg2,_arg3,_arg4);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           {
	PyWinObject_FreeTCHAR(_arg1);
}

           return PyWin_SetAPIError("ImageList_LoadBitmap", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
{
	PyWinObject_FreeTCHAR(_arg1);
}
    return _resultobj;
}

static PyObject *_wrap_ImageList_Remove(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HIMAGELIST  _arg0;
    int  _arg1;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oi:ImageList_Remove",&_obj0,&_arg1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )ImageList_Remove(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("ImageList_Remove");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_ImageList_Replace(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    HIMAGELIST  _arg0;
    int  _arg1;
    HBITMAP  _arg2;
    HBITMAP  _arg3;
    PyObject * _obj0 = 0;
    PyObject * _obj2 = 0;
    PyObject * _obj3 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OiOO:ImageList_Replace",&_obj0,&_arg1,&_obj2,&_obj3)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj2, (HANDLE *)&_arg2))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj3, (HANDLE *)&_arg3))
		return NULL;
}
{
    Py_BEGIN_ALLOW_THREADS
        _result = (int )ImageList_Replace(_arg0,_arg1,_arg2,_arg3);

    Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_ImageList_ReplaceIcon(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    HIMAGELIST  _arg0;
    int  _arg1;
    HICON  _arg2;
    PyObject * _obj0 = 0;
    PyObject * _obj2 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OiO:ImageList_ReplaceIcon",&_obj0,&_arg1,&_obj2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj2, (HANDLE *)&_arg2))
		return NULL;
}
{
    Py_BEGIN_ALLOW_THREADS
        _result = (int )ImageList_ReplaceIcon(_arg0,_arg1,_arg2);

    Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_ImageList_SetBkColor(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    COLORREF  _result;
    HIMAGELIST  _arg0;
    COLORREF  _arg1;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Ol:ImageList_SetBkColor",&_obj0,&_arg1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
    _result = (COLORREF )ImageList_SetBkColor(_arg0,_arg1);
    _resultobj = Py_BuildValue("l",_result);
    return _resultobj;
}

static PyObject *_wrap_ImageList_SetOverlayImage(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HIMAGELIST  _arg0;
    int  _arg1;
    int  _arg2;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oii:ImageList_SetOverlayImage",&_obj0,&_arg1,&_arg2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )ImageList_SetOverlayImage(_arg0,_arg1,_arg2);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("ImageList_SetOverlayImage");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_MessageBox(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    HWND  _arg0;
    TCHAR * _arg1;
    TCHAR * _arg2;
    DWORD  _arg3;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;
    PyObject * _obj2 = 0;
    PyObject * _obj3 = 0;

    self = self;
{
	_arg1 = NULL;
}
{
	_arg2 = NULL;
}
    if(!PyArg_ParseTuple(args,"OOOO:MessageBox",&_obj0,&_obj1,&_obj2,&_obj3)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsTCHAR(_obj1, &_arg1, FALSE))
		return NULL;
}
{
	if (!PyWinObject_AsTCHAR(_obj2, &_arg2, FALSE))
		return NULL;
}
{
	// PyLong_AsUnsignedLongMask isn't ideal - no overflow checking - but
	// this is what the 'k' format specifier in PyArg_ParseTuple uses, and
	// that is what much of pywin32 uses for DWORDS, so we use it here too
	_arg3 = PyLong_AsUnsignedLongMask(_obj3);
	if (_arg3==(DWORD)-1 && PyErr_Occurred())
		return NULL;
}
{
    Py_BEGIN_ALLOW_THREADS
        _result = (int )MessageBox(_arg0,_arg1,_arg2,_arg3);

    Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
{
	PyWinObject_FreeTCHAR(_arg1);
}
{
	PyWinObject_FreeTCHAR(_arg2);
}
    return _resultobj;
}

static PyObject *_wrap_MessageBeep(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    UINT  _arg0;

    self = self;
    if(!PyArg_ParseTuple(args,"i:MessageBeep",&_arg0)) 
        return NULL;
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )MessageBeep(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("MessageBeep");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_CreateWindow(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HWND  _result;
    STRING_OR_ATOM_CW  _arg0;
    TCHAR * _arg1;
    DWORD  _arg2;
    int  _arg3;
    int  _arg4;
    int  _arg5;
    int  _arg6;
    HWND  _arg7;
    HMENU  _arg8;
    HINSTANCE  _arg9;
    NULL_ONLY  _arg10;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;
    PyObject * _obj2 = 0;
    PyObject * _obj7 = 0;
    PyObject * _obj8 = 0;
    PyObject * _obj9 = 0;
    PyObject * _obj10 = 0;

    self = self;
{
	_arg0=NULL;
}
{
	_arg1 = NULL;
}
    if(!PyArg_ParseTuple(args,"OOOiiiiOOOO:CreateWindow",&_obj0,&_obj1,&_obj2,&_arg3,&_arg4,&_arg5,&_arg6,&_obj7,&_obj8,&_obj9,&_obj10)) 
        return NULL;
{
	if (!PyWinObject_AsResourceId(_obj0, &_arg0, TRUE))
		return NULL;
}
{
	if (!PyWinObject_AsTCHAR(_obj1, &_arg1, TRUE))
		return NULL;
}
{
	// PyLong_AsUnsignedLongMask isn't ideal - no overflow checking - but
	// this is what the 'k' format specifier in PyArg_ParseTuple uses, and
	// that is what much of pywin32 uses for DWORDS, so we use it here too
	_arg2 = PyLong_AsUnsignedLongMask(_obj2);
	if (_arg2==(DWORD)-1 && PyErr_Occurred())
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj7, (HANDLE *)&_arg7))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj8, (HANDLE *)&_arg8))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj9, (HANDLE *)&_arg9))
		return NULL;
}
{
	if (_obj10 != Py_None) {
		PyErr_SetString(PyExc_TypeError, "This param must be None");
		return NULL;
	}
	_arg10 = NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HWND )CreateWindow(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8,_arg9,_arg10);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           {
	// Look up the WNDCLASS object by either atom->wndclass or name->atom->wndclass to set window proc
	PyObject *obwc=NULL;
	if (_result) {
		if (IS_INTRESOURCE(_arg0))
			obwc = PyDict_GetItem(g_AtomMap, _obj0);
		else{
			// Use the name to retrieve the atom, and use it to retrieve the PyWNDCLASS
			PyObject *obatom=PyDict_GetItem(g_AtomMap, _obj0);
			if (obatom!=NULL)
				obwc = PyDict_GetItem(g_AtomMap, obatom);
			}
		// A HUGE HACK - set the class extra bytes.
		if (obwc)
			SetClassLongPtr(_result, 0, (LONG_PTR)((PyWNDCLASS *)obwc)->m_obWndProc);
		}
	PyWinObject_FreeResourceId(_arg0);
}
{
	PyWinObject_FreeTCHAR(_arg1);
}

           return PyWin_SetAPIError("CreateWindow", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
{
	// Look up the WNDCLASS object by either atom->wndclass or name->atom->wndclass to set window proc
	PyObject *obwc=NULL;
	if (_result) {
		if (IS_INTRESOURCE(_arg0))
			obwc = PyDict_GetItem(g_AtomMap, _obj0);
		else{
			// Use the name to retrieve the atom, and use it to retrieve the PyWNDCLASS
			PyObject *obatom=PyDict_GetItem(g_AtomMap, _obj0);
			if (obatom!=NULL)
				obwc = PyDict_GetItem(g_AtomMap, obatom);
			}
		// A HUGE HACK - set the class extra bytes.
		if (obwc)
			SetClassLongPtr(_result, 0, (LONG_PTR)((PyWNDCLASS *)obwc)->m_obWndProc);
		}
	PyWinObject_FreeResourceId(_arg0);
}
{
	PyWinObject_FreeTCHAR(_arg1);
}
    return _resultobj;
}

static PyObject *_wrap_DestroyWindow(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HWND  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:DestroyWindow",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )DestroyWindow(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("DestroyWindow");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_EnableWindow(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOL  _result;
    HWND  _arg0;
    BOOL  _arg1;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oi:EnableWindow",&_obj0,&_arg1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOL )EnableWindow(_arg0,_arg1);

      Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_FindWindow(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HWND  _result;
    RESOURCE_ID_NULLOK  _arg0;
    TCHAR * _arg1;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
{
	_arg0=NULL;
}
{
	_arg1 = NULL;
}
    if(!PyArg_ParseTuple(args,"OO:FindWindow",&_obj0,&_obj1)) 
        return NULL;
{
	if (!PyWinObject_AsResourceId(_obj0, &_arg0, TRUE))
		return NULL;
}
{
	if (!PyWinObject_AsTCHAR(_obj1, &_arg1, TRUE))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HWND )FindWindow(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           {
	PyWinObject_FreeResourceId(_arg0);
}
{
	PyWinObject_FreeTCHAR(_arg1);
}

           return PyWin_SetAPIError("FindWindow", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
{
	PyWinObject_FreeResourceId(_arg0);
}
{
	PyWinObject_FreeTCHAR(_arg1);
}
    return _resultobj;
}

static PyObject *_wrap_FindWindowEx(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HWND  _result;
    HWND  _arg0;
    HWND  _arg1;
    RESOURCE_ID_NULLOK  _arg2;
    TCHAR * _arg3;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;
    PyObject * _obj2 = 0;
    PyObject * _obj3 = 0;

    self = self;
{
	_arg2=NULL;
}
{
	_arg3 = NULL;
}
    if(!PyArg_ParseTuple(args,"OOOO:FindWindowEx",&_obj0,&_obj1,&_obj2,&_obj3)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj1, (HANDLE *)&_arg1))
		return NULL;
}
{
	if (!PyWinObject_AsResourceId(_obj2, &_arg2, TRUE))
		return NULL;
}
{
	if (!PyWinObject_AsTCHAR(_obj3, &_arg3, TRUE))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HWND )FindWindowEx(_arg0,_arg1,_arg2,_arg3);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           {
	PyWinObject_FreeResourceId(_arg2);
}
{
	PyWinObject_FreeTCHAR(_arg3);
}

           return PyWin_SetAPIError("FindWindowEx", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
{
	PyWinObject_FreeResourceId(_arg2);
}
{
	PyWinObject_FreeTCHAR(_arg3);
}
    return _resultobj;
}

static PyObject *_wrap_DragAcceptFiles(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HWND  _arg0;
    BOOL  _arg1;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oi:DragAcceptFiles",&_obj0,&_arg1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
    DragAcceptFiles(_arg0,_arg1);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static PyObject *_wrap_DragDetect(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOL  _result;
    HWND  _arg0;
    POINT * _arg1;
    PyObject * _obj0 = 0;
    POINT  point_input;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OO:DragDetect",&_obj0,&_obj1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsPOINT(_obj1, &point_input))
		return NULL;
	_arg1 = &point_input;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOL )DragDetect(_arg0,*_arg1);

      Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_SetDoubleClickTime(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    UINT  _arg0;

    self = self;
    if(!PyArg_ParseTuple(args,"i:SetDoubleClickTime",&_arg0)) 
        return NULL;
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )SetDoubleClickTime(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("SetDoubleClickTime");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_GetDoubleClickTime(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    UINT  _result;

    self = self;
    if(!PyArg_ParseTuple(args,":GetDoubleClickTime")) 
        return NULL;
{
    Py_BEGIN_ALLOW_THREADS
        _result = (UINT )GetDoubleClickTime();

    Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_HideCaret(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HWND  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:HideCaret",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )HideCaret(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("HideCaret");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_SetCaretPos(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    int  _arg0;
    int  _arg1;

    self = self;
    if(!PyArg_ParseTuple(args,"ii:SetCaretPos",&_arg0,&_arg1)) 
        return NULL;
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )SetCaretPos(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("SetCaretPos");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_GetCaretPos(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    POINT * _arg0;
    POINT  point_output;

    self = self;
{
  _arg0 = &point_output;
}
    if(!PyArg_ParseTuple(args,":GetCaretPos")) 
        return NULL;
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )GetCaretPos(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("GetCaretPos");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
{
    PyObject *o;
    o = Py_BuildValue("ll", _arg0->x, _arg0->y);
    if (!_resultobj) {
      _resultobj = o;
    } else if (_resultobj == Py_None) {
      Py_DECREF(Py_None);
      _resultobj = o;
    } else {
      if (!PyList_Check(_resultobj)) {
	PyObject *o2 = _resultobj;
	_resultobj = PyList_New(0);
	PyList_Append(_resultobj,o2);
	Py_XDECREF(o2);
      }
      PyList_Append(_resultobj,o);
      Py_XDECREF(o);
    }
}
    return _resultobj;
}

static PyObject *_wrap_ShowCaret(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HWND  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:ShowCaret",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )ShowCaret(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("ShowCaret");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_ShowWindow(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOL  _result;
    HWND  _arg0;
    int  _arg1;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oi:ShowWindow",&_obj0,&_arg1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOL )ShowWindow(_arg0,_arg1);

      Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_IsWindowVisible(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOL  _result;
    HWND  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:IsWindowVisible",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOL )IsWindowVisible(_arg0);

      Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_IsWindowEnabled(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOL  _result;
    HWND  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:IsWindowEnabled",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOL )IsWindowEnabled(_arg0);

      Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_SetFocus(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HWND  _result;
    HWND  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:SetFocus",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HWND )SetFocus(_arg0);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("SetFocus", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_GetFocus(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HWND  _result;

    self = self;
    if(!PyArg_ParseTuple(args,":GetFocus")) 
        return NULL;
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HWND )GetFocus();

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("GetFocus", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_UpdateWindow(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HWND  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:UpdateWindow",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )UpdateWindow(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("UpdateWindow");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_BringWindowToTop(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HWND  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:BringWindowToTop",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )BringWindowToTop(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("BringWindowToTop");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_SetActiveWindow(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HWND  _result;
    HWND  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:SetActiveWindow",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HWND )SetActiveWindow(_arg0);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("SetActiveWindow", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_GetActiveWindow(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HWND  _result;

    self = self;
    if(!PyArg_ParseTuple(args,":GetActiveWindow")) 
        return NULL;
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HWND )GetActiveWindow();

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("GetActiveWindow", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_SetForegroundWindow(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HWND  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:SetForegroundWindow",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )SetForegroundWindow(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("SetForegroundWindow");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_GetForegroundWindow(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HWND  _result;

    self = self;
    if(!PyArg_ParseTuple(args,":GetForegroundWindow")) 
        return NULL;
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HWND )GetForegroundWindow();

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("GetForegroundWindow", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_GetClientRect(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HWND  _arg0;
    RECT * _arg1;
    RECT  rect_output;
    PyObject * _obj0 = 0;

    self = self;
{
  _arg1 = &rect_output;
}
    if(!PyArg_ParseTuple(args,"O:GetClientRect",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )GetClientRect(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("GetClientRect");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
{
    PyObject *o;
    o = Py_BuildValue("llll", _arg1->left, _arg1->top, _arg1->right, _arg1->bottom);
    if (!_resultobj) {
      _resultobj = o;
    } else if (_resultobj == Py_None) {
      Py_DECREF(Py_None);
      _resultobj = o;
    } else {
      if (!PyList_Check(_resultobj)) {
	PyObject *o2 = _resultobj;
	_resultobj = PyList_New(0);
	PyList_Append(_resultobj,o2);
	Py_XDECREF(o2);
      }
      PyList_Append(_resultobj,o);
      Py_XDECREF(o);
    }
}
    return _resultobj;
}

static PyObject *_wrap_GetDC(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HDC  _result;
    HWND  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:GetDC",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HDC )GetDC(_arg0);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("GetDC", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_SaveDC(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    HDC  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:SaveDC",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
    Py_BEGIN_ALLOW_THREADS
        _result = (int )SaveDC(_arg0);

    Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_RestoreDC(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    int  _arg1;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oi:RestoreDC",&_obj0,&_arg1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )RestoreDC(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("RestoreDC");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_DeleteDC(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:DeleteDC",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )DeleteDC(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("DeleteDC");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_CreateCompatibleDC(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HDC  _result;
    HDC  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:CreateCompatibleDC",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HDC )CreateCompatibleDC(_arg0);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("CreateCompatibleDC", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_CreateCompatibleBitmap(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HBITMAP  _result;
    HDC  _arg0;
    int  _arg1;
    int  _arg2;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oii:CreateCompatibleBitmap",&_obj0,&_arg1,&_arg2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HBITMAP )CreateCompatibleBitmap(_arg0,_arg1,_arg2);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("CreateCompatibleBitmap", le);
      }
}{
	_resultobj = PyWinObject_FromGdiHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_CreateBitmap(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HBITMAP  _result;
    int  _arg0;
    int  _arg1;
    UINT  _arg2;
    UINT  _arg3;
    NULL_ONLY  _arg4;
    PyObject * _obj4 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"iiiiO:CreateBitmap",&_arg0,&_arg1,&_arg2,&_arg3,&_obj4)) 
        return NULL;
{
	if (_obj4 != Py_None) {
		PyErr_SetString(PyExc_TypeError, "This param must be None");
		return NULL;
	}
	_arg4 = NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HBITMAP )CreateBitmap(_arg0,_arg1,_arg2,_arg3,_arg4);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("CreateBitmap", le);
      }
}{
	_resultobj = PyWinObject_FromGdiHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_SelectObject(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HGDIOBJ  _result;
    HDC  _arg0;
    HGDIOBJ  _arg1;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OO:SelectObject",&_obj0,&_obj1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj1, (HANDLE *)&_arg1))
		return NULL;
}
    _result = (HGDIOBJ )SelectObject(_arg0,_arg1);
{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_GetCurrentObject(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HGDIOBJ  _result;
    HDC  _arg0;
    UINT  _arg1;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oi:GetCurrentObject",&_obj0,&_arg1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
    _result = (HGDIOBJ )GetCurrentObject(_arg0,_arg1);
{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_GetModuleHandle(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HINSTANCE  _result;
    TCHAR * _arg0;
    PyObject * _obj0 = 0;

    self = self;
{
	_arg0 = NULL;
}
    if(!PyArg_ParseTuple(args,"O:GetModuleHandle",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsTCHAR(_obj0, &_arg0, TRUE))
		return NULL;
}
    _result = (HINSTANCE )GetModuleHandle(_arg0);
{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
{
	PyWinObject_FreeTCHAR(_arg0);
}
    return _resultobj;
}

static PyObject *_wrap_GetWindowRect(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HWND  _arg0;
    RECT * _arg1;
    RECT  rect_output;
    PyObject * _obj0 = 0;

    self = self;
{
  _arg1 = &rect_output;
}
    if(!PyArg_ParseTuple(args,"O:GetWindowRect",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )GetWindowRect(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("GetWindowRect");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
{
    PyObject *o;
    o = Py_BuildValue("llll", _arg1->left, _arg1->top, _arg1->right, _arg1->bottom);
    if (!_resultobj) {
      _resultobj = o;
    } else if (_resultobj == Py_None) {
      Py_DECREF(Py_None);
      _resultobj = o;
    } else {
      if (!PyList_Check(_resultobj)) {
	PyObject *o2 = _resultobj;
	_resultobj = PyList_New(0);
	PyList_Append(_resultobj,o2);
	Py_XDECREF(o2);
      }
      PyList_Append(_resultobj,o);
      Py_XDECREF(o);
    }
}
    return _resultobj;
}

static PyObject *_wrap_GetStockObject(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HGDIOBJ  _result;
    int  _arg0;

    self = self;
    if(!PyArg_ParseTuple(args,"i:GetStockObject",&_arg0)) 
        return NULL;
    _result = (HGDIOBJ )GetStockObject(_arg0);
{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_PostQuitMessage(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _arg0;

    self = self;
    if(!PyArg_ParseTuple(args,"i:PostQuitMessage",&_arg0)) 
        return NULL;
    PostQuitMessage(_arg0);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static PyObject *_wrap_WaitMessage(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;

    self = self;
    if(!PyArg_ParseTuple(args,":WaitMessage")) 
        return NULL;
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )WaitMessage();

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("WaitMessage");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_SetWindowPos(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HWND  _arg0;
    HWND  _arg1;
    int  _arg2;
    int  _arg3;
    int  _arg4;
    int  _arg5;
    UINT  _arg6;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OOiiiii:SetWindowPos",&_obj0,&_obj1,&_arg2,&_arg3,&_arg4,&_arg5,&_arg6)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj1, (HANDLE *)&_arg1))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )SetWindowPos(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("SetWindowPos");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_GetMessage(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOL  _result;
    MSG * _arg0;
    MSG  temp;
    HWND  _arg1;
    UINT  _arg2;
    UINT  _arg3;
    PyObject * _obj1 = 0;

    self = self;
{
  _arg0 = &temp;
  memset(_arg0, 0, sizeof(MSG));
}
    if(!PyArg_ParseTuple(args,"Oii:GetMessage",&_obj1,&_arg2,&_arg3)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj1, (HANDLE *)&_arg1))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOL )GetMessage(_arg0,_arg1,_arg2,_arg3);

      Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
{
    PyObject *o = PyWinObject_FromMSG(_arg0);
    if (!_resultobj) {
      _resultobj = o;
    } else if (_resultobj == Py_None) {
      Py_DECREF(Py_None);
      _resultobj = o;
    } else {
      if (!PyList_Check(_resultobj)) {
	PyObject *o2 = _resultobj;
	_resultobj = PyList_New(0);
	PyList_Append(_resultobj,o2);
	Py_XDECREF(o2);
      }
      PyList_Append(_resultobj,o);
      Py_XDECREF(o);
    }
}
    return _resultobj;
}

static PyObject *_wrap_TranslateMessage(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOL  _result;
    MSG * _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:TranslateMessage",&_obj0)) 
        return NULL;
{
    _arg0 = (MSG *)_alloca(sizeof(MSG));
    if (!PyWinObject_AsMSG(_obj0, _arg0))
        return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOL )TranslateMessage(_arg0);

      Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_DispatchMessage(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    LRESULT  _result;
    MSG * _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:DispatchMessage",&_obj0)) 
        return NULL;
{
    _arg0 = (MSG *)_alloca(sizeof(MSG));
    if (!PyWinObject_AsMSG(_obj0, _arg0))
        return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (LRESULT )DispatchMessage(_arg0);

      Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("l",_result);
    return _resultobj;
}

static PyObject *_wrap_TranslateAccelerator(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    HWND  _arg0;
    HACCEL  _arg1;
    MSG * _arg2;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;
    PyObject * _obj2 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OOO:TranslateAccelerator",&_obj0,&_obj1,&_obj2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj1, (HANDLE *)&_arg1))
		return NULL;
}
{
    _arg2 = (MSG *)_alloca(sizeof(MSG));
    if (!PyWinObject_AsMSG(_obj2, _arg2))
        return NULL;
}
{
    Py_BEGIN_ALLOW_THREADS
        _result = (int )TranslateAccelerator(_arg0,_arg1,_arg2);

    Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_PeekMessage(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOL  _result;
    MSG * _arg0;
    MSG  temp;
    HWND  _arg1;
    UINT  _arg2;
    UINT  _arg3;
    UINT  _arg4;
    PyObject * _obj1 = 0;

    self = self;
{
  _arg0 = &temp;
  memset(_arg0, 0, sizeof(MSG));
}
    if(!PyArg_ParseTuple(args,"Oiii:PeekMessage",&_obj1,&_arg2,&_arg3,&_arg4)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj1, (HANDLE *)&_arg1))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOL )PeekMessage(_arg0,_arg1,_arg2,_arg3,_arg4);

      Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
{
    PyObject *o = PyWinObject_FromMSG(_arg0);
    if (!_resultobj) {
      _resultobj = o;
    } else if (_resultobj == Py_None) {
      Py_DECREF(Py_None);
      _resultobj = o;
    } else {
      if (!PyList_Check(_resultobj)) {
	PyObject *o2 = _resultobj;
	_resultobj = PyList_New(0);
	PyList_Append(_resultobj,o2);
	Py_XDECREF(o2);
      }
      PyList_Append(_resultobj,o);
      Py_XDECREF(o);
    }
}
    return _resultobj;
}

static PyObject *_wrap_Shell_NotifyIcon(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    DWORD  _arg0;
    NOTIFYICONDATA * _arg1;
    NOTIFYICONDATA  nid;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
{
	ZeroMemory(&nid, sizeof(nid));
	_arg1 = &nid;
}
    if(!PyArg_ParseTuple(args,"OO:Shell_NotifyIcon",&_obj0,&_obj1)) 
        return NULL;
{
	// PyLong_AsUnsignedLongMask isn't ideal - no overflow checking - but
	// this is what the 'k' format specifier in PyArg_ParseTuple uses, and
	// that is what much of pywin32 uses for DWORDS, so we use it here too
	_arg0 = PyLong_AsUnsignedLongMask(_obj0);
	if (_arg0==(DWORD)-1 && PyErr_Occurred())
		return NULL;
}
{
	if (!PyObject_AsNOTIFYICONDATA(_obj1, _arg1))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )Shell_NotifyIcon(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("Shell_NotifyIcon");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_GetSystemMenu(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HMENU  _result;
    HWND  _arg0;
    BOOL  _arg1;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oi:GetSystemMenu",&_obj0,&_arg1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HMENU )GetSystemMenu(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("GetSystemMenu", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_DrawMenuBar(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HWND  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:DrawMenuBar",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )DrawMenuBar(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("DrawMenuBar");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_MoveWindow(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HWND  _arg0;
    int  _arg1;
    int  _arg2;
    int  _arg3;
    int  _arg4;
    BOOL  _arg5;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oiiiii:MoveWindow",&_obj0,&_arg1,&_arg2,&_arg3,&_arg4,&_arg5)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )MoveWindow(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("MoveWindow");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_CloseWindow(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HWND  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:CloseWindow",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )CloseWindow(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("CloseWindow");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_DeleteMenu(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HMENU  _arg0;
    UINT  _arg1;
    UINT  _arg2;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oii:DeleteMenu",&_obj0,&_arg1,&_arg2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )DeleteMenu(_arg0,_arg1,_arg2);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("DeleteMenu");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_RemoveMenu(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HMENU  _arg0;
    UINT  _arg1;
    UINT  _arg2;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oii:RemoveMenu",&_obj0,&_arg1,&_arg2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )RemoveMenu(_arg0,_arg1,_arg2);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("RemoveMenu");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_CreateMenu(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HMENU  _result;

    self = self;
    if(!PyArg_ParseTuple(args,":CreateMenu")) 
        return NULL;
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HMENU )CreateMenu();

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("CreateMenu", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_CreatePopupMenu(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HMENU  _result;

    self = self;
    if(!PyArg_ParseTuple(args,":CreatePopupMenu")) 
        return NULL;
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HMENU )CreatePopupMenu();

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("CreatePopupMenu", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_TrackPopupMenu(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOL  _result;
    HMENU  _arg0;
    UINT  _arg1;
    int  _arg2;
    int  _arg3;
    int  _arg4;
    HWND  _arg5;
    RECT * _arg6;
    PyObject * _obj0 = 0;
    PyObject * _obj5 = 0;
    RECT  rect_input_nullok;
    PyObject * _obj6 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OiiiiOO:TrackPopupMenu",&_obj0,&_arg1,&_arg2,&_arg3,&_arg4,&_obj5,&_obj6)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj5, (HANDLE *)&_arg5))
		return NULL;
}
{
	if (PyTuple_Check(_obj6)) {
		if (PyArg_ParseTuple(_obj6, "llll", &rect_input_nullok.left, &rect_input_nullok.top, &rect_input_nullok.right, &rect_input_nullok.bottom) == 0) {
			return PyErr_Format(PyExc_TypeError, "%s: This param must be a tuple of four integers or None", "TrackPopupMenu");
		}
		_arg6 = &rect_input_nullok;
	} else {
		if (_obj6 == Py_None) {
            _arg6 = NULL;
        } else {
            PyErr_SetString(PyExc_TypeError, "This param must be a tuple of four integers or None");
            return NULL;
		}
	}
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOL )TrackPopupMenu(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6);

      Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_CommDlgExtendedError(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    DWORD  _result;

    self = self;
    if(!PyArg_ParseTuple(args,":CommDlgExtendedError")) 
        return NULL;
    _result = (DWORD )CommDlgExtendedError();
    _resultobj = Py_BuildValue("l",_result);
    return _resultobj;
}

static PyObject *_wrap_ExtractIcon(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HICON  _result;
    HINSTANCE  _arg0;
    TCHAR * _arg1;
    UINT  _arg2;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
{
	_arg1 = NULL;
}
    if(!PyArg_ParseTuple(args,"OOi:ExtractIcon",&_obj0,&_obj1,&_arg2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsTCHAR(_obj1, &_arg1, FALSE))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HICON )ExtractIcon(_arg0,_arg1,_arg2);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           {
	PyWinObject_FreeTCHAR(_arg1);
}

           return PyWin_SetAPIError("ExtractIcon", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
{
	PyWinObject_FreeTCHAR(_arg1);
}
    return _resultobj;
}

static PyObject *_wrap_DestroyIcon(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HICON  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:DestroyIcon",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )DestroyIcon(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("DestroyIcon");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_GetIconInfo(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HICON  _arg0;
    ICONINFO * _arg1;
    ICONINFO  temp;
    PyObject * _obj0 = 0;

    self = self;
{
  _arg1 = &temp;
}
    if(!PyArg_ParseTuple(args,"O:GetIconInfo",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )GetIconInfo(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("GetIconInfo");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
{
    PyObject *o;
    o = Py_BuildValue("lllNN", _arg1->fIcon, _arg1->xHotspot, _arg1->yHotspot, 
		PyWinObject_FromGdiHANDLE(_arg1->hbmMask), PyWinObject_FromGdiHANDLE(_arg1->hbmColor));
    if (!_resultobj) {
      _resultobj = o;
    } else if (_resultobj == Py_None) {
      Py_DECREF(Py_None);
      _resultobj = o;
    } else {
      if (!PyList_Check(_resultobj)) {
	PyObject *o2 = _resultobj;
	_resultobj = PyList_New(0);
	PyList_Append(_resultobj,o2);
	Py_XDECREF(o2);
      }
      PyList_Append(_resultobj,o);
      Py_XDECREF(o);
    }
}
    return _resultobj;
}

static PyObject *_wrap_ScreenToClient(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HWND  _arg0;
    POINT * _arg1;
    PyObject * _obj0 = 0;
    POINT  point_input;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OO:ScreenToClient",&_obj0,&_obj1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsPOINT(_obj1, &point_input))
		return NULL;
	_arg1 = &point_input;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )ScreenToClient(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("ScreenToClient");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
{
    PyObject *o;
    o = Py_BuildValue("ll", _arg1->x, _arg1->y);
    if (!_resultobj) {
      _resultobj = o;
    } else if (_resultobj == Py_None) {
      Py_DECREF(Py_None);
      _resultobj = o;
    } else {
      if (!PyList_Check(_resultobj)) {
	PyObject *o2 = _resultobj;
	_resultobj = PyList_New(0);
	PyList_Append(_resultobj,o2);
	Py_XDECREF(o2);
      }
      PyList_Append(_resultobj,o);
      Py_XDECREF(o);
    }
}
    return _resultobj;
}

static PyObject *_wrap_ClientToScreen(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HWND  _arg0;
    POINT * _arg1;
    PyObject * _obj0 = 0;
    POINT  point_input;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OO:ClientToScreen",&_obj0,&_obj1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsPOINT(_obj1, &point_input))
		return NULL;
	_arg1 = &point_input;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )ClientToScreen(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("ClientToScreen");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
{
    PyObject *o;
    o = Py_BuildValue("ll", _arg1->x, _arg1->y);
    if (!_resultobj) {
      _resultobj = o;
    } else if (_resultobj == Py_None) {
      Py_DECREF(Py_None);
      _resultobj = o;
    } else {
      if (!PyList_Check(_resultobj)) {
	PyObject *o2 = _resultobj;
	_resultobj = PyList_New(0);
	PyList_Append(_resultobj,o2);
	Py_XDECREF(o2);
      }
      PyList_Append(_resultobj,o);
      Py_XDECREF(o);
    }
}
    return _resultobj;
}

static PyObject *_wrap_PaintDesktop(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:PaintDesktop",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )PaintDesktop(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("PaintDesktop");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_RedrawWindow(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HWND  _arg0;
    RECT * _arg1;
    HRGN  _arg2;
    UINT  _arg3;
    PyObject * _obj0 = 0;
    RECT  rect_input_nullok;
    PyObject * _obj1 = 0;
    PyObject * _obj2 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OOOi:RedrawWindow",&_obj0,&_obj1,&_obj2,&_arg3)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (PyTuple_Check(_obj1)) {
		if (PyArg_ParseTuple(_obj1, "llll", &rect_input_nullok.left, &rect_input_nullok.top, &rect_input_nullok.right, &rect_input_nullok.bottom) == 0) {
			return PyErr_Format(PyExc_TypeError, "%s: This param must be a tuple of four integers or None", "RedrawWindow");
		}
		_arg1 = &rect_input_nullok;
	} else {
		if (_obj1 == Py_None) {
            _arg1 = NULL;
        } else {
            PyErr_SetString(PyExc_TypeError, "This param must be a tuple of four integers or None");
            return NULL;
		}
	}
}
{
	if (!PyWinObject_AsHANDLE(_obj2, (HANDLE *)&_arg2))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )RedrawWindow(_arg0,_arg1,_arg2,_arg3);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("RedrawWindow");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_GetWindowOrgEx(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    POINT * _arg1;
    POINT  point_output;
    PyObject * _obj0 = 0;

    self = self;
{
  _arg1 = &point_output;
}
    if(!PyArg_ParseTuple(args,"O:GetWindowOrgEx",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )GetWindowOrgEx(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("GetWindowOrgEx");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
{
    PyObject *o;
    o = Py_BuildValue("ll", _arg1->x, _arg1->y);
    if (!_resultobj) {
      _resultobj = o;
    } else if (_resultobj == Py_None) {
      Py_DECREF(Py_None);
      _resultobj = o;
    } else {
      if (!PyList_Check(_resultobj)) {
	PyObject *o2 = _resultobj;
	_resultobj = PyList_New(0);
	PyList_Append(_resultobj,o2);
	Py_XDECREF(o2);
      }
      PyList_Append(_resultobj,o);
      Py_XDECREF(o);
    }
}
    return _resultobj;
}

static PyObject *_wrap_SetWindowOrgEx(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    int  _arg1;
    int  _arg2;
    POINT * _arg3;
    POINT  point_output;
    PyObject * _obj0 = 0;

    self = self;
{
  _arg3 = &point_output;
}
    if(!PyArg_ParseTuple(args,"Oii:SetWindowOrgEx",&_obj0,&_arg1,&_arg2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )SetWindowOrgEx(_arg0,_arg1,_arg2,_arg3);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("SetWindowOrgEx");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
{
    PyObject *o;
    o = Py_BuildValue("ll", _arg3->x, _arg3->y);
    if (!_resultobj) {
      _resultobj = o;
    } else if (_resultobj == Py_None) {
      Py_DECREF(Py_None);
      _resultobj = o;
    } else {
      if (!PyList_Check(_resultobj)) {
	PyObject *o2 = _resultobj;
	_resultobj = PyList_New(0);
	PyList_Append(_resultobj,o2);
	Py_XDECREF(o2);
      }
      PyList_Append(_resultobj,o);
      Py_XDECREF(o);
    }
}
    return _resultobj;
}

static PyObject *_wrap_GetViewportOrgEx(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    POINT * _arg1;
    POINT  point_output;
    PyObject * _obj0 = 0;

    self = self;
{
  _arg1 = &point_output;
}
    if(!PyArg_ParseTuple(args,"O:GetViewportOrgEx",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )GetViewportOrgEx(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("GetViewportOrgEx");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
{
    PyObject *o;
    o = Py_BuildValue("ll", _arg1->x, _arg1->y);
    if (!_resultobj) {
      _resultobj = o;
    } else if (_resultobj == Py_None) {
      Py_DECREF(Py_None);
      _resultobj = o;
    } else {
      if (!PyList_Check(_resultobj)) {
	PyObject *o2 = _resultobj;
	_resultobj = PyList_New(0);
	PyList_Append(_resultobj,o2);
	Py_XDECREF(o2);
      }
      PyList_Append(_resultobj,o);
      Py_XDECREF(o);
    }
}
    return _resultobj;
}

static PyObject *_wrap_SetViewportOrgEx(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    int  _arg1;
    int  _arg2;
    POINT * _arg3;
    POINT  point_output;
    PyObject * _obj0 = 0;

    self = self;
{
  _arg3 = &point_output;
}
    if(!PyArg_ParseTuple(args,"Oii:SetViewportOrgEx",&_obj0,&_arg1,&_arg2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )SetViewportOrgEx(_arg0,_arg1,_arg2,_arg3);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("SetViewportOrgEx");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
{
    PyObject *o;
    o = Py_BuildValue("ll", _arg3->x, _arg3->y);
    if (!_resultobj) {
      _resultobj = o;
    } else if (_resultobj == Py_None) {
      Py_DECREF(Py_None);
      _resultobj = o;
    } else {
      if (!PyList_Check(_resultobj)) {
	PyObject *o2 = _resultobj;
	_resultobj = PyList_New(0);
	PyList_Append(_resultobj,o2);
	Py_XDECREF(o2);
      }
      PyList_Append(_resultobj,o);
      Py_XDECREF(o);
    }
}
    return _resultobj;
}

static PyObject *_wrap_GetOpenFileName(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOL  _result;
    OPENFILENAME * _arg0;
    int  size;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:GetOpenFileName",&_obj0)) 
        return NULL;
{
	size = sizeof(OPENFILENAME);
	if (!PyString_Check(_obj0)) {
		PyErr_Format(PyExc_TypeError, "Argument must be a %d-byte string (got type %s)",
		             size, _obj0->ob_type->tp_name);
		return NULL;
	}
	if (size != PyString_GET_SIZE(_obj0)) {
		PyErr_Format(PyExc_TypeError, "Argument must be a %d-byte string (got string of %d bytes)",
		             size, PyString_GET_SIZE(_obj0));
		return NULL;
	}
	_arg0 = ( OPENFILENAME *)PyString_AS_STRING(_obj0);
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOL )GetOpenFileName(_arg0);

      Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_InsertMenuItem(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HMENU  _arg0;
    UINT  _arg1;
    BOOL  _arg2;
    MENUITEMINFO * _arg3;
    PyObject * _obj0 = 0;
    Py_ssize_t  target_size;
    PyObject * _obj3 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OiiO:InsertMenuItem",&_obj0,&_arg1,&_arg2,&_obj3)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (0 != PyObject_AsReadBuffer(_obj3, (const void **)&_arg3, &target_size))
		return NULL;
	if (sizeof MENUITEMINFO != target_size)
		return PyErr_Format(PyExc_TypeError, "Argument must be a %d-byte string/buffer (got %d bytes)", sizeof MENUITEMINFO, target_size);
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )InsertMenuItem(_arg0,_arg1,_arg2,_arg3);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("InsertMenuItem");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_SetMenuItemInfo(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HMENU  _arg0;
    UINT  _arg1;
    BOOL  _arg2;
    MENUITEMINFO * _arg3;
    PyObject * _obj0 = 0;
    Py_ssize_t  target_size;
    PyObject * _obj3 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OiiO:SetMenuItemInfo",&_obj0,&_arg1,&_arg2,&_obj3)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (0 != PyObject_AsReadBuffer(_obj3, (const void **)&_arg3, &target_size))
		return NULL;
	if (sizeof MENUITEMINFO != target_size)
		return PyErr_Format(PyExc_TypeError, "Argument must be a %d-byte string/buffer (got %d bytes)", sizeof MENUITEMINFO, target_size);
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )SetMenuItemInfo(_arg0,_arg1,_arg2,_arg3);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("SetMenuItemInfo");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_GetMenuItemInfo(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HMENU  _arg0;
    UINT  _arg1;
    BOOL  _arg2;
    MENUITEMINFO * _arg3;
    PyObject * _obj0 = 0;
    Py_ssize_t  target_size;
    PyObject * _obj3 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OiiO:GetMenuItemInfo",&_obj0,&_arg1,&_arg2,&_obj3)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (0 != PyObject_AsWriteBuffer(_obj3, (void **)&_arg3, &target_size))
		return NULL;
	if (sizeof MENUITEMINFO != target_size)
		return PyErr_Format(PyExc_TypeError, "Argument must be a %d-byte buffer (got %d bytes)", sizeof MENUITEMINFO, target_size);
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )GetMenuItemInfo(_arg0,_arg1,_arg2,_arg3);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("GetMenuItemInfo");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_GetMenuItemCount(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    HMENU  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:GetMenuItemCount",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
    Py_BEGIN_ALLOW_THREADS
        _result = (int )GetMenuItemCount(_arg0);

    Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_GetMenuItemRect(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    HWND  _arg0;
    HMENU  _arg1;
    UINT  _arg2;
    RECT * _arg3;
    RECT  rect_output;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
{
  _arg3 = &rect_output;
}
    if(!PyArg_ParseTuple(args,"OOi:GetMenuItemRect",&_obj0,&_obj1,&_arg2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj1, (HANDLE *)&_arg1))
		return NULL;
}
{
    Py_BEGIN_ALLOW_THREADS
        _result = (int )GetMenuItemRect(_arg0,_arg1,_arg2,_arg3);

    Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
{
    PyObject *o;
    o = Py_BuildValue("llll", _arg3->left, _arg3->top, _arg3->right, _arg3->bottom);
    if (!_resultobj) {
      _resultobj = o;
    } else if (_resultobj == Py_None) {
      Py_DECREF(Py_None);
      _resultobj = o;
    } else {
      if (!PyList_Check(_resultobj)) {
	PyObject *o2 = _resultobj;
	_resultobj = PyList_New(0);
	PyList_Append(_resultobj,o2);
	Py_XDECREF(o2);
      }
      PyList_Append(_resultobj,o);
      Py_XDECREF(o);
    }
}
    return _resultobj;
}

static PyObject *_wrap_GetMenuState(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    HMENU  _arg0;
    UINT  _arg1;
    UINT  _arg2;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oii:GetMenuState",&_obj0,&_arg1,&_arg2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
    Py_BEGIN_ALLOW_THREADS
        _result = (int )GetMenuState(_arg0,_arg1,_arg2);

    Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_SetMenuDefaultItem(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HMENU  _arg0;
    UINT  _arg1;
    UINT  _arg2;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oii:SetMenuDefaultItem",&_obj0,&_arg1,&_arg2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )SetMenuDefaultItem(_arg0,_arg1,_arg2);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("SetMenuDefaultItem");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_GetMenuDefaultItem(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    HMENU  _arg0;
    UINT  _arg1;
    UINT  _arg2;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oii:GetMenuDefaultItem",&_obj0,&_arg1,&_arg2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
    Py_BEGIN_ALLOW_THREADS
        _result = (int )GetMenuDefaultItem(_arg0,_arg1,_arg2);

    Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_AppendMenu(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HMENU  _arg0;
    UINT  _arg1;
    UINT  _arg2;
    TCHAR * _arg3;
    PyObject * _obj0 = 0;
    PyObject * _obj3 = 0;

    self = self;
{
	_arg3 = NULL;
}
    if(!PyArg_ParseTuple(args,"OiiO:AppendMenu",&_obj0,&_arg1,&_arg2,&_obj3)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsTCHAR(_obj3, &_arg3, FALSE))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )AppendMenu(_arg0,_arg1,_arg2,_arg3);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           {
	PyWinObject_FreeTCHAR(_arg3);
}

           return PyWin_SetAPIError("AppendMenu");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
{
	PyWinObject_FreeTCHAR(_arg3);
}
    return _resultobj;
}

static PyObject *_wrap_InsertMenu(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HMENU  _arg0;
    UINT  _arg1;
    UINT  _arg2;
    UINT  _arg3;
    TCHAR * _arg4;
    PyObject * _obj0 = 0;
    PyObject * _obj4 = 0;

    self = self;
{
	_arg4 = NULL;
}
    if(!PyArg_ParseTuple(args,"OiiiO:InsertMenu",&_obj0,&_arg1,&_arg2,&_arg3,&_obj4)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsTCHAR(_obj4, &_arg4, TRUE))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )InsertMenu(_arg0,_arg1,_arg2,_arg3,_arg4);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           {
	PyWinObject_FreeTCHAR(_arg4);
}

           return PyWin_SetAPIError("InsertMenu");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
{
	PyWinObject_FreeTCHAR(_arg4);
}
    return _resultobj;
}

static PyObject *_wrap_EnableMenuItem(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOL  _result;
    HMENU  _arg0;
    UINT  _arg1;
    UINT  _arg2;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oii:EnableMenuItem",&_obj0,&_arg1,&_arg2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOL )EnableMenuItem(_arg0,_arg1,_arg2);

      Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_CheckMenuItem(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    HMENU  _arg0;
    UINT  _arg1;
    UINT  _arg2;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oii:CheckMenuItem",&_obj0,&_arg1,&_arg2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
    Py_BEGIN_ALLOW_THREADS
        _result = (int )CheckMenuItem(_arg0,_arg1,_arg2);

    Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_GetSubMenu(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HMENU  _result;
    HMENU  _arg0;
    int  _arg1;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oi:GetSubMenu",&_obj0,&_arg1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HMENU )GetSubMenu(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("GetSubMenu", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_ModifyMenu(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HMENU  _arg0;
    UINT  _arg1;
    UINT  _arg2;
    UINT  _arg3;
    TCHAR * _arg4;
    PyObject * _obj0 = 0;
    PyObject * _obj4 = 0;

    self = self;
{
	_arg4 = NULL;
}
    if(!PyArg_ParseTuple(args,"OiiiO:ModifyMenu",&_obj0,&_arg1,&_arg2,&_arg3,&_obj4)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsTCHAR(_obj4, &_arg4, FALSE))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )ModifyMenu(_arg0,_arg1,_arg2,_arg3,_arg4);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           {
	PyWinObject_FreeTCHAR(_arg4);
}

           return PyWin_SetAPIError("ModifyMenu");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
{
	PyWinObject_FreeTCHAR(_arg4);
}
    return _resultobj;
}

static PyObject *_wrap_GetMenuItemID(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    UINT  _result;
    HMENU  _arg0;
    int  _arg1;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oi:GetMenuItemID",&_obj0,&_arg1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
    Py_BEGIN_ALLOW_THREADS
        _result = (UINT )GetMenuItemID(_arg0,_arg1);

    Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_SetMenuItemBitmaps(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HMENU  _arg0;
    UINT  _arg1;
    UINT  _arg2;
    HBITMAP  _arg3;
    HBITMAP  _arg4;
    PyObject * _obj0 = 0;
    PyObject * _obj3 = 0;
    PyObject * _obj4 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OiiOO:SetMenuItemBitmaps",&_obj0,&_arg1,&_arg2,&_obj3,&_obj4)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj3, (HANDLE *)&_arg3))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj4, (HANDLE *)&_arg4))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )SetMenuItemBitmaps(_arg0,_arg1,_arg2,_arg3,_arg4);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("SetMenuItemBitmaps");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_CheckMenuRadioItem(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HMENU  _arg0;
    UINT  _arg1;
    UINT  _arg2;
    UINT  _arg3;
    UINT  _arg4;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oiiii:CheckMenuRadioItem",&_obj0,&_arg1,&_arg2,&_arg3,&_arg4)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )CheckMenuRadioItem(_arg0,_arg1,_arg2,_arg3,_arg4);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("CheckMenuRadioItem");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_DrawFocusRect(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    RECT * _arg1;
    PyObject * _obj0 = 0;
    RECT  rect_input;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OO:DrawFocusRect",&_obj0,&_obj1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (PyTuple_Check(_obj1)) {
		if (PyArg_ParseTuple(_obj1, "llll", &rect_input.left, &rect_input.top, &rect_input.right, &rect_input.bottom) == 0) {
			return PyErr_Format(PyExc_TypeError, "%s: This param must be a tuple of four integers", "DrawFocusRect");
		}
		_arg1 = &rect_input;
	} else {
		return PyErr_Format(PyExc_TypeError, "%s: This param must be a tuple of four integers", "DrawFocusRect");
	}
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )DrawFocusRect(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("DrawFocusRect");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_DrawText(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    HDC  _arg0;
    TCHAR * _arg1;
    int  _arg2;
    RECT * _arg3;
    UINT  _arg4;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;
    RECT  rect_input;
    PyObject * _obj3 = 0;

    self = self;
{
	_arg1 = NULL;
}
    if(!PyArg_ParseTuple(args,"OOiOi:DrawText",&_obj0,&_obj1,&_arg2,&_obj3,&_arg4)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsTCHAR(_obj1, &_arg1, FALSE))
		return NULL;
}
{
	if (PyTuple_Check(_obj3)) {
		if (PyArg_ParseTuple(_obj3, "llll", &rect_input.left, &rect_input.top, &rect_input.right, &rect_input.bottom) == 0) {
			return PyErr_Format(PyExc_TypeError, "%s: This param must be a tuple of four integers", "DrawText");
		}
		_arg3 = &rect_input;
	} else {
		return PyErr_Format(PyExc_TypeError, "%s: This param must be a tuple of four integers", "DrawText");
	}
}
{
    Py_BEGIN_ALLOW_THREADS
        _result = (int )DrawText(_arg0,_arg1,_arg2,_arg3,_arg4);

    Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
{
    PyObject *o;
    o = Py_BuildValue("llll", _arg3->left, _arg3->top, _arg3->right, _arg3->bottom);
    if (!_resultobj) {
      _resultobj = o;
    } else if (_resultobj == Py_None) {
      Py_DECREF(Py_None);
      _resultobj = o;
    } else {
      if (!PyList_Check(_resultobj)) {
	PyObject *o2 = _resultobj;
	_resultobj = PyList_New(0);
	PyList_Append(_resultobj,o2);
	Py_XDECREF(o2);
      }
      PyList_Append(_resultobj,o);
      Py_XDECREF(o);
    }
}
{
	PyWinObject_FreeTCHAR(_arg1);
}
    return _resultobj;
}

static PyObject *_wrap_LineTo(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    int  _arg1;
    int  _arg2;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oii:LineTo",&_obj0,&_arg1,&_arg2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )LineTo(_arg0,_arg1,_arg2);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("LineTo");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_Ellipse(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    int  _arg1;
    int  _arg2;
    int  _arg3;
    int  _arg4;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oiiii:Ellipse",&_obj0,&_arg1,&_arg2,&_arg3,&_arg4)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )Ellipse(_arg0,_arg1,_arg2,_arg3,_arg4);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("Ellipse");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_Pie(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    int  _arg1;
    int  _arg2;
    int  _arg3;
    int  _arg4;
    int  _arg5;
    int  _arg6;
    int  _arg7;
    int  _arg8;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oiiiiiiii:Pie",&_obj0,&_arg1,&_arg2,&_arg3,&_arg4,&_arg5,&_arg6,&_arg7,&_arg8)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )Pie(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("Pie");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_Arc(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    int  _arg1;
    int  _arg2;
    int  _arg3;
    int  _arg4;
    int  _arg5;
    int  _arg6;
    int  _arg7;
    int  _arg8;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oiiiiiiii:Arc",&_obj0,&_arg1,&_arg2,&_arg3,&_arg4,&_arg5,&_arg6,&_arg7,&_arg8)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )Arc(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("Arc");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_ArcTo(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    int  _arg1;
    int  _arg2;
    int  _arg3;
    int  _arg4;
    int  _arg5;
    int  _arg6;
    int  _arg7;
    int  _arg8;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oiiiiiiii:ArcTo",&_obj0,&_arg1,&_arg2,&_arg3,&_arg4,&_arg5,&_arg6,&_arg7,&_arg8)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )ArcTo(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("ArcTo");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_Chord(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    int  _arg1;
    int  _arg2;
    int  _arg3;
    int  _arg4;
    int  _arg5;
    int  _arg6;
    int  _arg7;
    int  _arg8;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oiiiiiiii:Chord",&_obj0,&_arg1,&_arg2,&_arg3,&_arg4,&_arg5,&_arg6,&_arg7,&_arg8)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )Chord(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("Chord");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_ExtFloodFill(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    int  _arg1;
    int  _arg2;
    COLORREF  _arg3;
    UINT  _arg4;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oiili:ExtFloodFill",&_obj0,&_arg1,&_arg2,&_arg3,&_arg4)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )ExtFloodFill(_arg0,_arg1,_arg2,_arg3,_arg4);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("ExtFloodFill");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_SetPixelV(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    int  _arg1;
    int  _arg2;
    COLORREF  _arg3;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oiil:SetPixelV",&_obj0,&_arg1,&_arg2,&_arg3)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )SetPixelV(_arg0,_arg1,_arg2,_arg3);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("SetPixelV");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_MoveToEx(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    int  _arg1;
    int  _arg2;
    POINT * _arg3;
    POINT  point_output;
    PyObject * _obj0 = 0;

    self = self;
{
  _arg3 = &point_output;
}
    if(!PyArg_ParseTuple(args,"Oii:MoveToEx",&_obj0,&_arg1,&_arg2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )MoveToEx(_arg0,_arg1,_arg2,_arg3);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("MoveToEx");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
{
    PyObject *o;
    o = Py_BuildValue("ll", _arg3->x, _arg3->y);
    if (!_resultobj) {
      _resultobj = o;
    } else if (_resultobj == Py_None) {
      Py_DECREF(Py_None);
      _resultobj = o;
    } else {
      if (!PyList_Check(_resultobj)) {
	PyObject *o2 = _resultobj;
	_resultobj = PyList_New(0);
	PyList_Append(_resultobj,o2);
	Py_XDECREF(o2);
      }
      PyList_Append(_resultobj,o);
      Py_XDECREF(o);
    }
}
    return _resultobj;
}

static PyObject *_wrap_GetCurrentPositionEx(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    POINT * _arg1;
    POINT  point_output;
    PyObject * _obj0 = 0;

    self = self;
{
  _arg1 = &point_output;
}
    if(!PyArg_ParseTuple(args,"O:GetCurrentPositionEx",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )GetCurrentPositionEx(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("GetCurrentPositionEx");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
{
    PyObject *o;
    o = Py_BuildValue("ll", _arg1->x, _arg1->y);
    if (!_resultobj) {
      _resultobj = o;
    } else if (_resultobj == Py_None) {
      Py_DECREF(Py_None);
      _resultobj = o;
    } else {
      if (!PyList_Check(_resultobj)) {
	PyObject *o2 = _resultobj;
	_resultobj = PyList_New(0);
	PyList_Append(_resultobj,o2);
	Py_XDECREF(o2);
      }
      PyList_Append(_resultobj,o);
      Py_XDECREF(o);
    }
}
    return _resultobj;
}

static PyObject *_wrap_GetArcDirection(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    HDC  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:GetArcDirection",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
    Py_BEGIN_ALLOW_THREADS
        _result = (int )GetArcDirection(_arg0);

    Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_SetArcDirection(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    HDC  _arg0;
    int  _arg1;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oi:SetArcDirection",&_obj0,&_arg1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
    Py_BEGIN_ALLOW_THREADS
        _result = (int )SetArcDirection(_arg0,_arg1);

    Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_GetTextColor(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    COLORREF  _result;
    HDC  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:GetTextColor",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
    _result = (COLORREF )GetTextColor(_arg0);
    _resultobj = Py_BuildValue("l",_result);
    return _resultobj;
}

static PyObject *_wrap_SetTextColor(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    HDC  _arg0;
    COLORREF  _arg1;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Ol:SetTextColor",&_obj0,&_arg1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
    Py_BEGIN_ALLOW_THREADS
        _result = (int )SetTextColor(_arg0,_arg1);

    Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_GetBkMode(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    HDC  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:GetBkMode",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
    Py_BEGIN_ALLOW_THREADS
        _result = (int )GetBkMode(_arg0);

    Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_SetBkMode(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    HDC  _arg0;
    int  _arg1;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oi:SetBkMode",&_obj0,&_arg1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
    Py_BEGIN_ALLOW_THREADS
        _result = (int )SetBkMode(_arg0,_arg1);

    Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_GetBkColor(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    HDC  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:GetBkColor",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
    Py_BEGIN_ALLOW_THREADS
        _result = (int )GetBkColor(_arg0);

    Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_SetBkColor(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    HDC  _arg0;
    COLORREF  _arg1;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Ol:SetBkColor",&_obj0,&_arg1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
    Py_BEGIN_ALLOW_THREADS
        _result = (int )SetBkColor(_arg0,_arg1);

    Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_DrawEdge(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    RECT * _arg1;
    UINT  _arg2;
    UINT  _arg3;
    PyObject * _obj0 = 0;
    RECT  rect_input;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OOii:DrawEdge",&_obj0,&_obj1,&_arg2,&_arg3)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (PyTuple_Check(_obj1)) {
		if (PyArg_ParseTuple(_obj1, "llll", &rect_input.left, &rect_input.top, &rect_input.right, &rect_input.bottom) == 0) {
			return PyErr_Format(PyExc_TypeError, "%s: This param must be a tuple of four integers", "DrawEdge");
		}
		_arg1 = &rect_input;
	} else {
		return PyErr_Format(PyExc_TypeError, "%s: This param must be a tuple of four integers", "DrawEdge");
	}
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )DrawEdge(_arg0,_arg1,_arg2,_arg3);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("DrawEdge");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
{
    PyObject *o;
    o = Py_BuildValue("llll", _arg1->left, _arg1->top, _arg1->right, _arg1->bottom);
    if (!_resultobj) {
      _resultobj = o;
    } else if (_resultobj == Py_None) {
      Py_DECREF(Py_None);
      _resultobj = o;
    } else {
      if (!PyList_Check(_resultobj)) {
	PyObject *o2 = _resultobj;
	_resultobj = PyList_New(0);
	PyList_Append(_resultobj,o2);
	Py_XDECREF(o2);
      }
      PyList_Append(_resultobj,o);
      Py_XDECREF(o);
    }
}
    return _resultobj;
}

static PyObject *_wrap_FillRect(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    HDC  _arg0;
    RECT * _arg1;
    HBRUSH  _arg2;
    PyObject * _obj0 = 0;
    RECT  rect_input;
    PyObject * _obj1 = 0;
    PyObject * _obj2 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OOO:FillRect",&_obj0,&_obj1,&_obj2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (PyTuple_Check(_obj1)) {
		if (PyArg_ParseTuple(_obj1, "llll", &rect_input.left, &rect_input.top, &rect_input.right, &rect_input.bottom) == 0) {
			return PyErr_Format(PyExc_TypeError, "%s: This param must be a tuple of four integers", "FillRect");
		}
		_arg1 = &rect_input;
	} else {
		return PyErr_Format(PyExc_TypeError, "%s: This param must be a tuple of four integers", "FillRect");
	}
}
{
	if (!PyWinObject_AsHANDLE(_obj2, (HANDLE *)&_arg2))
		return NULL;
}
{
    Py_BEGIN_ALLOW_THREADS
        _result = (int )FillRect(_arg0,_arg1,_arg2);

    Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_FillRgn(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    HRGN  _arg1;
    HBRUSH  _arg2;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;
    PyObject * _obj2 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OOO:FillRgn",&_obj0,&_obj1,&_obj2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj1, (HANDLE *)&_arg1))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj2, (HANDLE *)&_arg2))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )FillRgn(_arg0,_arg1,_arg2);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("FillRgn");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_PaintRgn(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    HRGN  _arg1;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OO:PaintRgn",&_obj0,&_obj1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj1, (HANDLE *)&_arg1))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )PaintRgn(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("PaintRgn");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_FrameRgn(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    HRGN  _arg1;
    HBRUSH  _arg2;
    int  _arg3;
    int  _arg4;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;
    PyObject * _obj2 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OOOii:FrameRgn",&_obj0,&_obj1,&_obj2,&_arg3,&_arg4)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj1, (HANDLE *)&_arg1))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj2, (HANDLE *)&_arg2))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )FrameRgn(_arg0,_arg1,_arg2,_arg3,_arg4);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("FrameRgn");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_InvertRgn(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    HRGN  _arg1;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OO:InvertRgn",&_obj0,&_obj1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj1, (HANDLE *)&_arg1))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )InvertRgn(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("InvertRgn");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_EqualRgn(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOL  _result;
    HRGN  _arg0;
    HRGN  _arg1;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OO:EqualRgn",&_obj0,&_obj1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj1, (HANDLE *)&_arg1))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOL )EqualRgn(_arg0,_arg1);

      Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_PtInRegion(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOL  _result;
    HRGN  _arg0;
    int  _arg1;
    int  _arg2;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oii:PtInRegion",&_obj0,&_arg1,&_arg2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOL )PtInRegion(_arg0,_arg1,_arg2);

      Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_PtInRect(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOL  _result;
    RECT * _arg0;
    POINT * _arg1;
    RECT  rect_input;
    PyObject * _obj0 = 0;
    POINT  point_input;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OO:PtInRect",&_obj0,&_obj1)) 
        return NULL;
{
	if (PyTuple_Check(_obj0)) {
		if (PyArg_ParseTuple(_obj0, "llll", &rect_input.left, &rect_input.top, &rect_input.right, &rect_input.bottom) == 0) {
			return PyErr_Format(PyExc_TypeError, "%s: This param must be a tuple of four integers", "PtInRect");
		}
		_arg0 = &rect_input;
	} else {
		return PyErr_Format(PyExc_TypeError, "%s: This param must be a tuple of four integers", "PtInRect");
	}
}
{
	if (!PyWinObject_AsPOINT(_obj1, &point_input))
		return NULL;
	_arg1 = &point_input;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOL )PtInRect(_arg0,*_arg1);

      Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_RectInRegion(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOL  _result;
    HRGN  _arg0;
    RECT * _arg1;
    PyObject * _obj0 = 0;
    RECT  rect_input;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OO:RectInRegion",&_obj0,&_obj1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (PyTuple_Check(_obj1)) {
		if (PyArg_ParseTuple(_obj1, "llll", &rect_input.left, &rect_input.top, &rect_input.right, &rect_input.bottom) == 0) {
			return PyErr_Format(PyExc_TypeError, "%s: This param must be a tuple of four integers", "RectInRegion");
		}
		_arg1 = &rect_input;
	} else {
		return PyErr_Format(PyExc_TypeError, "%s: This param must be a tuple of four integers", "RectInRegion");
	}
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOL )RectInRegion(_arg0,_arg1);

      Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_SetRectRgn(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HRGN  _arg0;
    int  _arg1;
    int  _arg2;
    int  _arg3;
    int  _arg4;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oiiii:SetRectRgn",&_obj0,&_arg1,&_arg2,&_arg3,&_arg4)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )SetRectRgn(_arg0,_arg1,_arg2,_arg3,_arg4);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("SetRectRgn");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_CombineRgn(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int_regiontype  _result;
    HRGN  _arg0;
    HRGN  _arg1;
    HRGN  _arg2;
    int  _arg3;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;
    PyObject * _obj2 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OOOi:CombineRgn",&_obj0,&_obj1,&_obj2,&_arg3)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj1, (HANDLE *)&_arg1))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj2, (HANDLE *)&_arg2))
		return NULL;
}
{
	Py_BEGIN_ALLOW_THREADS
	    _result = (int_regiontype )CombineRgn(_arg0,_arg1,_arg2,_arg3);

	Py_END_ALLOW_THREADS
	if (_result==ERROR){
		
		return PyWin_SetAPIError("CombineRgn");
		}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_DrawAnimatedRects(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HWND  _arg0;
    int  _arg1;
    RECT * _arg2;
    RECT * _arg3;
    PyObject * _obj0 = 0;
    RECT  rect_input;
    PyObject * _obj2 = 0;
    RECT  rect_input0;
    PyObject * _obj3 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OiOO:DrawAnimatedRects",&_obj0,&_arg1,&_obj2,&_obj3)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (PyTuple_Check(_obj2)) {
		if (PyArg_ParseTuple(_obj2, "llll", &rect_input.left, &rect_input.top, &rect_input.right, &rect_input.bottom) == 0) {
			return PyErr_Format(PyExc_TypeError, "%s: This param must be a tuple of four integers", "DrawAnimatedRects");
		}
		_arg2 = &rect_input;
	} else {
		return PyErr_Format(PyExc_TypeError, "%s: This param must be a tuple of four integers", "DrawAnimatedRects");
	}
}
{
	if (PyTuple_Check(_obj3)) {
		if (PyArg_ParseTuple(_obj3, "llll", &rect_input0.left, &rect_input0.top, &rect_input0.right, &rect_input0.bottom) == 0) {
			return PyErr_Format(PyExc_TypeError, "%s: This param must be a tuple of four integers", "DrawAnimatedRects");
		}
		_arg3 = &rect_input0;
	} else {
		return PyErr_Format(PyExc_TypeError, "%s: This param must be a tuple of four integers", "DrawAnimatedRects");
	}
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )DrawAnimatedRects(_arg0,_arg1,_arg2,_arg3);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("DrawAnimatedRects");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_CreateSolidBrush(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HBRUSH  _result;
    COLORREF  _arg0;

    self = self;
    if(!PyArg_ParseTuple(args,"l:CreateSolidBrush",&_arg0)) 
        return NULL;
{
	Py_BEGIN_ALLOW_THREADS
	    _result = (HBRUSH )CreateSolidBrush(_arg0);

	Py_END_ALLOW_THREADS
	if (_result==NULL){
		
		return PyWin_SetAPIError("CreateSolidBrush");
		}
}{
	_resultobj = PyWinObject_FromGdiHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_CreatePatternBrush(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HBRUSH  _result;
    HBITMAP  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:CreatePatternBrush",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	Py_BEGIN_ALLOW_THREADS
	    _result = (HBRUSH )CreatePatternBrush(_arg0);

	Py_END_ALLOW_THREADS
	if (_result==NULL){
		
		return PyWin_SetAPIError("CreatePatternBrush");
		}
}{
	_resultobj = PyWinObject_FromGdiHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_CreateHatchBrush(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HBRUSH  _result;
    int  _arg0;
    COLORREF  _arg1;

    self = self;
    if(!PyArg_ParseTuple(args,"il:CreateHatchBrush",&_arg0,&_arg1)) 
        return NULL;
{
	Py_BEGIN_ALLOW_THREADS
	    _result = (HBRUSH )CreateHatchBrush(_arg0,_arg1);

	Py_END_ALLOW_THREADS
	if (_result==NULL){
		
		return PyWin_SetAPIError("CreateHatchBrush");
		}
}{
	_resultobj = PyWinObject_FromGdiHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_CreatePen(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HPEN  _result;
    int  _arg0;
    int  _arg1;
    COLORREF  _arg2;

    self = self;
    if(!PyArg_ParseTuple(args,"iil:CreatePen",&_arg0,&_arg1,&_arg2)) 
        return NULL;
{
	Py_BEGIN_ALLOW_THREADS
	    _result = (HPEN )CreatePen(_arg0,_arg1,_arg2);

	Py_END_ALLOW_THREADS
	if (_result==NULL){
		
		return PyWin_SetAPIError("CreatePen");
		}
}{
	_resultobj = PyWinObject_FromGdiHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_GetSysColor(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    DWORD  _result;
    int  _arg0;

    self = self;
    if(!PyArg_ParseTuple(args,"i:GetSysColor",&_arg0)) 
        return NULL;
    _result = (DWORD )GetSysColor(_arg0);
    _resultobj = Py_BuildValue("l",_result);
    return _resultobj;
}

static PyObject *_wrap_GetSysColorBrush(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HBRUSH  _result;
    int  _arg0;

    self = self;
    if(!PyArg_ParseTuple(args,"i:GetSysColorBrush",&_arg0)) 
        return NULL;
{
	Py_BEGIN_ALLOW_THREADS
	    _result = (HBRUSH )GetSysColorBrush(_arg0);

	Py_END_ALLOW_THREADS
	if (_result==NULL){
		
		return PyWin_SetAPIError("GetSysColorBrush");
		}
}{
	_resultobj = PyWinObject_FromGdiHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_InvalidateRect(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HWND  _arg0;
    RECT * _arg1;
    BOOL  _arg2;
    PyObject * _obj0 = 0;
    RECT  rect_input_nullok;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OOi:InvalidateRect",&_obj0,&_obj1,&_arg2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (PyTuple_Check(_obj1)) {
		if (PyArg_ParseTuple(_obj1, "llll", &rect_input_nullok.left, &rect_input_nullok.top, &rect_input_nullok.right, &rect_input_nullok.bottom) == 0) {
			return PyErr_Format(PyExc_TypeError, "%s: This param must be a tuple of four integers or None", "InvalidateRect");
		}
		_arg1 = &rect_input_nullok;
	} else {
		if (_obj1 == Py_None) {
            _arg1 = NULL;
        } else {
            PyErr_SetString(PyExc_TypeError, "This param must be a tuple of four integers or None");
            return NULL;
		}
	}
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )InvalidateRect(_arg0,_arg1,_arg2);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("InvalidateRect");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_FrameRect(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    RECT * _arg1;
    HBRUSH  _arg2;
    PyObject * _obj0 = 0;
    RECT  rect_input;
    PyObject * _obj1 = 0;
    PyObject * _obj2 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OOO:FrameRect",&_obj0,&_obj1,&_obj2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (PyTuple_Check(_obj1)) {
		if (PyArg_ParseTuple(_obj1, "llll", &rect_input.left, &rect_input.top, &rect_input.right, &rect_input.bottom) == 0) {
			return PyErr_Format(PyExc_TypeError, "%s: This param must be a tuple of four integers", "FrameRect");
		}
		_arg1 = &rect_input;
	} else {
		return PyErr_Format(PyExc_TypeError, "%s: This param must be a tuple of four integers", "FrameRect");
	}
}
{
	if (!PyWinObject_AsHANDLE(_obj2, (HANDLE *)&_arg2))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )FrameRect(_arg0,_arg1,_arg2);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("FrameRect");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_InvertRect(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    RECT * _arg1;
    PyObject * _obj0 = 0;
    RECT  rect_input;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OO:InvertRect",&_obj0,&_obj1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (PyTuple_Check(_obj1)) {
		if (PyArg_ParseTuple(_obj1, "llll", &rect_input.left, &rect_input.top, &rect_input.right, &rect_input.bottom) == 0) {
			return PyErr_Format(PyExc_TypeError, "%s: This param must be a tuple of four integers", "InvertRect");
		}
		_arg1 = &rect_input;
	} else {
		return PyErr_Format(PyExc_TypeError, "%s: This param must be a tuple of four integers", "InvertRect");
	}
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )InvertRect(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("InvertRect");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_WindowFromDC(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HWND  _result;
    HDC  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:WindowFromDC",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HWND )WindowFromDC(_arg0);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("WindowFromDC", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_GetUpdateRgn(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int_regiontype  _result;
    HWND  _arg0;
    HRGN  _arg1;
    BOOL  _arg2;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OOi:GetUpdateRgn",&_obj0,&_obj1,&_arg2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj1, (HANDLE *)&_arg1))
		return NULL;
}
{
	Py_BEGIN_ALLOW_THREADS
	    _result = (int_regiontype )GetUpdateRgn(_arg0,_arg1,_arg2);

	Py_END_ALLOW_THREADS
	if (_result==ERROR){
		
		return PyWin_SetAPIError("GetUpdateRgn");
		}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_GetWindowRgn(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int_regiontype  _result;
    HWND  _arg0;
    HRGN  _arg1;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OO:GetWindowRgn",&_obj0,&_obj1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj1, (HANDLE *)&_arg1))
		return NULL;
}
{
	Py_BEGIN_ALLOW_THREADS
	    _result = (int_regiontype )GetWindowRgn(_arg0,_arg1);

	Py_END_ALLOW_THREADS
	if (_result==ERROR){
		
		return PyWin_SetAPIError("GetWindowRgn");
		}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_SetWindowRgn(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HWND  _arg0;
    HRGN  _arg1;
    BOOL  _arg2;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OOi:SetWindowRgn",&_obj0,&_obj1,&_arg2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj1, (HANDLE *)&_arg1))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )SetWindowRgn(_arg0,_arg1,_arg2);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("SetWindowRgn");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_ValidateRgn(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HWND  _arg0;
    HRGN  _arg1;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OO:ValidateRgn",&_obj0,&_obj1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj1, (HANDLE *)&_arg1))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )ValidateRgn(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("ValidateRgn");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_InvalidateRgn(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HWND  _arg0;
    HRGN  _arg1;
    BOOL  _arg2;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OOi:InvalidateRgn",&_obj0,&_obj1,&_arg2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj1, (HANDLE *)&_arg1))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )InvalidateRgn(_arg0,_arg1,_arg2);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("InvalidateRgn");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_GetRgnBox(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int_regiontype  _result;
    HRGN  _arg0;
    RECT * _arg1;
    RECT  rect_output;
    PyObject * _obj0 = 0;

    self = self;
{
  _arg1 = &rect_output;
}
    if(!PyArg_ParseTuple(args,"O:GetRgnBox",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	Py_BEGIN_ALLOW_THREADS
	    _result = (int_regiontype )GetRgnBox(_arg0,_arg1);

	Py_END_ALLOW_THREADS
	if (_result==ERROR){
		
		return PyWin_SetAPIError("GetRgnBox");
		}
}    _resultobj = Py_BuildValue("i",_result);
{
    PyObject *o;
    o = Py_BuildValue("llll", _arg1->left, _arg1->top, _arg1->right, _arg1->bottom);
    if (!_resultobj) {
      _resultobj = o;
    } else if (_resultobj == Py_None) {
      Py_DECREF(Py_None);
      _resultobj = o;
    } else {
      if (!PyList_Check(_resultobj)) {
	PyObject *o2 = _resultobj;
	_resultobj = PyList_New(0);
	PyList_Append(_resultobj,o2);
	Py_XDECREF(o2);
      }
      PyList_Append(_resultobj,o);
      Py_XDECREF(o);
    }
}
    return _resultobj;
}

static PyObject *_wrap_OffsetRgn(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int_regiontype  _result;
    HRGN  _arg0;
    int  _arg1;
    int  _arg2;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oii:OffsetRgn",&_obj0,&_arg1,&_arg2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	Py_BEGIN_ALLOW_THREADS
	    _result = (int_regiontype )OffsetRgn(_arg0,_arg1,_arg2);

	Py_END_ALLOW_THREADS
	if (_result==ERROR){
		
		return PyWin_SetAPIError("OffsetRgn");
		}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_Rectangle(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    int  _arg1;
    int  _arg2;
    int  _arg3;
    int  _arg4;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oiiii:Rectangle",&_obj0,&_arg1,&_arg2,&_arg3,&_arg4)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )Rectangle(_arg0,_arg1,_arg2,_arg3,_arg4);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("Rectangle");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_RoundRect(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    int  _arg1;
    int  _arg2;
    int  _arg3;
    int  _arg4;
    int  _arg5;
    int  _arg6;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oiiiiii:RoundRect",&_obj0,&_arg1,&_arg2,&_arg3,&_arg4,&_arg5,&_arg6)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )RoundRect(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("RoundRect");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_BeginPaint(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HDC  _result;
    HWND  _arg0;
    PAINTSTRUCT * _arg1;
    PAINTSTRUCT  ps_output;
    PyObject * _obj0 = 0;

    self = self;
{
  _arg1 = &ps_output;
}
    if(!PyArg_ParseTuple(args,"O:BeginPaint",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HDC )BeginPaint(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("BeginPaint", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
{
    PyObject *o;
    o = Py_BuildValue("(Nl(iiii)llN)",
                PyWinLong_FromHANDLE(_arg1->hdc),
                _arg1->fErase,
                _arg1->rcPaint.left, _arg1->rcPaint.top, _arg1->rcPaint.right, _arg1->rcPaint.bottom,
                _arg1->fRestore,
                _arg1->fIncUpdate,
                PyString_FromStringAndSize((char *)_arg1->rgbReserved,sizeof(_arg1->rgbReserved)));
    if (!_resultobj) {
      _resultobj = o;
    } else if (_resultobj == Py_None) {
      Py_DECREF(Py_None);
      _resultobj = o;
    } else {
      if (!PyList_Check(_resultobj)) {
	PyObject *o2 = _resultobj;
	_resultobj = PyList_New(0);
	PyList_Append(_resultobj,o2);
	Py_XDECREF(o2);
      }
      PyList_Append(_resultobj,o);
      Py_XDECREF(o);
    }
}
    return _resultobj;
}

static PyObject *_wrap_EndPaint(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HWND  _arg0;
    PAINTSTRUCT * _arg1;
    PyObject * _obj0 = 0;
    PAINTSTRUCT  ps_input;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OO:EndPaint",&_obj0,&_obj1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
    char *szReserved;
    Py_ssize_t lenReserved;
	PyObject *obdc, *obReserved;
	if (PyTuple_Check(_obj1)) {
		if (!PyArg_ParseTuple(_obj1,
			"Ol(iiii)llO",
			&obdc,
			&ps_input.fErase,
			&ps_input.rcPaint.left, &ps_input.rcPaint.top, &ps_input.rcPaint.right, &ps_input.rcPaint.bottom,
			&ps_input.fRestore,
			&ps_input.fIncUpdate,
			&obReserved))
			return NULL;
		if (!PyWinObject_AsHANDLE(obdc, (HANDLE *)&ps_input.hdc))
			return NULL;
		if (PyString_AsStringAndSize(obReserved, &szReserved, &lenReserved)==-1)
			return NULL;
        if (lenReserved != sizeof(ps_input.rgbReserved))
            return PyErr_Format(PyExc_ValueError, "%s: last element must be string of %d bytes",
                                "EndPaint", sizeof(ps_input.rgbReserved));
        memcpy(&ps_input.rgbReserved, szReserved, sizeof(ps_input.rgbReserved));
		_arg1 = &ps_input;
    } else {
		return PyErr_Format(PyExc_TypeError, "%s: a PAINTSTRUCT must be a tuple", "EndPaint");
	}
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )EndPaint(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("EndPaint");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_BeginPath(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:BeginPath",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )BeginPath(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("BeginPath");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_EndPath(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:EndPath",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )EndPath(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("EndPath");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_AbortPath(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:AbortPath",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )AbortPath(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("AbortPath");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_CloseFigure(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:CloseFigure",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )CloseFigure(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("CloseFigure");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_FlattenPath(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:FlattenPath",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )FlattenPath(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("FlattenPath");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_FillPath(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:FillPath",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )FillPath(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("FillPath");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_WidenPath(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:WidenPath",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )WidenPath(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("WidenPath");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_StrokePath(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:StrokePath",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )StrokePath(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("StrokePath");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_StrokeAndFillPath(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:StrokeAndFillPath",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )StrokeAndFillPath(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("StrokeAndFillPath");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_GetMiterLimit(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    float * _arg1;
    float  temp;
    PyObject * _obj0 = 0;

    self = self;
{
  _arg1 = &temp;
}
    if(!PyArg_ParseTuple(args,"O:GetMiterLimit",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )GetMiterLimit(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("GetMiterLimit");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
{
    PyObject *o;
    o = PyFloat_FromDouble((double) (*_arg1));
    if (!_resultobj) {
      _resultobj = o;
    } else if (_resultobj == Py_None) {
      Py_DECREF(Py_None);
      _resultobj = o;
    } else {
      if (!PyList_Check(_resultobj)) {
	PyObject *o2 = _resultobj;
	_resultobj = PyList_New(0);
	PyList_Append(_resultobj,o2);
	Py_XDECREF(o2);
      }
      PyList_Append(_resultobj,o);
      Py_XDECREF(o);
    }
}
    return _resultobj;
}

static PyObject *_wrap_SetMiterLimit(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HDC  _arg0;
    float  _arg1;
    float * _arg2;
    float  temp;
    PyObject * _obj0 = 0;

    self = self;
{
  _arg2 = &temp;
}
    if(!PyArg_ParseTuple(args,"Of:SetMiterLimit",&_obj0,&_arg1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )SetMiterLimit(_arg0,_arg1,_arg2);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("SetMiterLimit");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
{
    PyObject *o;
    o = PyFloat_FromDouble((double) (*_arg2));
    if (!_resultobj) {
      _resultobj = o;
    } else if (_resultobj == Py_None) {
      Py_DECREF(Py_None);
      _resultobj = o;
    } else {
      if (!PyList_Check(_resultobj)) {
	PyObject *o2 = _resultobj;
	_resultobj = PyList_New(0);
	PyList_Append(_resultobj,o2);
	Py_XDECREF(o2);
      }
      PyList_Append(_resultobj,o);
      Py_XDECREF(o);
    }
}
    return _resultobj;
}

static PyObject *_wrap_PathToRegion(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HRGN  _result;
    HDC  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:PathToRegion",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	Py_BEGIN_ALLOW_THREADS
	    _result = (HRGN )PathToRegion(_arg0);

	Py_END_ALLOW_THREADS
	if (_result==NULL){
		
		return PyWin_SetAPIError("PathToRegion");
		}
}{
	_resultobj = PyWinObject_FromGdiHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_CreateRoundRectRgn(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HRGN  _result;
    int  _arg0;
    int  _arg1;
    int  _arg2;
    int  _arg3;
    int  _arg4;
    int  _arg5;

    self = self;
    if(!PyArg_ParseTuple(args,"iiiiii:CreateRoundRectRgn",&_arg0,&_arg1,&_arg2,&_arg3,&_arg4,&_arg5)) 
        return NULL;
{
	Py_BEGIN_ALLOW_THREADS
	    _result = (HRGN )CreateRoundRectRgn(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5);

	Py_END_ALLOW_THREADS
	if (_result==NULL){
		
		return PyWin_SetAPIError("CreateRoundRectRgn");
		}
}{
	_resultobj = PyWinObject_FromGdiHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_CreateRectRgnIndirect(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HRGN  _result;
    RECT * _arg0;
    RECT  rect_input;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:CreateRectRgnIndirect",&_obj0)) 
        return NULL;
{
	if (PyTuple_Check(_obj0)) {
		if (PyArg_ParseTuple(_obj0, "llll", &rect_input.left, &rect_input.top, &rect_input.right, &rect_input.bottom) == 0) {
			return PyErr_Format(PyExc_TypeError, "%s: This param must be a tuple of four integers", "CreateRectRgnIndirect");
		}
		_arg0 = &rect_input;
	} else {
		return PyErr_Format(PyExc_TypeError, "%s: This param must be a tuple of four integers", "CreateRectRgnIndirect");
	}
}
{
	Py_BEGIN_ALLOW_THREADS
	    _result = (HRGN )CreateRectRgnIndirect(_arg0);

	Py_END_ALLOW_THREADS
	if (_result==NULL){
		
		return PyWin_SetAPIError("CreateRectRgnIndirect");
		}
}{
	_resultobj = PyWinObject_FromGdiHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_CreateEllipticRgnIndirect(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HRGN  _result;
    RECT * _arg0;
    RECT  rect_input;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:CreateEllipticRgnIndirect",&_obj0)) 
        return NULL;
{
	if (PyTuple_Check(_obj0)) {
		if (PyArg_ParseTuple(_obj0, "llll", &rect_input.left, &rect_input.top, &rect_input.right, &rect_input.bottom) == 0) {
			return PyErr_Format(PyExc_TypeError, "%s: This param must be a tuple of four integers", "CreateEllipticRgnIndirect");
		}
		_arg0 = &rect_input;
	} else {
		return PyErr_Format(PyExc_TypeError, "%s: This param must be a tuple of four integers", "CreateEllipticRgnIndirect");
	}
}
{
	Py_BEGIN_ALLOW_THREADS
	    _result = (HRGN )CreateEllipticRgnIndirect(_arg0);

	Py_END_ALLOW_THREADS
	if (_result==NULL){
		
		return PyWin_SetAPIError("CreateEllipticRgnIndirect");
		}
}{
	_resultobj = PyWinObject_FromGdiHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_CreateWindowEx(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HWND  _result;
    DWORD  _arg0;
    STRING_OR_ATOM_CW  _arg1;
    TCHAR * _arg2;
    DWORD  _arg3;
    int  _arg4;
    int  _arg5;
    int  _arg6;
    int  _arg7;
    HWND  _arg8;
    HMENU  _arg9;
    HINSTANCE  _arg10;
    NULL_ONLY  _arg11;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;
    PyObject * _obj2 = 0;
    PyObject * _obj3 = 0;
    PyObject * _obj8 = 0;
    PyObject * _obj9 = 0;
    PyObject * _obj10 = 0;
    PyObject * _obj11 = 0;

    self = self;
{
	_arg1=NULL;
}
{
	_arg2 = NULL;
}
    if(!PyArg_ParseTuple(args,"OOOOiiiiOOOO:CreateWindowEx",&_obj0,&_obj1,&_obj2,&_obj3,&_arg4,&_arg5,&_arg6,&_arg7,&_obj8,&_obj9,&_obj10,&_obj11)) 
        return NULL;
{
	// PyLong_AsUnsignedLongMask isn't ideal - no overflow checking - but
	// this is what the 'k' format specifier in PyArg_ParseTuple uses, and
	// that is what much of pywin32 uses for DWORDS, so we use it here too
	_arg0 = PyLong_AsUnsignedLongMask(_obj0);
	if (_arg0==(DWORD)-1 && PyErr_Occurred())
		return NULL;
}
{
	if (!PyWinObject_AsResourceId(_obj1, &_arg1, TRUE))
		return NULL;
}
{
	if (!PyWinObject_AsTCHAR(_obj2, &_arg2, TRUE))
		return NULL;
}
{
	// PyLong_AsUnsignedLongMask isn't ideal - no overflow checking - but
	// this is what the 'k' format specifier in PyArg_ParseTuple uses, and
	// that is what much of pywin32 uses for DWORDS, so we use it here too
	_arg3 = PyLong_AsUnsignedLongMask(_obj3);
	if (_arg3==(DWORD)-1 && PyErr_Occurred())
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj8, (HANDLE *)&_arg8))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj9, (HANDLE *)&_arg9))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj10, (HANDLE *)&_arg10))
		return NULL;
}
{
	if (_obj11 != Py_None) {
		PyErr_SetString(PyExc_TypeError, "This param must be None");
		return NULL;
	}
	_arg11 = NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HWND )CreateWindowEx(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8,_arg9,_arg10,_arg11);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           {
	// Look up the WNDCLASS object by either atom->wndclass or name->atom->wndclass to set window proc
	PyObject *obwc=NULL;
	if (_result) {
		if (IS_INTRESOURCE(_arg1))
			obwc = PyDict_GetItem(g_AtomMap, _obj1);
		else{
			// Use the name to retrieve the atom, and use it to retrieve the PyWNDCLASS
			PyObject *obatom=PyDict_GetItem(g_AtomMap, _obj1);
			if (obatom!=NULL)
				obwc = PyDict_GetItem(g_AtomMap, obatom);
			}
		// A HUGE HACK - set the class extra bytes.
		if (obwc)
			SetClassLongPtr(_result, 0, (LONG_PTR)((PyWNDCLASS *)obwc)->m_obWndProc);
		}
	PyWinObject_FreeResourceId(_arg1);
}
{
	PyWinObject_FreeTCHAR(_arg2);
}

           return PyWin_SetAPIError("CreateWindowEx", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
{
	// Look up the WNDCLASS object by either atom->wndclass or name->atom->wndclass to set window proc
	PyObject *obwc=NULL;
	if (_result) {
		if (IS_INTRESOURCE(_arg1))
			obwc = PyDict_GetItem(g_AtomMap, _obj1);
		else{
			// Use the name to retrieve the atom, and use it to retrieve the PyWNDCLASS
			PyObject *obatom=PyDict_GetItem(g_AtomMap, _obj1);
			if (obatom!=NULL)
				obwc = PyDict_GetItem(g_AtomMap, obatom);
			}
		// A HUGE HACK - set the class extra bytes.
		if (obwc)
			SetClassLongPtr(_result, 0, (LONG_PTR)((PyWNDCLASS *)obwc)->m_obWndProc);
		}
	PyWinObject_FreeResourceId(_arg1);
}
{
	PyWinObject_FreeTCHAR(_arg2);
}
    return _resultobj;
}

static PyObject *_wrap_GetParent(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HWND  _result;
    HWND  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:GetParent",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HWND )GetParent(_arg0);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("GetParent", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_SetParent(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HWND  _result;
    HWND  _arg0;
    HWND  _arg1;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OO:SetParent",&_obj0,&_obj1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj1, (HANDLE *)&_arg1))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HWND )SetParent(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("SetParent", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_GetCursorPos(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    POINT * _arg0;
    POINT  point_output;

    self = self;
{
  _arg0 = &point_output;
}
    if(!PyArg_ParseTuple(args,":GetCursorPos")) 
        return NULL;
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )GetCursorPos(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("GetCursorPos");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
{
    PyObject *o;
    o = Py_BuildValue("ll", _arg0->x, _arg0->y);
    if (!_resultobj) {
      _resultobj = o;
    } else if (_resultobj == Py_None) {
      Py_DECREF(Py_None);
      _resultobj = o;
    } else {
      if (!PyList_Check(_resultobj)) {
	PyObject *o2 = _resultobj;
	_resultobj = PyList_New(0);
	PyList_Append(_resultobj,o2);
	Py_XDECREF(o2);
      }
      PyList_Append(_resultobj,o);
      Py_XDECREF(o);
    }
}
    return _resultobj;
}

static PyObject *_wrap_GetDesktopWindow(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HWND  _result;

    self = self;
    if(!PyArg_ParseTuple(args,":GetDesktopWindow")) 
        return NULL;
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HWND )GetDesktopWindow();

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("GetDesktopWindow", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_GetWindow(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HWND  _result;
    HWND  _arg0;
    UINT  _arg1;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oi:GetWindow",&_obj0,&_arg1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HWND )GetWindow(_arg0,_arg1);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("GetWindow", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_GetWindowDC(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HDC  _result;
    HWND  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:GetWindowDC",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HDC )GetWindowDC(_arg0);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("GetWindowDC", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_IsIconic(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOL  _result;
    HWND  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:IsIconic",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOL )IsIconic(_arg0);

      Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_IsWindow(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOL  _result;
    HWND  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:IsWindow",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOL )IsWindow(_arg0);

      Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_IsChild(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOL  _result;
    HWND  _arg0;
    HWND  _arg1;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OO:IsChild",&_obj0,&_obj1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj1, (HANDLE *)&_arg1))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOL )IsChild(_arg0,_arg1);

      Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_ReleaseCapture(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;

    self = self;
    if(!PyArg_ParseTuple(args,":ReleaseCapture")) 
        return NULL;
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )ReleaseCapture();

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("ReleaseCapture");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_GetCapture(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HWND  _result;

    self = self;
    if(!PyArg_ParseTuple(args,":GetCapture")) 
        return NULL;
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HWND )GetCapture();

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("GetCapture", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_SetCapture(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HWND  _result;
    HWND  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:SetCapture",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HWND )SetCapture(_arg0);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("SetCapture", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap__TrackMouseEvent(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    TRACKMOUSEEVENT * _arg0;
    TRACKMOUSEEVENT  e;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:_TrackMouseEvent",&_obj0)) 
        return NULL;
{
	PyObject *obhwnd;
	e.cbSize = sizeof e;
	if (PyTuple_Check(_obj0)) {
		if (PyArg_ParseTuple(_obj0, "lOl", &e.dwFlags, &obhwnd, &e.dwHoverTime) == 0) {
			return PyErr_Format(PyExc_TypeError, "%s: a TRACKMOUSEEVENT must be a tuple of 3 integers", "_TrackMouseEvent");
		}
		if (!PyWinObject_AsHANDLE(obhwnd, (HANDLE *)&e.hwndTrack))
			return NULL;
		_arg0 = &e;
    } else {
		return PyErr_Format(PyExc_TypeError, "%s: a TRACKMOUSEEVENT must be a tuple of 3 integers", "_TrackMouseEvent");
	}
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )_TrackMouseEvent(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("_TrackMouseEvent");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_ReleaseDC(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    HWND  _arg0;
    HDC  _arg1;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OO:ReleaseDC",&_obj0,&_obj1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj1, (HANDLE *)&_arg1))
		return NULL;
}
{
    Py_BEGIN_ALLOW_THREADS
        _result = (int )ReleaseDC(_arg0,_arg1);

    Py_END_ALLOW_THREADS
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_CreateCaret(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HWND  _arg0;
    HBITMAP  _arg1;
    int  _arg2;
    int  _arg3;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OOii:CreateCaret",&_obj0,&_obj1,&_arg2,&_arg3)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsHANDLE(_obj1, (HANDLE *)&_arg1))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )CreateCaret(_arg0,_arg1,_arg2,_arg3);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("CreateCaret");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_DestroyCaret(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;

    self = self;
    if(!PyArg_ParseTuple(args,":DestroyCaret")) 
        return NULL;
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )DestroyCaret();

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("DestroyCaret");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_ScrollWindowEx(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int_regiontype  _result;
    HWND  _arg0;
    int  _arg1;
    int  _arg2;
    RECT * _arg3;
    RECT * _arg4;
    HRGN  _arg5;
    RECT * _arg6;
    RECT  rect_output;
    UINT  _arg7;
    PyObject * _obj0 = 0;
    RECT  rect_input_nullok;
    PyObject * _obj3 = 0;
    RECT  rect_input_nullok0;
    PyObject * _obj4 = 0;
    PyObject * _obj5 = 0;

    self = self;
{
  _arg6 = &rect_output;
}
    if(!PyArg_ParseTuple(args,"OiiOOOi:ScrollWindowEx",&_obj0,&_arg1,&_arg2,&_obj3,&_obj4,&_obj5,&_arg7)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (PyTuple_Check(_obj3)) {
		if (PyArg_ParseTuple(_obj3, "llll", &rect_input_nullok.left, &rect_input_nullok.top, &rect_input_nullok.right, &rect_input_nullok.bottom) == 0) {
			return PyErr_Format(PyExc_TypeError, "%s: This param must be a tuple of four integers or None", "ScrollWindowEx");
		}
		_arg3 = &rect_input_nullok;
	} else {
		if (_obj3 == Py_None) {
            _arg3 = NULL;
        } else {
            PyErr_SetString(PyExc_TypeError, "This param must be a tuple of four integers or None");
            return NULL;
		}
	}
}
{
	if (PyTuple_Check(_obj4)) {
		if (PyArg_ParseTuple(_obj4, "llll", &rect_input_nullok0.left, &rect_input_nullok0.top, &rect_input_nullok0.right, &rect_input_nullok0.bottom) == 0) {
			return PyErr_Format(PyExc_TypeError, "%s: This param must be a tuple of four integers or None", "ScrollWindowEx");
		}
		_arg4 = &rect_input_nullok0;
	} else {
		if (_obj4 == Py_None) {
            _arg4 = NULL;
        } else {
            PyErr_SetString(PyExc_TypeError, "This param must be a tuple of four integers or None");
            return NULL;
		}
	}
}
{
	if (!PyWinObject_AsHANDLE(_obj5, (HANDLE *)&_arg5))
		return NULL;
}
{
	Py_BEGIN_ALLOW_THREADS
	    _result = (int_regiontype )ScrollWindowEx(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7);

	Py_END_ALLOW_THREADS
	if (_result==ERROR){
		
		return PyWin_SetAPIError("ScrollWindowEx");
		}
}    _resultobj = Py_BuildValue("i",_result);
{
    PyObject *o;
    o = Py_BuildValue("llll", _arg6->left, _arg6->top, _arg6->right, _arg6->bottom);
    if (!_resultobj) {
      _resultobj = o;
    } else if (_resultobj == Py_None) {
      Py_DECREF(Py_None);
      _resultobj = o;
    } else {
      if (!PyList_Check(_resultobj)) {
	PyObject *o2 = _resultobj;
	_resultobj = PyList_New(0);
	PyList_Append(_resultobj,o2);
	Py_XDECREF(o2);
      }
      PyList_Append(_resultobj,o);
      Py_XDECREF(o);
    }
}
    return _resultobj;
}

static PyObject *_wrap_WindowFromPoint(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HWND  _result;
    POINT * _arg0;
    POINT  point_input;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:WindowFromPoint",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsPOINT(_obj0, &point_input))
		return NULL;
	_arg0 = &point_input;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HWND )WindowFromPoint(*_arg0);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("WindowFromPoint", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_ChildWindowFromPoint(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HWND  _result;
    HWND  _arg0;
    POINT * _arg1;
    PyObject * _obj0 = 0;
    POINT  point_input;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OO:ChildWindowFromPoint",&_obj0,&_obj1)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsPOINT(_obj1, &point_input))
		return NULL;
	_arg1 = &point_input;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HWND )ChildWindowFromPoint(_arg0,*_arg1);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("ChildWindowFromPoint", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_ChildWindowFromPointEx(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HWND  _result;
    HWND  _arg0;
    POINT * _arg1;
    int  _arg2;
    PyObject * _obj0 = 0;
    POINT  point_input;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"OOi:ChildWindowFromPointEx",&_obj0,&_obj1,&_arg2)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
	if (!PyWinObject_AsPOINT(_obj1, &point_input))
		return NULL;
	_arg1 = &point_input;
}
{
      Py_BEGIN_ALLOW_THREADS
      SetLastError(0);
          _result = (HWND )ChildWindowFromPointEx(_arg0,*_arg1,_arg2);

      Py_END_ALLOW_THREADS
      DWORD le;
      if (_result==0 && (le=GetLastError())) {
           
           return PyWin_SetAPIError("ChildWindowFromPointEx", le);
      }
}{
	_resultobj=PyWinLong_FromHANDLE(_result);
}
    return _resultobj;
}

static PyObject *_wrap_UnregisterDeviceNotification(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HANDLE  _arg0;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"O:UnregisterDeviceNotification",&_obj0)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, &_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )UnregisterDeviceNotification(_arg0);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("UnregisterDeviceNotification");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyObject *_wrap_RegisterHotKey(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BOOLAPI  _result;
    HWND  _arg0;
    int  _arg1;
    UINT  _arg2;
    UINT  _arg3;
    PyObject * _obj0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"Oiii:RegisterHotKey",&_obj0,&_arg1,&_arg2,&_arg3)) 
        return NULL;
{
	if (!PyWinObject_AsHANDLE(_obj0, (HANDLE *)&_arg0))
		return NULL;
}
{
      Py_BEGIN_ALLOW_THREADS
          _result = (BOOLAPI )RegisterHotKey(_arg0,_arg1,_arg2,_arg3);

      Py_END_ALLOW_THREADS
      if (!_result)  {
           
           return PyWin_SetAPIError("RegisterHotKey");
      }
}{
	_resultobj = Py_None;
	Py_INCREF(Py_None);
}
    return _resultobj;
}

static PyMethodDef win32guiMethods[] = {
	 { "RegisterHotKey", _wrap_RegisterHotKey, 1 },
	 { "UnregisterDeviceNotification", _wrap_UnregisterDeviceNotification, 1 },
	 { "RegisterDeviceNotification", PyRegisterDeviceNotification, 1 },
	 { "EnumPropsEx", PyEnumPropsEx, 1 },
	 { "DrawTextW", pfnPyDrawTextW, 1 },
	 { "ExtCreatePen", PyExtCreatePen, 1 },
	 { "CreateBrushIndirect", PyCreateBrushIndirect, 1 },
	 { "AnimateWindow", pfnPyAnimateWindow, 1 },
	 { "UpdateLayeredWindow", pfnPyUpdateLayeredWindow, 1 },
	 { "GetLayeredWindowAttributes", pfnPyGetLayeredWindowAttributes, 1 },
	 { "SetLayeredWindowAttributes", pfnPySetLayeredWindowAttributes, 1 },
	 { "SystemParametersInfo", pfnPySystemParametersInfo, 1 },
	 { "GetOpenFileNameW", pfnPyGetOpenFileNameW, 1 },
	 { "GetSaveFileNameW", pfnPyGetSaveFileNameW, 1 },
	 { "CreateDC", PyCreateDC, 1 },
	 { "ListView_SortItemsEx", PyListView_SortItemsEx, 1 },
	 { "ListView_SortItems", PyListView_SortItems, 1 },
	 { "ChildWindowFromPointEx", _wrap_ChildWindowFromPointEx, 1 },
	 { "ChildWindowFromPoint", _wrap_ChildWindowFromPoint, 1 },
	 { "WindowFromPoint", _wrap_WindowFromPoint, 1 },
	 { "GetClassName", PyGetClassName, 1 },
	 { "GetScrollInfo", PyGetScrollInfo, 1 },
	 { "SetScrollInfo", PySetScrollInfo, 1 },
	 { "ScrollWindowEx", _wrap_ScrollWindowEx, 1 },
	 { "DestroyCaret", _wrap_DestroyCaret, 1 },
	 { "CreateCaret", _wrap_CreateCaret, 1 },
	 { "ReleaseDC", _wrap_ReleaseDC, 1 },
	 { "_TrackMouseEvent", _wrap__TrackMouseEvent, 1 },
	 { "SetCapture", _wrap_SetCapture, 1 },
	 { "GetCapture", _wrap_GetCapture, 1 },
	 { "ReleaseCapture", _wrap_ReleaseCapture, 1 },
	 { "IsChild", _wrap_IsChild, 1 },
	 { "IsWindow", _wrap_IsWindow, 1 },
	 { "IsIconic", _wrap_IsIconic, 1 },
	 { "GetWindowDC", _wrap_GetWindowDC, 1 },
	 { "GetWindow", _wrap_GetWindow, 1 },
	 { "GetDesktopWindow", _wrap_GetDesktopWindow, 1 },
	 { "GetCursorPos", _wrap_GetCursorPos, 1 },
	 { "SetParent", _wrap_SetParent, 1 },
	 { "GetParent", _wrap_GetParent, 1 },
	 { "CreateWindowEx", _wrap_CreateWindowEx, 1 },
	 { "CreateEllipticRgnIndirect", _wrap_CreateEllipticRgnIndirect, 1 },
	 { "CreateRectRgnIndirect", _wrap_CreateRectRgnIndirect, 1 },
	 { "CreateRoundRectRgn", _wrap_CreateRoundRectRgn, 1 },
	 { "GetPath", PyGetPath, 1 },
	 { "PathToRegion", _wrap_PathToRegion, 1 },
	 { "SetMiterLimit", _wrap_SetMiterLimit, 1 },
	 { "GetMiterLimit", _wrap_GetMiterLimit, 1 },
	 { "StrokeAndFillPath", _wrap_StrokeAndFillPath, 1 },
	 { "StrokePath", _wrap_StrokePath, 1 },
	 { "WidenPath", _wrap_WidenPath, 1 },
	 { "FillPath", _wrap_FillPath, 1 },
	 { "FlattenPath", _wrap_FlattenPath, 1 },
	 { "CloseFigure", _wrap_CloseFigure, 1 },
	 { "AbortPath", _wrap_AbortPath, 1 },
	 { "EndPath", _wrap_EndPath, 1 },
	 { "BeginPath", _wrap_BeginPath, 1 },
	 { "EndPaint", _wrap_EndPaint, 1 },
	 { "BeginPaint", _wrap_BeginPaint, 1 },
	 { "RoundRect", _wrap_RoundRect, 1 },
	 { "Rectangle", _wrap_Rectangle, 1 },
	 { "OffsetRgn", _wrap_OffsetRgn, 1 },
	 { "GetRgnBox", _wrap_GetRgnBox, 1 },
	 { "InvalidateRgn", _wrap_InvalidateRgn, 1 },
	 { "ValidateRgn", _wrap_ValidateRgn, 1 },
	 { "SetWindowRgn", _wrap_SetWindowRgn, 1 },
	 { "GetWindowRgn", _wrap_GetWindowRgn, 1 },
	 { "GetUpdateRgn", _wrap_GetUpdateRgn, 1 },
	 { "WindowFromDC", _wrap_WindowFromDC, 1 },
	 { "InvertRect", _wrap_InvertRect, 1 },
	 { "FrameRect", _wrap_FrameRect, 1 },
	 { "InvalidateRect", _wrap_InvalidateRect, 1 },
	 { "GetSysColorBrush", _wrap_GetSysColorBrush, 1 },
	 { "GetSysColor", _wrap_GetSysColor, 1 },
	 { "CreatePen", _wrap_CreatePen, 1 },
	 { "CreateHatchBrush", _wrap_CreateHatchBrush, 1 },
	 { "CreatePatternBrush", _wrap_CreatePatternBrush, 1 },
	 { "CreateSolidBrush", _wrap_CreateSolidBrush, 1 },
	 { "DrawAnimatedRects", _wrap_DrawAnimatedRects, 1 },
	 { "CombineRgn", _wrap_CombineRgn, 1 },
	 { "SetRectRgn", _wrap_SetRectRgn, 1 },
	 { "RectInRegion", _wrap_RectInRegion, 1 },
	 { "PtInRect", _wrap_PtInRect, 1 },
	 { "PtInRegion", _wrap_PtInRegion, 1 },
	 { "EqualRgn", _wrap_EqualRgn, 1 },
	 { "InvertRgn", _wrap_InvertRgn, 1 },
	 { "FrameRgn", _wrap_FrameRgn, 1 },
	 { "PaintRgn", _wrap_PaintRgn, 1 },
	 { "FillRgn", _wrap_FillRgn, 1 },
	 { "FillRect", _wrap_FillRect, 1 },
	 { "DrawEdge", _wrap_DrawEdge, 1 },
	 { "SetBkColor", _wrap_SetBkColor, 1 },
	 { "GetBkColor", _wrap_GetBkColor, 1 },
	 { "SetBkMode", _wrap_SetBkMode, 1 },
	 { "GetBkMode", _wrap_GetBkMode, 1 },
	 { "SetTextColor", _wrap_SetTextColor, 1 },
	 { "GetTextColor", _wrap_GetTextColor, 1 },
	 { "ExtTextOut", PyExtTextOut, 1 },
	 { "CreatePolygonRgn", PyCreatePolygonRgn, 1 },
	 { "PlgBlt", PyPlgBlt, 1 },
	 { "PolyBezierTo", PyPolyBezierTo, 1 },
	 { "PolyBezier", PyPolyBezier, 1 },
	 { "PolylineTo", PyPolylineTo, 1 },
	 { "Polyline", PyPolyline, 1 },
	 { "Polygon", PyPolygon, 1 },
	 { "SetArcDirection", _wrap_SetArcDirection, 1 },
	 { "GetArcDirection", _wrap_GetArcDirection, 1 },
	 { "GetCurrentPositionEx", _wrap_GetCurrentPositionEx, 1 },
	 { "MoveToEx", _wrap_MoveToEx, 1 },
	 { "SetPixelV", _wrap_SetPixelV, 1 },
	 { "SetROP2", PySetROP2, 1 },
	 { "GetROP2", PyGetROP2, 1 },
	 { "GetPixel", PyGetPixel, 1 },
	 { "SetPixel", PySetPixel, 1 },
	 { "ExtFloodFill", _wrap_ExtFloodFill, 1 },
	 { "Chord", _wrap_Chord, 1 },
	 { "AngleArc", PyAngleArc, 1 },
	 { "ArcTo", _wrap_ArcTo, 1 },
	 { "Arc", _wrap_Arc, 1 },
	 { "Pie", _wrap_Pie, 1 },
	 { "Ellipse", _wrap_Ellipse, 1 },
	 { "LineTo", _wrap_LineTo, 1 },
	 { "DrawText", _wrap_DrawText, 1 },
	 { "DrawFocusRect", _wrap_DrawFocusRect, 1 },
	 { "GetMenuInfo", PyGetMenuInfo, 1 },
	 { "SetMenuInfo", PySetMenuInfo, 1 },
	 { "CheckMenuRadioItem", _wrap_CheckMenuRadioItem, 1 },
	 { "SetMenuItemBitmaps", _wrap_SetMenuItemBitmaps, 1 },
	 { "GetMenuItemID", _wrap_GetMenuItemID, 1 },
	 { "ModifyMenu", _wrap_ModifyMenu, 1 },
	 { "GetSubMenu", _wrap_GetSubMenu, 1 },
	 { "CheckMenuItem", _wrap_CheckMenuItem, 1 },
	 { "EnableMenuItem", _wrap_EnableMenuItem, 1 },
	 { "InsertMenu", _wrap_InsertMenu, 1 },
	 { "AppendMenu", _wrap_AppendMenu, 1 },
	 { "GetMenuDefaultItem", _wrap_GetMenuDefaultItem, 1 },
	 { "SetMenuDefaultItem", _wrap_SetMenuDefaultItem, 1 },
	 { "GetMenuState", _wrap_GetMenuState, 1 },
	 { "GetMenuItemRect", _wrap_GetMenuItemRect, 1 },
	 { "GetMenuItemCount", _wrap_GetMenuItemCount, 1 },
	 { "GetMenuItemInfo", _wrap_GetMenuItemInfo, 1 },
	 { "SetMenuItemInfo", _wrap_SetMenuItemInfo, 1 },
	 { "InsertMenuItem", _wrap_InsertMenuItem, 1 },
	 { "GetOpenFileName", _wrap_GetOpenFileName, 1 },
	 { "GradientFill", PyGradientFill, 1 },
	 { "SetViewportExtEx", PySetViewportExtEx, 1 },
	 { "GetViewportExtEx", PyGetViewportExtEx, 1 },
	 { "SetWindowExtEx", PySetWindowExtEx, 1 },
	 { "GetWindowExtEx", PyGetWindowExtEx, 1 },
	 { "SetViewportOrgEx", _wrap_SetViewportOrgEx, 1 },
	 { "GetViewportOrgEx", _wrap_GetViewportOrgEx, 1 },
	 { "SetWindowOrgEx", _wrap_SetWindowOrgEx, 1 },
	 { "GetWindowOrgEx", _wrap_GetWindowOrgEx, 1 },
	 { "CombineTransform", PyCombineTransform, 1 },
	 { "ModifyWorldTransform", PyModifyWorldTransform, 1 },
	 { "SetWorldTransform", PySetWorldTransform, 1 },
	 { "GetWorldTransform", PyGetWorldTransform, 1 },
	 { "SetPolyFillMode", PySetPolyFillMode, 1 },
	 { "GetPolyFillMode", PyGetPolyFillMode, 1 },
	 { "SetLayout", PySetLayout, 1 },
	 { "GetLayout", PyGetLayout, 1 },
	 { "SetGraphicsMode", PySetGraphicsMode, 1 },
	 { "GetGraphicsMode", PyGetGraphicsMode, 1 },
	 { "SetMapMode", PySetMapMode, 1 },
	 { "GetMapMode", PyGetMapMode, 1 },
	 { "GetTextFace", PyGetTextFace, 1 },
	 { "SetTextAlign", PySetTextAlign, 1 },
	 { "GetTextAlign", PyGetTextAlign, 1 },
	 { "SetTextCharacterExtra", PySetTextCharacterExtra, 1 },
	 { "GetTextCharacterExtra", PyGetTextCharacterExtra, 1 },
	 { "GetTextMetrics", PyGetTextMetrics, 1 },
	 { "GetTextExtentPoint32", PyGetTextExtentPoint32, 1 },
	 { "RedrawWindow", _wrap_RedrawWindow, 1 },
	 { "PaintDesktop", _wrap_PaintDesktop, 1 },
	 { "ClientToScreen", _wrap_ClientToScreen, 1 },
	 { "ScreenToClient", _wrap_ScreenToClient, 1 },
	 { "GetIconInfo", _wrap_GetIconInfo, 1 },
	 { "DestroyIcon", _wrap_DestroyIcon, 1 },
	 { "ExtractIconEx", PyExtractIconEx, 1 },
	 { "ExtractIcon", _wrap_ExtractIcon, 1 },
	 { "CommDlgExtendedError", _wrap_CommDlgExtendedError, 1 },
	 { "lpstr", Pylpstr, 1 },
	 { "TrackPopupMenu", _wrap_TrackPopupMenu, 1 },
	 { "CreatePopupMenu", _wrap_CreatePopupMenu, 1 },
	 { "CreateMenu", _wrap_CreateMenu, 1 },
	 { "RemoveMenu", _wrap_RemoveMenu, 1 },
	 { "DeleteMenu", _wrap_DeleteMenu, 1 },
	 { "CloseWindow", _wrap_CloseWindow, 1 },
	 { "MoveWindow", _wrap_MoveWindow, 1 },
	 { "DrawMenuBar", _wrap_DrawMenuBar, 1 },
	 { "GetSystemMenu", _wrap_GetSystemMenu, 1 },
	 { "Edit_GetLine", PyEdit_GetLine, 1 },
	 { "Shell_NotifyIcon", _wrap_Shell_NotifyIcon, 1 },
	 { "LOWORD", PyLOWORD, 1 },
	 { "HIWORD", PyHIWORD, 1 },
	 { "PeekMessage", _wrap_PeekMessage, 1 },
	 { "TranslateAccelerator", _wrap_TranslateAccelerator, 1 },
	 { "DispatchMessage", _wrap_DispatchMessage, 1 },
	 { "TranslateMessage", _wrap_TranslateMessage, 1 },
	 { "GetMessage", _wrap_GetMessage, 1 },
	 { "PumpWaitingMessages", PyPumpWaitingMessages, 1 },
	 { "PumpMessages", PyPumpMessages, 1 },
	 { "UnregisterClass", PyUnregisterClass, 1 },
	 { "RegisterClass", PyRegisterClass, 1 },
	 { "SetWindowPlacement", PySetWindowPlacement, 1 },
	 { "GetWindowPlacement", PyGetWindowPlacement, 1 },
	 { "SetWindowPos", _wrap_SetWindowPos, 1 },
	 { "WaitMessage", _wrap_WaitMessage, 1 },
	 { "PostQuitMessage", _wrap_PostQuitMessage, 1 },
	 { "GetStockObject", _wrap_GetStockObject, 1 },
	 { "GetWindowRect", _wrap_GetWindowRect, 1 },
	 { "GetModuleHandle", _wrap_GetModuleHandle, 1 },
	 { "GetCurrentObject", _wrap_GetCurrentObject, 1 },
	 { "SelectObject", _wrap_SelectObject, 1 },
	 { "CreateBitmap", _wrap_CreateBitmap, 1 },
	 { "CreateCompatibleBitmap", _wrap_CreateCompatibleBitmap, 1 },
	 { "CreateCompatibleDC", _wrap_CreateCompatibleDC, 1 },
	 { "DeleteDC", _wrap_DeleteDC, 1 },
	 { "RestoreDC", _wrap_RestoreDC, 1 },
	 { "SaveDC", _wrap_SaveDC, 1 },
	 { "GetDC", _wrap_GetDC, 1 },
	 { "GetClientRect", _wrap_GetClientRect, 1 },
	 { "GetForegroundWindow", _wrap_GetForegroundWindow, 1 },
	 { "SetForegroundWindow", _wrap_SetForegroundWindow, 1 },
	 { "GetActiveWindow", _wrap_GetActiveWindow, 1 },
	 { "SetActiveWindow", _wrap_SetActiveWindow, 1 },
	 { "BringWindowToTop", _wrap_BringWindowToTop, 1 },
	 { "UpdateWindow", _wrap_UpdateWindow, 1 },
	 { "GetFocus", _wrap_GetFocus, 1 },
	 { "SetFocus", _wrap_SetFocus, 1 },
	 { "IsWindowEnabled", _wrap_IsWindowEnabled, 1 },
	 { "IsWindowVisible", _wrap_IsWindowVisible, 1 },
	 { "ShowWindow", _wrap_ShowWindow, 1 },
	 { "ShowCaret", _wrap_ShowCaret, 1 },
	 { "GetCaretPos", _wrap_GetCaretPos, 1 },
	 { "SetCaretPos", _wrap_SetCaretPos, 1 },
	 { "HideCaret", _wrap_HideCaret, 1 },
	 { "GetDoubleClickTime", _wrap_GetDoubleClickTime, 1 },
	 { "SetDoubleClickTime", _wrap_SetDoubleClickTime, 1 },
	 { "DragDetect", _wrap_DragDetect, 1 },
	 { "DragAcceptFiles", _wrap_DragAcceptFiles, 1 },
	 { "FindWindowEx", _wrap_FindWindowEx, 1 },
	 { "FindWindow", _wrap_FindWindow, 1 },
	 { "EnableWindow", _wrap_EnableWindow, 1 },
	 { "DestroyWindow", _wrap_DestroyWindow, 1 },
	 { "CreateWindow", _wrap_CreateWindow, 1 },
	 { "MessageBeep", _wrap_MessageBeep, 1 },
	 { "MessageBox", _wrap_MessageBox, 1 },
	 { "ImageList_SetOverlayImage", _wrap_ImageList_SetOverlayImage, 1 },
	 { "ImageList_SetBkColor", _wrap_ImageList_SetBkColor, 1 },
	 { "ImageList_ReplaceIcon", _wrap_ImageList_ReplaceIcon, 1 },
	 { "ImageList_Replace", _wrap_ImageList_Replace, 1 },
	 { "ImageList_Remove", _wrap_ImageList_Remove, 1 },
	 { "ImageList_LoadBitmap", _wrap_ImageList_LoadBitmap, 1 },
	 { "ImageList_LoadImage", _wrap_ImageList_LoadImage, 1 },
	 { "ImageList_GetImageCount", _wrap_ImageList_GetImageCount, 1 },
	 { "ImageList_GetIcon", _wrap_ImageList_GetIcon, 1 },
	 { "ImageList_DrawEx", _wrap_ImageList_DrawEx, 1 },
	 { "ImageList_Draw", _wrap_ImageList_Draw, 1 },
	 { "ImageList_Destroy", _wrap_ImageList_Destroy, 1 },
	 { "ImageList_Create", _wrap_ImageList_Create, 1 },
	 { "ImageList_Add", _wrap_ImageList_Add, 1 },
	 { "AlphaBlend", PyAlphaBlend, 1 },
	 { "MaskBlt", PyMaskBlt, 1 },
	 { "TransparentBlt", PyTransparentBlt, 1 },
	 { "GetStretchBltMode", _wrap_GetStretchBltMode, 1 },
	 { "SetStretchBltMode", _wrap_SetStretchBltMode, 1 },
	 { "PatBlt", _wrap_PatBlt, 1 },
	 { "StretchBlt", _wrap_StretchBlt, 1 },
	 { "BitBlt", _wrap_BitBlt, 1 },
	 { "DeleteObject", PyDeleteObject, 1 },
	 { "LoadImage", _wrap_LoadImage, 1 },
	 { "CreateIconFromResource", PyCreateIconFromResource, 1 },
	 { "CreateIconIndirect", _wrap_CreateIconIndirect, 1 },
	 { "DrawIconEx", _wrap_DrawIconEx, 1 },
	 { "DrawIcon", _wrap_DrawIcon, 1 },
	 { "CopyIcon", _wrap_CopyIcon, 1 },
	 { "LoadIcon", _wrap_LoadIcon, 1 },
	 { "GetMenu", _wrap_GetMenu, 1 },
	 { "SetMenu", _wrap_SetMenu, 1 },
	 { "DestroyMenu", _wrap_DestroyMenu, 1 },
	 { "LoadMenu", _wrap_LoadMenu, 1 },
	 { "DestroyAcceleratorTable", _wrap_DestroyAcceleratorTable, 1 },
	 { "CreateAcceleratorTable", PyCreateAcceleratorTable, 1 },
	 { "GetCursorInfo", PyGetCursorInfo, 1 },
	 { "GetCursor", _wrap_GetCursor, 1 },
	 { "SetCursor", _wrap_SetCursor, 1 },
	 { "LoadCursor", _wrap_LoadCursor, 1 },
	 { "InitCommonControlsEx", PyInitCommonControlsEx, 1 },
	 { "InitCommonControls", _wrap_InitCommonControls, 1 },
	 { "GetWindowTextLength", _wrap_GetWindowTextLength, 1 },
	 { "GetWindowText", PyGetWindowText, 1 },
	 { "SetWindowText", _wrap_SetWindowText, 1 },
	 { "GetNextDlgGroupItem", _wrap_GetNextDlgGroupItem, 1 },
	 { "GetNextDlgTabItem", _wrap_GetNextDlgTabItem, 1 },
	 { "SetDlgItemText", _wrap_SetDlgItemText, 1 },
	 { "GetDlgItemText", PyGetDlgItemText, 1 },
	 { "GetDlgCtrlID", _wrap_GetDlgCtrlID, 1 },
	 { "SetDlgItemInt", _wrap_SetDlgItemInt, 1 },
	 { "GetDlgItemInt", PyGetDlgItemInt, 1 },
	 { "GetDlgItem", _wrap_GetDlgItem, 1 },
	 { "EndDialog", _wrap_EndDialog, 1 },
	 { "CreateDialogIndirectParam", PyCreateDialogIndirect, 1 },
	 { "CreateDialogIndirect", PyCreateDialogIndirect, 1 },
	 { "DialogBoxIndirectParam", PyDialogBoxIndirect, 1 },
	 { "DialogBoxIndirect", PyDialogBoxIndirect, 1 },
	 { "DialogBoxParam", PyDialogBox, 1 },
	 { "DialogBox", PyDialogBox, 1 },
	 { "EnumChildWindows", PyEnumChildWindows, 1 },
	 { "EnumThreadWindows", PyEnumThreadWindows, 1 },
	 { "EnumWindows", PyEnumWindows, 1 },
	 { "DefWindowProc", _wrap_DefWindowProc, 1 },
	 { "RegisterWindowMessage", _wrap_RegisterWindowMessage, 1 },
	 { "ReplyMessage", _wrap_ReplyMessage, 1 },
	 { "PostThreadMessage", _wrap_PostThreadMessage, 1 },
	 { "PostMessage", _wrap_PostMessage, 1 },
	 { "SendMessageTimeout", PySendMessageTimeout, 1 },
	 { "SendMessage", PySendMessage, 1 },
	 { "CallWindowProc", PyCallWindowProc, 1 },
	 { "SetWindowLong", PySetWindowLong, 1 },
	 { "GetClassLong", _wrap_GetClassLong, 1 },
	 { "GetWindowLong", _wrap_GetWindowLong, 1 },
	 { "FlashWindowEx", PyFlashWindowEx, 1 },
	 { "FlashWindow", _wrap_FlashWindow, 1 },
	 { "PyGetBufferAddressAndLen", PyGetBufferAddressAndLen, 1 },
	 { "PyGetArraySignedLong", PyGetArraySignedLong, 1 },
	 { "PySetMemory", PySetMemory, 1 },
	 { "PySetString", PySetString, 1 },
	 { "PyGetString", PyGetString, 1 },
	 { "PyGetMemory", PyGetMemory, 1 },
	 { "PyMakeBuffer", PyMakeBuffer, 1 },
	 { "GetObjectType", PyGetObjectType, 1 },
	 { "GetObject", PyGetObject, 1 },
	 { "CreateFontIndirect", _wrap_CreateFontIndirect, 1 },
	 { "EnumFontFamilies", PyEnumFontFamilies, 1 },
	 { "LOGFONT", MakeLOGFONT, 1 },
	 { "set_logger", set_logger, 1 },
	 { "WNDCLASS", MakeWNDCLASS, 1 },
	 { NULL, NULL }
};
static PyObject *SWIG_globals;
#ifdef __cplusplus
extern "C" 
#endif
#if (PY_VERSION_HEX < 0x03000000)
#define MODINIT_ERROR_RETURN
SWIGEXPORT(void,initwin32gui)() {
#else
#define MODINIT_ERROR_RETURN NULL
SWIGEXPORT(PyObject*,  PyInit_win32gui)(void) {
#endif
	 PyObject *m, *d;
	 SWIG_globals = SWIG_newvarlink();
#if (PY_VERSION_HEX < 0x03000000)
	 m = Py_InitModule("win32gui", win32guiMethods);
	 d = PyModule_GetDict(m);
#else
  static PyModuleDef win32gui_def = {
    PyModuleDef_HEAD_INIT,
      "win32gui",
      "",
      -1,
      win32guiMethods,
      };
  m = PyModule_Create(&win32gui_def);
  if (!m)
    return NULL;
  d = PyModule_GetDict(m);
  if (!d)
    return NULL;
#endif

#ifndef SWIG_PYTHONCOM
/* This code only valid if non COM SWIG builds */
#ifndef PYCOM_EXPORT
	 PyDict_SetItemString(d,"UNICODE", PyInt_FromLong(
#ifdef UNICODE
	1
#else
	0
#endif
	));
#endif
  PyWinGlobals_Ensure();
  PyDict_SetItemString(d, "error", PyWinExc_ApiError);
#endif SWIG_PYTHONCOM

PyEval_InitThreads(); /* Start the interpreter's thread-awareness */
PyDict_SetItemString(d, "dllhandle", PyWinLong_FromVoidPtr(g_dllhandle));
PyDict_SetItemString(d, "error", PyWinExc_ApiError);

if (PyType_Ready(&PyWNDCLASSType) == -1 ||
	PyType_Ready(&PyBITMAPType) == -1 ||
	PyType_Ready(&PyLOGFONTType) == -1)
	PYWIN_MODULE_INIT_RETURN_ERROR;

// Expose the window procedure and window class dicts to aid debugging
g_AtomMap = PyDict_New();
g_HWNDMap = PyDict_New();
g_DLGMap = PyDict_New();
#ifdef Py_DEBUG
PyDict_SetItemString(d, "g_AtomMap", g_AtomMap);
PyDict_SetItemString(d, "g_HWNDMap", g_HWNDMap);
PyDict_SetItemString(d, "g_DLGMap", g_DLGMap);
#endif

PyDict_SetItemString(d, "UNICODE",
#ifdef UNICODE
					Py_True
#else
					Py_False
#endif
						);

// hack borrowed from win32security since version of SWIG we use doesn't do keyword arguments
#ifdef WINXPGUI
for (PyMethodDef *pmd = winxpguiMethods; pmd->ml_name; pmd++)
#else
for (PyMethodDef *pmd = win32guiMethods; pmd->ml_name; pmd++)
#endif
	if	 (strcmp(pmd->ml_name, "SetLayeredWindowAttributes")==0
		||strcmp(pmd->ml_name, "GetLayeredWindowAttributes")==0
		||strcmp(pmd->ml_name, "UpdateLayeredWindow")==0
		||strcmp(pmd->ml_name, "AnimateWindow")==0
		||strcmp(pmd->ml_name, "GetOpenFileNameW")==0
		||strcmp(pmd->ml_name, "GetSaveFileNameW")==0
		||strcmp(pmd->ml_name, "SystemParametersInfo")==0
		||strcmp(pmd->ml_name, "DrawTextW")==0
		)
		pmd->ml_flags = METH_VARARGS | METH_KEYWORDS;

HMODULE hmodule=GetModuleHandle(TEXT("user32.dll"));
if (hmodule==NULL)
	hmodule=LoadLibrary(TEXT("user32.dll"));
if (hmodule){
	pfnSetLayeredWindowAttributes=(SetLayeredWindowAttributesfunc)GetProcAddress(hmodule,"SetLayeredWindowAttributes");
	pfnGetLayeredWindowAttributes=(GetLayeredWindowAttributesfunc)GetProcAddress(hmodule,"GetLayeredWindowAttributes");
	pfnUpdateLayeredWindow=(UpdateLayeredWindowfunc)GetProcAddress(hmodule,"UpdateLayeredWindow");
	pfnAnimateWindow=(AnimateWindowfunc)GetProcAddress(hmodule,"AnimateWindow");
	pfnGetMenuInfo=(GetMenuInfofunc)GetProcAddress(hmodule,"GetMenuInfo");
	pfnSetMenuInfo=(SetMenuInfofunc)GetProcAddress(hmodule,"SetMenuInfo");
	pfnDrawTextW=(DrawTextWfunc)GetProcAddress(hmodule, "DrawTextW");
	}

hmodule=GetModuleHandle(TEXT("gdi32.dll"));
if (hmodule==NULL)
	hmodule=LoadLibrary(TEXT("gdi32.dll"));
if (hmodule){
	pfnAngleArc=(AngleArcfunc)GetProcAddress(hmodule,"AngleArc");
	pfnPlgBlt=(PlgBltfunc)GetProcAddress(hmodule,"PlgBlt");
	pfnGetWorldTransform=(GetWorldTransformfunc)GetProcAddress(hmodule,"GetWorldTransform");
	pfnSetWorldTransform=(SetWorldTransformfunc)GetProcAddress(hmodule,"SetWorldTransform");
	pfnModifyWorldTransform=(ModifyWorldTransformfunc)GetProcAddress(hmodule,"ModifyWorldTransform");
	pfnCombineTransform=(CombineTransformfunc)GetProcAddress(hmodule,"CombineTransform");
	pfnMaskBlt=(MaskBltfunc)GetProcAddress(hmodule,"MaskBlt");
	pfnGetLayout=(GetLayoutfunc)GetProcAddress(hmodule,"GetLayout");
	pfnSetLayout=(SetLayoutfunc)GetProcAddress(hmodule,"SetLayout");
	}

hmodule=GetModuleHandle(TEXT("msimg32.dll"));
if (hmodule==NULL)
	hmodule=LoadLibrary(TEXT("msimg32.dll"));
if (hmodule){
	pfnGradientFill=(GradientFillfunc)GetProcAddress(hmodule,"GradientFill");
	pfnTransparentBlt=(TransparentBltfunc)GetProcAddress(hmodule,"TransparentBlt");
	pfnAlphaBlend=(AlphaBlendfunc)GetProcAddress(hmodule,"AlphaBlend");
	}
	 PyDict_SetItemString(d,"IMAGE_BITMAP", PyInt_FromLong((long) IMAGE_BITMAP));
	 PyDict_SetItemString(d,"IMAGE_CURSOR", PyInt_FromLong((long) IMAGE_CURSOR));
	 PyDict_SetItemString(d,"IMAGE_ICON", PyInt_FromLong((long) IMAGE_ICON));
	 PyDict_SetItemString(d,"LR_DEFAULTCOLOR", PyInt_FromLong((long) LR_DEFAULTCOLOR));
	 PyDict_SetItemString(d,"LR_CREATEDIBSECTION", PyInt_FromLong((long) LR_CREATEDIBSECTION));
	 PyDict_SetItemString(d,"LR_DEFAULTSIZE", PyInt_FromLong((long) LR_DEFAULTSIZE));
	 PyDict_SetItemString(d,"LR_LOADFROMFILE", PyInt_FromLong((long) LR_LOADFROMFILE));
	 PyDict_SetItemString(d,"LR_LOADMAP3DCOLORS", PyInt_FromLong((long) LR_LOADMAP3DCOLORS));
	 PyDict_SetItemString(d,"LR_LOADTRANSPARENT", PyInt_FromLong((long) LR_LOADTRANSPARENT));
	 PyDict_SetItemString(d,"LR_MONOCHROME", PyInt_FromLong((long) LR_MONOCHROME));
	 PyDict_SetItemString(d,"LR_SHARED", PyInt_FromLong((long) LR_SHARED));
	 PyDict_SetItemString(d,"LR_VGACOLOR", PyInt_FromLong((long) LR_VGACOLOR));
	 PyDict_SetItemString(d,"ILC_COLOR", PyInt_FromLong((long) ILC_COLOR));
	 PyDict_SetItemString(d,"ILC_COLOR4", PyInt_FromLong((long) ILC_COLOR4));
	 PyDict_SetItemString(d,"ILC_COLOR8", PyInt_FromLong((long) ILC_COLOR8));
	 PyDict_SetItemString(d,"ILC_COLOR16", PyInt_FromLong((long) ILC_COLOR16));
	 PyDict_SetItemString(d,"ILC_COLOR24", PyInt_FromLong((long) ILC_COLOR24));
	 PyDict_SetItemString(d,"ILC_COLOR32", PyInt_FromLong((long) ILC_COLOR32));
	 PyDict_SetItemString(d,"ILC_COLORDDB", PyInt_FromLong((long) ILC_COLORDDB));
	 PyDict_SetItemString(d,"ILC_MASK", PyInt_FromLong((long) ILC_MASK));
	 PyDict_SetItemString(d,"ILD_BLEND25", PyInt_FromLong((long) ILD_BLEND25));
	 PyDict_SetItemString(d,"ILD_FOCUS", PyInt_FromLong((long) ILD_FOCUS));
	 PyDict_SetItemString(d,"ILD_BLEND50", PyInt_FromLong((long) ILD_BLEND50));
	 PyDict_SetItemString(d,"ILD_SELECTED", PyInt_FromLong((long) ILD_SELECTED));
	 PyDict_SetItemString(d,"ILD_BLEND", PyInt_FromLong((long) ILD_BLEND));
	 PyDict_SetItemString(d,"ILD_MASK", PyInt_FromLong((long) ILD_MASK));
	 PyDict_SetItemString(d,"ILD_NORMAL", PyInt_FromLong((long) ILD_NORMAL));
	 PyDict_SetItemString(d,"ILD_TRANSPARENT", PyInt_FromLong((long) ILD_TRANSPARENT));
	 PyDict_SetItemString(d,"CLR_NONE", PyInt_FromLong((long) CLR_NONE));
	 PyDict_SetItemString(d,"NIF_ICON", PyInt_FromLong((long) NIF_ICON));
	 PyDict_SetItemString(d,"NIF_MESSAGE", PyInt_FromLong((long) NIF_MESSAGE));
	 PyDict_SetItemString(d,"NIF_TIP", PyInt_FromLong((long) NIF_TIP));
	 PyDict_SetItemString(d,"NIF_INFO", PyInt_FromLong((long) NIF_INFO));
	 PyDict_SetItemString(d,"NIF_STATE", PyInt_FromLong((long) NIF_STATE));
	 PyDict_SetItemString(d,"NIIF_WARNING", PyInt_FromLong((long) NIIF_WARNING));
	 PyDict_SetItemString(d,"NIIF_ERROR", PyInt_FromLong((long) NIIF_ERROR));
	 PyDict_SetItemString(d,"NIIF_NONE", PyInt_FromLong((long) NIIF_NONE));
	 PyDict_SetItemString(d,"NIIF_INFO", PyInt_FromLong((long) NIIF_INFO));
	 PyDict_SetItemString(d,"NIIF_ICON_MASK", PyInt_FromLong((long) NIIF_ICON_MASK));
	 PyDict_SetItemString(d,"NIIF_NOSOUND", PyInt_FromLong((long) NIIF_NOSOUND));
	 PyDict_SetItemString(d,"NIM_ADD", PyInt_FromLong((long) NIM_ADD));
	 PyDict_SetItemString(d,"NIM_DELETE", PyInt_FromLong((long) NIM_DELETE));
	 PyDict_SetItemString(d,"NIM_MODIFY", PyInt_FromLong((long) NIM_MODIFY));
	 PyDict_SetItemString(d,"NIM_SETVERSION", PyInt_FromLong((long) NIM_SETVERSION));
	 PyDict_SetItemString(d,"TPM_CENTERALIGN", PyInt_FromLong((long) TPM_CENTERALIGN));
	 PyDict_SetItemString(d,"TPM_LEFTALIGN", PyInt_FromLong((long) TPM_LEFTALIGN));
	 PyDict_SetItemString(d,"TPM_RIGHTALIGN", PyInt_FromLong((long) TPM_RIGHTALIGN));
	 PyDict_SetItemString(d,"TPM_BOTTOMALIGN", PyInt_FromLong((long) TPM_BOTTOMALIGN));
	 PyDict_SetItemString(d,"TPM_TOPALIGN", PyInt_FromLong((long) TPM_TOPALIGN));
	 PyDict_SetItemString(d,"TPM_VCENTERALIGN", PyInt_FromLong((long) TPM_VCENTERALIGN));
	 PyDict_SetItemString(d,"TPM_NONOTIFY", PyInt_FromLong((long) TPM_NONOTIFY));
	 PyDict_SetItemString(d,"TPM_RETURNCMD", PyInt_FromLong((long) TPM_RETURNCMD));
	 PyDict_SetItemString(d,"TPM_LEFTBUTTON", PyInt_FromLong((long) TPM_LEFTBUTTON));
	 PyDict_SetItemString(d,"TPM_RIGHTBUTTON", PyInt_FromLong((long) TPM_RIGHTBUTTON));
#if (PY_VERSION_HEX > 0x03000000)
	return m;
#endif
}
